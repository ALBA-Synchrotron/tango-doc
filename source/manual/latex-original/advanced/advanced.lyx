#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage{a4wide}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding latin1
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 5
\tocdepth 5
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Advanced features
\end_layout

\begin_layout Section
Attribute alarms
\end_layout

\begin_layout Standard
Each Tango attribute two several alarms.
 These alarms are :
\end_layout

\begin_layout Itemize
A four thresholds level alarm
\end_layout

\begin_layout Itemize
The read different than set (RDS
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
RDS
\end_layout

\end_inset

) alarm
\end_layout

\begin_layout Subsection
The level alarms
\end_layout

\begin_layout Standard
This alarm is defined for all Tango attribute read type and for numerical
 data type.
 The action of this alarm depend on the attribute value when it is read
 :
\end_layout

\begin_layout Itemize
If the attribute value is below or equal the attribute configuration 
\series bold
min_alarm
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
min-alarm
\end_layout

\end_inset


\series default
 parameter, the attribute quality factor is switched to Tango::ATTR_ALARM
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ATTR-ALARM
\end_layout

\end_inset

 and if the device state is Tango::ON, it is switched to Tango::ALARM.
 
\end_layout

\begin_layout Itemize
If the attribute value is below or equal the attribute configuration 
\series bold
min_warning
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
min-warning
\end_layout

\end_inset


\series default
 parameter, the attribute quality factor is switched to Tango::ATTR_WARNING
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ATTR-WARNING
\end_layout

\end_inset

 and if the device state is Tango::ON, it is switched to Tango::ALARM.
\end_layout

\begin_layout Itemize
If the attribute value is above or equal the attribute configuration 
\series bold
max_warning
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
max-warning
\end_layout

\end_inset


\series default
 parameter, the attribute quality factor is switched to Tango::ATTR_WARNING
\begin_inset Index idx
status open

\begin_layout Plain Layout
ATTR-WARNING
\end_layout

\end_inset

 and if the device state is Tango::ON, it is switched to Tango::ALARM.
\end_layout

\begin_layout Itemize
If the attribute value is above or equal the attribute configuration 
\series bold
max_alarm
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
max-alarm
\end_layout

\end_inset


\series default
 parameter, the attribute quality factor is switched to Tango::ATTR_ALARM
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ATTR-ALARM
\end_layout

\end_inset

 and if the device state is Tango::ON, it is switched to Tango::ALARM.
\end_layout

\begin_layout Standard
If the attribute is a spectrum or an image, then the alarm is set if any
 one of the attribute value satisfies the above criterium.
 By default, these four parameters are not defined and no check will be
 done.
\end_layout

\begin_layout Standard
The following figure is a drawing of attribute quality factor and device
 state values function of the the attribute value.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename alarm.eps
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Level alarm
\begin_inset CommandInset label
LatexCommand label
name "alarm_fig"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the min_warning and max_warning parameters are not set, the attribute
 quality factor will simply change between Tango::ATTR_ALARM and Tango::ATTR_VAL
ID function of the attribute value.
\end_layout

\begin_layout Subsection
The Read Different than Set (RDS) alarm
\end_layout

\begin_layout Standard
This alarm is defined only for attribute of the Tango::READ_WRITE and Tango::REA
D_WITH_WRITE read/write type and for numerical data type.
 When the attribute is read (or when the device state is requested), if
 the difference between its read value and the last written value is something
 more than or equal to an authorized delta and if at least a certain amount
 of milli seconds occurs since the last write operation, the attribute quality
 factor will be set to Tango::ATTR_ALARM
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ATTR-ALARM
\end_layout

\end_inset

 and if the device state is Tango::ON, it is switched to Tango::ALARM
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ALARM
\end_layout

\end_inset

.
 If the attribute is a spectrum or an image, then the alarm is set if any
 one of the attribute value's satisfies the above criterium.
 This alarm configuration is done with two attribute configuration parameters
 called 
\series bold
delta_val
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
delta-val
\end_layout

\end_inset


\series default
 and 
\series bold
delta_t
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
delta-t
\end_layout

\end_inset


\series default
.
 By default, these two parameters are not defined and no check will be done.
\end_layout

\begin_layout Section
Enumerated
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout

\series medium
Enumeration
\end_layout

\end_inset

 attribute
\end_layout

\begin_layout Standard
Since Tango release 9, enumerated attribute is supported using the new data
 type DevEnum
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
DevEnum
\end_layout

\end_inset

.
 This data type is not a real C++ enumeration because:
\end_layout

\begin_layout Enumerate
The enumerated value allways start with 0
\end_layout

\begin_layout Enumerate
Values are consecutive
\end_layout

\begin_layout Enumerate
It is transferred on the network as DevShort data type
\end_layout

\begin_layout Standard
One enumeration label is associated to each enumeration value.
 For the Tango kernel, it is this list of enumeration labels which will
 define the possible enumeration values.
 For instance if the enumeration has 3 labels, its value must be between
 0 and 2.
 There are two ways to define the enumeration labels:
\end_layout

\begin_layout Enumerate
At attribute creation time.
 This is the most common case when the list of possible enumeration values
 and labels are known at compile time.
 The Tango code generator Pogo generates for you the code needed to pass
 the enumeration labels to the Tango kernel.
\end_layout

\begin_layout Enumerate
In the user code when the enumeration values and labels are not known at
 compile time but retrieved during device startup phase.
 The user gives the possible enumeration values to the Tango kernel using
 the Attribute class 
\emph on
set_properties()
\emph default
 method.
\end_layout

\begin_layout Standard
A Tango client is able to retrieve the enumeration labels in the attribute
 configuration returned by instance by a call to the 
\emph on
DeviceProxy::get_attribute_config()
\emph default
 method.
 Using the 
\emph on
DeviceProxy::set_attribute_config()
\emph default
 call, a user may change the enumeration labels but not their number.
\end_layout

\begin_layout Subsection
Usage in a Tango class
\end_layout

\begin_layout Standard
Within a Tango class, you set the attribute value with a C++ enum or a DevShort
 variable.
 In case a DevShort variable is used, its value will be checked according
 to the enumeration labels list given to Tango kernel.
\end_layout

\begin_layout Subsubsection
Setting the labels with enumeration compile time knowledge
\end_layout

\begin_layout Standard
In such a case, the enumeration labels are given to Tango at the attribute
 creation time in the 
\emph on
attribute_factory
\emph default
 method of the XXXClass class.
 Let us take one example
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
\align block
     1  enum class Card: short
\end_layout

\begin_layout LyX-Code
     2  {
\end_layout

\begin_layout LyX-Code
     3      NORTH = 0,
\end_layout

\begin_layout LyX-Code
     4      SOUTH,
\end_layout

\begin_layout LyX-Code
     5      EAST,
\end_layout

\begin_layout LyX-Code
     6      WEST
\end_layout

\begin_layout LyX-Code
     7  };
\end_layout

\begin_layout LyX-Code
     8 
\end_layout

\begin_layout LyX-Code
     9  void XXXClass::attribute_factory(vector<Tango::Attr *> &att_list)
\end_layout

\begin_layout LyX-Code
    10  {
\end_layout

\begin_layout LyX-Code
    11      .....
\end_layout

\begin_layout LyX-Code
    12      TheEnumAttrib	*theenum = new TheEnumAttrib();
\end_layout

\begin_layout LyX-Code
    13      Tango::UserDefaultAttrProp theenum_prop;
\end_layout

\begin_layout LyX-Code
    14      vector<string> labels = {"North","South","East","West"};
\end_layout

\begin_layout LyX-Code
    15      theenum_prop.set_enum_labels(labels);
\end_layout

\begin_layout LyX-Code
    16      theenum->set_default_properties(theenum_prop);
\end_layout

\begin_layout LyX-Code
    17      att_list.push_back(theenum);
\end_layout

\begin_layout LyX-Code
    18      .....
\end_layout

\begin_layout LyX-Code
    19   }	
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
line 1-7 : The definition of the enumeration (C++11 in this example)
\end_layout

\begin_layout Standard
line 14 : A vector of strings with the enumeration labels is created.
 Because there is no way to get the labels from the enumeration definition,
 they are re-defined here.
\end_layout

\begin_layout Standard
line 15 : This vector is given to the theenum_prop object which contains
 the user default properties
\end_layout

\begin_layout Standard
line 16 : The user default properties are associated to the attribute
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
In most cases, all this code will be automatically generated by the Tango
 code generator Pogo.
 It is given here for completness.
\end_layout

\begin_layout Subsubsection
Setting the labels without enumeration compile time knowledge
\end_layout

\begin_layout Standard
In such a case, the enumeration labels are retrieved by the user in a way
 specific to the device and passed to Tango using the Attribute class 
\emph on
set_properties()
\emph default
 method.
 Let us take one example
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
\align block
     1  void MyDev::init_device()
\end_layout

\begin_layout LyX-Code
     2  {
\end_layout

\begin_layout LyX-Code
     3      ...
\end_layout

\begin_layout LyX-Code
     4  
\end_layout

\begin_layout LyX-Code
     5      Attribute &att = get_device_attr()->get_attr_by_name("TheEnumAtt");
\end_layout

\begin_layout LyX-Code
     6      MultiAttrProp<DevEnum> multi_prop;
\end_layout

\begin_layout LyX-Code
     7      att.get_properties(multi_prop);
\end_layout

\begin_layout LyX-Code
     8 
\end_layout

\begin_layout LyX-Code
     9      multi_prop.enum_labels = {....};
\end_layout

\begin_layout LyX-Code
    10      att.set_properties(multi_prop);
\end_layout

\begin_layout LyX-Code
    11      ....
\end_layout

\begin_layout LyX-Code
    12   }	
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
line 5 : Get a reference to the attribute object
\end_layout

\begin_layout Standard
line 7 : Retrieve the attribute properties
\end_layout

\begin_layout Standard
line 9 : Initialise the attribute labels in the set of attribute properties
\end_layout

\begin_layout Standard
line 10 : Set the attribute properties
\end_layout

\begin_layout Subsubsection
Setting the attribute value
\end_layout

\begin_layout Standard
It is possible to set the attribute value using either a classical DevShort
 variable or using a variable of the C++ enumeration.
 The following example is when you have compile time knowledge of the enumeratio
n definition.
 We assume that the enumeration is the same than the one defined above (Card
 enumeration)
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
\align block
     1  enum Card points;
\end_layout

\begin_layout LyX-Code
     2  
\end_layout

\begin_layout LyX-Code
     3  void MyDev::read_TheEnum(Attribute &att)
\end_layout

\begin_layout LyX-Code
     4  {
\end_layout

\begin_layout LyX-Code
     5      ...
\end_layout

\begin_layout LyX-Code
     6      points = SOUTH;
\end_layout

\begin_layout LyX-Code
     7      att.set_value(&points);
\end_layout

\begin_layout LyX-Code
     8  }
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
line 1 : One instance of the Card enum is created (named points)
\end_layout

\begin_layout Standard
line 6 : The enumeration is initialized
\end_layout

\begin_layout Standard
line 7 : The value of the attribute object is set using the enumeration
 (by pointer)
\begin_inset Newline newline
\end_inset

To get the same result using a classical DevShort variable, the code looks
 like
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
\align block
     1  DevShort sh;
\end_layout

\begin_layout LyX-Code
     2  
\end_layout

\begin_layout LyX-Code
     3  void MyDev::read_TheEnum(Attribute &att)
\end_layout

\begin_layout LyX-Code
     4  {
\end_layout

\begin_layout LyX-Code
     5      ...
\end_layout

\begin_layout LyX-Code
     6      sh = 1;
\end_layout

\begin_layout LyX-Code
     7      att.set_value(&sh);
\end_layout

\begin_layout LyX-Code
     8  }
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
line 1 : A DevShort variable is created (named sh)
\end_layout

\begin_layout Standard
line 6 : The variable is initialized
\end_layout

\begin_layout Standard
line 7 : The value of the attribute object is set using the DevShort variable
 (by pointer)
\end_layout

\begin_layout Subsection
Usage in a Tango client
\end_layout

\begin_layout Standard
Within a Tango client, you insert/extract enumerated attribute value in/from
 DeviceAttribute object with a C++ enum or a DevShort variable.
 The later case is for generic client which do not have compile time knowledge
 of the enumeration.
 The code looks like
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
\align block
     1  DeviceAttribute da = the_dev.read_attribute("TheEnumAtt");
\end_layout

\begin_layout LyX-Code
     2  Card ca;
\end_layout

\begin_layout LyX-Code
     3  da >> ca;
\end_layout

\begin_layout LyX-Code
     4  
\end_layout

\begin_layout LyX-Code
     5  DeviceAttribute db = the_dev.read_attribute("TheEnumAtt");
\end_layout

\begin_layout LyX-Code
     6  DevShort sh;
\end_layout

\begin_layout LyX-Code
     7  da >> sh;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
line 2-3 : The attribute value is extracted in a C++ enumeration variable
\end_layout

\begin_layout Standard
line 6-7 : The attribute value is extracted in a DevShort variable
\end_layout

\begin_layout Section
Device polling
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
Each tango device server automatically have a separate polling
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
polling
\end_layout

\end_inset

 thread pool.
 Polling a device means periodically executing command on a device (or reading
 device attribute) and storing the results (or the thrown exception) in
 a polling buffer.
 The aim of this polling is threefold :
\end_layout

\begin_layout Itemize
Speed-up response time for slow device
\end_layout

\begin_layout Itemize
Get a first-level history of device command output or attribute value
\end_layout

\begin_layout Itemize
Be the data source for the Tango event system
\end_layout

\begin_layout Standard
Speeding-up response time is achieved because the command_inout or read_attribut
e CORBA operation is able to get its data from the polling buffer or from
 the a real access to the device.
 For 
\begin_inset Quotes eld
\end_inset

slow
\begin_inset Quotes erd
\end_inset

 device, getting the data from the buffer is much faster than accessing
 the device.
 Returning a first-level command output history (or attribute value history)
 to a client is possible due to the polling buffer which is managed as a
 circular buffer.
 The history is the contents of this circular buffer.
 Obviously, the history depth is limited to the depth of the circular buffer.
 The polling is also the data source for the event system because detecting
 an event means being able to regularly read the data, memorize it and declaring
 that it is an event after some comparison with older values.
\end_layout

\begin_layout Standard
Starting with Tango 9, the default polling algorithm has been modifed.
 However, it is still possible to use the polling as it was in Tango releases
 prior to release 9.
 See chaper on polling configuration to get details on this.
\end_layout

\begin_layout Subsection
Configuring the polling system
\end_layout

\begin_layout Subsubsection
Configuring what has to be polled and how
\end_layout

\begin_layout Standard
It is possible to configure the polling in order to poll :
\end_layout

\begin_layout Itemize
Any command which does not need input parameter
\end_layout

\begin_layout Itemize
Any attribute
\end_layout

\begin_layout Standard
Configuring the polling is done by sending command to the device server
 administration device automatically implemented in every device server
 process.
 Seven commands are dedicated to this feature.
 These commands are
\end_layout

\begin_layout Description
AddObjPolling
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
AddObjPolling
\end_layout

\end_inset

 It add a new object (command or attribute) to the list of object(s) to
 be polled.
 It is also with this command that the polling period is specified.
\end_layout

\begin_layout Description
RemObjPolling
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
RemObjPolling
\end_layout

\end_inset

 To remove one object (command or attribute) from the polled object(s) list
\end_layout

\begin_layout Description
UpdObjPollingPeriod
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
UpdObjPollingPeriod
\end_layout

\end_inset

 Change one object polling period
\end_layout

\begin_layout Description
StartPolling
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
StartPolling
\end_layout

\end_inset

 Starts polling for the whole process
\end_layout

\begin_layout Description
StopPolling
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
StopPolling
\end_layout

\end_inset

 Stops polling for the whole process
\end_layout

\begin_layout Description
PolledDevice
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
PolledDevice
\end_layout

\end_inset

 Allow a client to know which device are polled
\end_layout

\begin_layout Description
DevPollStatus
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
DevPollStatus
\end_layout

\end_inset

 Allow a client to precisely knows the polling status for a device
\end_layout

\begin_layout Standard
All the necessary parameters for the polling configuration are stored in
 the Tango database.
 Therefore, the polling configuration is not lost after a device server
 process stop and restart (or after a device server process crash!!).
\end_layout

\begin_layout Standard
It is also possible to automatically poll a command (or an attribute) without
 sending command to the device server administration device.
 This request some coding (a method call) in the device server software
 during the command or attribute creation.
 In this case, for every devices supporting this command or this attribute,
 polling configuration will be automatically updated in the database and
 the polling will start automatically at each device server process startup.
 It is possible to stop this behavior on a device basis by sending a RemObjPolli
ng
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
RemObjPolling
\end_layout

\end_inset

 command to the device server administration device.
 The following piece of code shows how the source code should be written.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
\align block
     1  
\end_layout

\begin_layout LyX-Code
     2  void DevTestClass::command_factory()
\end_layout

\begin_layout LyX-Code
     3  {
\end_layout

\begin_layout LyX-Code
     4  ...
\end_layout

\begin_layout LyX-Code
     5      command_list.push_back(new IOStartPoll("IOStartPoll",
\end_layout

\begin_layout LyX-Code
     6                                              Tango::DEV_VOID,
\end_layout

\begin_layout LyX-Code
     7                                              Tango::DEV_LONG,
\end_layout

\begin_layout LyX-Code
     8                                              "Void",
\end_layout

\begin_layout LyX-Code
     9                                              "Constant number"));
\end_layout

\begin_layout LyX-Code
    10      command_list.back()->set_polling_period(400);
\end_layout

\begin_layout LyX-Code
    11  ...
\end_layout

\begin_layout LyX-Code
    12  }
\end_layout

\begin_layout LyX-Code
    13  
\end_layout

\begin_layout LyX-Code
    14  
\end_layout

\begin_layout LyX-Code
    15  void DevTestClass::attribute_factory(vector<Tango::Attr *> &att_list)
\end_layout

\begin_layout LyX-Code
    16  {
\end_layout

\begin_layout LyX-Code
    17  ...
\end_layout

\begin_layout LyX-Code
    18      att_list.push_back(new Tango::Attr("String_attr",
\end_layout

\begin_layout LyX-Code
    19                                          Tango::DEV_STRING,
\end_layout

\begin_layout LyX-Code
    20                                          Tango::READ));
\end_layout

\begin_layout LyX-Code
    21      att_list.back()->set_polling_period(250);
\end_layout

\begin_layout LyX-Code
    22  ...
\end_layout

\begin_layout LyX-Code
    23  }
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
A polling period of 400 mS is set for the command called 
\begin_inset Quotes eld
\end_inset

IOStartPoll
\begin_inset Quotes erd
\end_inset

 at line 10 with the 
\emph on
set_polling_period
\emph default
 method of the Command class.
 Therefore, for a device of this class, the polling thread will start polling
 its IOStartPoll command at process start-up except if a RemObjPolling indicatin
g this device and the IOStartPoll command has already been received by the
 device server administration device.
 This is exactly the same behavior for attribute.
 The polling period for attribute called 
\begin_inset Quotes eld
\end_inset

String_attr
\begin_inset Quotes erd
\end_inset

 is defined at line 20.
\end_layout

\begin_layout Standard
Configuring the polling means defining device attribute/command polling
 period.
 The polling period has to be chosen with care.
 If reading an attribute needs 200 mS, there is no point to poll this attribute
 with a polling period equal or even below 200 mS.
 You should also take into account that some "free" time has to be foreseen
 for external request(s) on the device.
 On average, for one attribute needing X mS as reading time, define a polling
 period which is equal to 1.4 X (280 mS for our example of one attribute
 needing 200 mS as reading time).
 In case the polling tuning is given to external user, Tango provides a
 way to define polling period minimun threshold.
 This is done using device properties.
 These properties are named 
\emph on
min_poll_period
\emph default
, 
\emph on
cmd_min_poll_period
\emph default
 and 
\emph on
attr_min_poll_period
\emph default
.
 The property min_poll_period
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
min-poll-period
\end_layout

\end_inset

 (mS) defined a minimun polling period for the device.
 The property cmd_min_poll_period
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
cmd-min-poll-period
\end_layout

\end_inset

 allows the definition of a minimun polling period for a specific device
 command.
 The property attr_min_poll_period
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
attr-min-poll-period
\end_layout

\end_inset

 allows the definition of a minimun polling period for one device attribute.
 In case these properties are defined, it is not possible to poll the device
 command/attribute with a polling period below those defined by these properties.
 See Appendix A on device parameter to get a precise syntax description
 for these properties.
\end_layout

\begin_layout Standard
The Jive
\begin_inset CommandInset citation
LatexCommand cite
key "Jive doc"

\end_inset

 tool also allows a graphical device polling configuration.
\end_layout

\begin_layout Subsubsection
Configuring the polling threads pool
\end_layout

\begin_layout Standard
Starting with Tango release 7, a Tango device server process may have several
 polling threads managed as a pool.
 For instance, this could be usefull in case of devices within the same
 device server process but accessed by different hardware channel when one
 of the channel is not responding (Thus generating long timeout and de-synchroni
sing the polling thread).
 By default, the polling threads pool size is set to 1 and all the polled
 object(s) are managed by the same thread (idem polling system in Tango
 releases older than release 7) .
 The configuration of the polling thread pool is done using two properties
 associated to the device server administration device.
 These properties are named:
\end_layout

\begin_layout Itemize

\emph on
polling_threads_pool_size
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
polling-threads-pool-size
\end_layout

\end_inset


\emph default
 defining the maximun number of threads that you can have in the pool
\end_layout

\begin_layout Itemize

\emph on
polling_threads_pool_conf
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
polling-threads-pool-conf
\end_layout

\end_inset


\emph default
 defining which threads in the pool manages which device
\end_layout

\begin_layout Standard
The granularity of the polling threads pool tuning is the device.
 You cannot ask the polling threads pool to have thread number 1 in charge
 of attribute 
\emph on
att1
\emph default
 of device 
\emph on
dev1
\emph default
 and thread number 2 to be in charge of 
\emph on
att2
\emph default
 of the same device 
\emph on
dev1
\emph default
.
\end_layout

\begin_layout Standard
When you require a new object (command or attribute) to be polled, two main
 cases may arrive:
\end_layout

\begin_layout Enumerate
Some polled object(s) belonging to the device are already polled by one
 of the polling threads in the pool: There is no new thread created.
 The object is simply added to the list of objects to be polled for the
 existing thread
\end_layout

\begin_layout Enumerate
There is no thread already created for the device.
 We have two sub-cases:
\end_layout

\begin_deeper
\begin_layout Enumerate
The number of polling threads is less than the polling_threads_pool_size:
 A new thread is created and started to poll the object (command or attribute)
\end_layout

\begin_layout Enumerate
The number of polling threads is already equal to the polling_threads_pool_size:
 The software search for the thread with the smallest number of polled objects
 and add the new polled object to this thread
\end_layout

\end_deeper
\begin_layout Standard
Each time the polling threads pool configuration is changed, it is written
 in the database using the polling_threads_pool_conf property.
 If the behaviour previously described does not fulfill your needs, it is
 possible to update the polling_threads_pool_conf property in a graphical
 way using the Tango Astor 
\begin_inset CommandInset citation
LatexCommand cite
key "Astor_doc"

\end_inset

 tool or manually using the Jive tool 
\begin_inset CommandInset citation
LatexCommand cite
key "Jive doc"

\end_inset

.
 These changes will be taken into account at the next device server process
 start-up.
 At start-up, the polling threads pool will allways be configured as required
 by the polling_threads_pool_conf property.
 The syntax used for this property is described in the Reference part of
 the Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Reference-part"

\end_inset

.
 The following window dump is the Astor tool window which allows polling
 threads pool management.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\begin_inset Graphics
	filename ThreadsManagement.png

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align block
In this example, the polling threads pool size to set to 9 but only 4 polling
 threads are running.
 Thread 1 is in charge of all polled objects related to device pv/thread-pool/te
st-1 and pv/thread-pool/test-2.
 Thread 2 is in charge of all polled objects related to device pv/thread-pool/te
st-3.
 Thread 3 is in charge of all polled objects related to device pv/thread-pool/te
st-5 anf finally, thread 4 is in charge of all polled objects for devices
 pv/thread-pool/test-4, pv/thread-pool/test-6 and pv/thread-pool/test-7.
\end_layout

\begin_layout Standard
It's also possible to define the polling threads pool size programmatically
 in the main function of a device server process using the 
\emph on
Util::set_polling_threads_pool_size()
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
set-polling-threads-pool-size
\end_layout

\end_inset


\emph default
 method before the call to the 
\emph on
Util::server_init()
\emph default
 method
\end_layout

\begin_layout Subsubsection
Choosing polling algorithm
\end_layout

\begin_layout Standard
Starting with Tango 9, you can choose between two different polling algorithm:
\end_layout

\begin_layout Itemize
The polling as it was in Tango since it has been introduced.
 This means:
\end_layout

\begin_deeper
\begin_layout Itemize
For one device, always poll attribute one at a time even if the polling
 period is the same (use of read_attribute instead of read_attributes)
\end_layout

\begin_layout Itemize
Do not allow the polling thread to be late: If it is the case (because at
 the end of polling object 1, the time is greater than the polling date
 of object 2), discard polling object and inform event user by sending one
 event with error (Polling thread is late and discard....)
\end_layout

\end_deeper
\begin_layout Itemize
New polling algorithm introduced in Tango 9 as the default one.
 This means:
\end_layout

\begin_deeper
\begin_layout Itemize
For one device, poll all attributes with the same polling period using a
 single device call (read_attributes)
\end_layout

\begin_layout Itemize
Allow the polling thread to be late but only if number of late objects decreases.
\end_layout

\end_deeper
\begin_layout Standard
The advantages of new polling algorithm are 
\end_layout

\begin_layout Enumerate
In case of several attributes polled on the same device at the same period
 a lower device occupation time by the polling thread (due to a single read_attr
ibutes() call instead of several single read_attribute() calls)
\end_layout

\begin_layout Enumerate
Less 
\begin_inset Quotes eld
\end_inset

Polling thread late
\begin_inset Quotes erd
\end_inset

 errors in the event system in case of device with non constant response
 time
\end_layout

\begin_layout Standard
The drawback is
\end_layout

\begin_layout Enumerate
The loss of attribute individual timing data reported in the polling thread
 status
\end_layout

\begin_layout Standard
It is still possible to return to pre-release 9 polling algorithm.
 To do so, you can use the device server process administration device 
\emph on
polling_before_9
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
polling_before_9
\end_layout

\end_inset

 property by setting it to true.
 It is also possible to choose this pre-release 9 algorithm in device server
 process code in the main function of the process using the 
\emph on
Util::set_polling_before_9()
\emph default
 method.
\end_layout

\begin_layout Subsection
Reading data from the polling buffer
\end_layout

\begin_layout Standard
For a polled command or a polled attribute, a client has three possibilities
 to get command result or attribute value (or the thrown exception) :
\end_layout

\begin_layout Itemize
From the device itself
\end_layout

\begin_layout Itemize
From the polling buffer
\end_layout

\begin_layout Itemize
From the polling buffer first and from the device if data in the polling
 buffer are invalid or if the polling is badly configured.
\end_layout

\begin_layout Standard
The choice is done during the command_inout CORBA operation by positioning
 one of the operation parameter.
 When reading data from the polling buffer, several error cases are possible
 
\end_layout

\begin_layout Itemize
The data in the buffer are not valid any more.
 Every time data are requested from the polling buffer, a check is done
 between the client request date and the date when the data were stored
 in the buffer.
 An exception is thrown if the delta is greater than the polling period
 multiplied by a 
\begin_inset Quotes eld
\end_inset

too old
\begin_inset Quotes erd
\end_inset

 factor.
 This factor has a default value and is up-datable via a device property.
 This is detailed in the reference part of this manual.
\end_layout

\begin_layout Itemize
The polling is correctly configured but there is no data yet in the polling
 buffer.
\end_layout

\begin_layout Subsection
Retrieving command/attribute result history
\end_layout

\begin_layout Standard
The polling thread stores the command result or attribute value in circular
 buffers.
 It is possible to retrieve an history of the command result (or attribute
 value) from these polling buffers.
 Obviously the history is limited by the depth of the circular buffer.
 For commands, a CORBA operation called 
\emph on
command_inout_history_2
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
command-inout-history-2
\end_layout

\end_inset


\emph default
 allows this retrieval.
 The client specifies the command name and the record number he want to
 retrieve.
 For each record, the call returns the date when the command was executed,
 the command result or the exception stack in case of the command failed
 when it was executed by the polling thread.
 In such a case, the exception stack is sent as a structure member and not
 as an exception.
 The same thing is available for attribute.
 The CORBA operation name is 
\emph on
read_attribute_history_2
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
read-attribute-history-2
\end_layout

\end_inset

.

\emph default
 For these two calls, there is no check done between the call date and the
 record date in contrary of the call to retrieve the last command result
 (or attribute value).
\end_layout

\begin_layout Subsection
Externally triggered polling
\end_layout

\begin_layout Standard
Sometimes, rather than polling a command or an attribute regulary with a
 fixed period, it is more interesting to "manually" decides when the polling
 must occurs.
 The Tango polling system also supports this kind of usage.
 This is called 
\emph on
externally triggered polling
\emph default
.
 To define one attribute (or command) as externally triggered, simply set
 its polling period to 0.
 This can be done with the device server administration device AddObjPolling
 or UpdObjPollingPeriod command.
 Once in this mode, the attribute (or command) polling is triggered with
 the 
\emph on
trigger_cmd_polling()
\emph default
 method (or 
\emph on
trigger_attr_polling()
\emph default
 method) of the Util class.
 The following piece of code shows how this method could be used for one
 externally triggered command.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
\align block
     1  .....
\end_layout

\begin_layout LyX-Code
     2  
\end_layout

\begin_layout LyX-Code
     3  string ext_polled_cmd("MyCmd");
\end_layout

\begin_layout LyX-Code
     4  Tango::DeviceImpl *device = .....;
\end_layout

\begin_layout LyX-Code
     5  
\end_layout

\begin_layout LyX-Code
     6  Tango::Util *tg = Tango::Util::instance();
\end_layout

\begin_layout LyX-Code
     7  
\end_layout

\begin_layout LyX-Code
     8  tg->trigger_cmd_polling(device,ext_polled_cmd);
\end_layout

\begin_layout LyX-Code
     9  
\end_layout

\begin_layout LyX-Code
    10  .....
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
line 3 : The externally polled command name
\end_layout

\begin_layout Standard
line 4 : The device object
\end_layout

\begin_layout Standard
line 8 : Trigger polling of command MyCmd
\end_layout

\begin_layout Subsection
Filling polling buffer
\end_layout

\begin_layout Standard
Some hardware to be interfaced already returned an array of pair value,
 timestamp.
 In order to be read with the 
\emph on
command_inout_history
\emph default
 or 
\emph on
read_attribute_history
\emph default
 calls, this array has to be transferred in the attribute or command polling
 buffer.
 This is possible only for attribute or command configured in the externally
 triggered polling mode.
 Once in externally triggered polling mode, the attribute (or command) polling
 buffer is filled with the 
\emph on
fill_cmd_polling_buffer()
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
fill-cmd-polling-buffer
\end_layout

\end_inset


\emph default
 method (or 
\emph on
fill_attr_polling_buffer()
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
fill-attr-polling-buffer
\end_layout

\end_inset


\emph default
 method) of the Util class.
 For command, the user uses a template class called 
\emph on
TimedCmdData
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
TimedCmdData
\end_layout

\end_inset


\emph default
 for each element of the command history.
 Each element is stored in a stack in one instance of a template class called
 
\emph on
CmdHistoryStack
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
CmdHistoryStack
\end_layout

\end_inset

.

\emph default
 This object is one of the argument of the fill_cmd_polling_buffer() method.
 Obviously, the stack depth cannot be larger than the polling buffer depth.
 See 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:The-device-polling-prop"

\end_inset

 to learn how the polling buffer depth is defined.
 The same way is used for attribute with the 
\emph on
TimedAttrData
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
TimedAttrData
\end_layout

\end_inset


\emph default
 and 
\emph on
AttrHistoryStack
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
AttrHistoryStack
\end_layout

\end_inset


\emph default
 template classes.
 These classes are documented in 
\begin_inset CommandInset citation
LatexCommand cite
key "TANGO_ref_man"

\end_inset

.
 The following piece of code fills the polling buffer for a command called
 MyCmd which is already in externally triggered mode.
 It returns a DevVarLongArray data type with three elements.
 This example is not really something you will find in a real hardware interface.
 It is only to demonstrate the fill_cmd_polling_buffer() method usage.
 Error management has also been removed.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
\align block
     1  ....
\end_layout

\begin_layout LyX-Code
     2  
\end_layout

\begin_layout LyX-Code
     3  Tango::DevVarLongArray dvla_array[4];
\end_layout

\begin_layout LyX-Code
     4          
\end_layout

\begin_layout LyX-Code
     5  for(int i = 0;i < 4;i++)
\end_layout

\begin_layout LyX-Code
     6  {
\end_layout

\begin_layout LyX-Code
     7      dvla_array[i].length(3);
\end_layout

\begin_layout LyX-Code
     8      dvla_array[i][0] = 10 + i;
\end_layout

\begin_layout LyX-Code
     9      dvla_array[i][1] = 11 + i;
\end_layout

\begin_layout LyX-Code
    10      dvla_array[i][2] = 12 + i;
\end_layout

\begin_layout LyX-Code
    11  }
\end_layout

\begin_layout LyX-Code
    12  
\end_layout

\begin_layout LyX-Code
    13  Tango::CmdHistoryStack<DevVarLongArray> chs;
\end_layout

\begin_layout LyX-Code
    14  chs.length(4);
\end_layout

\begin_layout LyX-Code
    15  
\end_layout

\begin_layout LyX-Code
    16  for (int k = 0;k < 4;k++)
\end_layout

\begin_layout LyX-Code
    17  {
\end_layout

\begin_layout LyX-Code
    18      time_t when = time(NULL);
\end_layout

\begin_layout LyX-Code
    19  
\end_layout

\begin_layout LyX-Code
    20      Tango::TimedCmdData<DevVarLongArray> tcd(&dvla_array[k],when);
\end_layout

\begin_layout LyX-Code
    21      chs.push(tcd);
\end_layout

\begin_layout LyX-Code
    22  }
\end_layout

\begin_layout LyX-Code
    23  
\end_layout

\begin_layout LyX-Code
    24  Tango::Util *tg = Tango::Util::instance();
\end_layout

\begin_layout LyX-Code
    25  string cmd_name("MyCmd");
\end_layout

\begin_layout LyX-Code
    26  DeviceImpl *dev = ....;
\end_layout

\begin_layout LyX-Code
    27  
\end_layout

\begin_layout LyX-Code
    28  tg->fill_cmd_polling_buffer(dev,cmd_name,chs);
\end_layout

\begin_layout LyX-Code
    29  
\end_layout

\begin_layout LyX-Code
    30  .....
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Line 3-11 : Simulate data coming from hardware
\end_layout

\begin_layout Standard
Line 13-14 : Create one instance of the CmdHistoryStack class and reserve
 space for one history of 4 elements
\end_layout

\begin_layout Standard
Line 16-17 : A loop on each history element
\end_layout

\begin_layout Standard
Line 18 : Get date (hardware simulation)
\end_layout

\begin_layout Standard
Line 20 : Create one instance of the TimedCmdData class with data and date
\end_layout

\begin_layout Standard
Line 21 : Store this command history element in the history stack.
 The element order will be the insertion order whatever the element date
 is.
\end_layout

\begin_layout Standard
Line 28 : Fill command polling buffer
\end_layout

\begin_layout Standard
After one execution of this code, a command_inout_history() call will return
 one history with 4 elements.
 The first array element of the oldest history record will have the value
 10.
 The first array element of the newest history record will have the value
 13.
 A command_inout() call with the data source parameter set to CACHE will
 return the newest history record (ie an array with values 13,14 and 15).
 A command_inout() call with the data source parameter set to DEVICE will
 return what is coded is the command method.
 If you execute this code a second time, a command_inout_history() call
 will return an history of 8 elements.
\end_layout

\begin_layout Standard
The next example fills the polling buffer for an attribute called MyAttr
 which is already in externally triggered mode.
 It is a scalar attribute of the DevString data type.
 This example is not really something you will find in a real hardware interface.
 It is only to demonstrate the fill_attr_polling_buffer() method usage with
 memory management issue.
 Error management has also been removed.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
\align block
     1  ....
\end_layout

\begin_layout LyX-Code
\align block
     2  
\end_layout

\begin_layout LyX-Code
\align block
     3  AttrHistoryStack<DevString> ahs;
\end_layout

\begin_layout LyX-Code
\align block
     4  ahs.length(3);
\end_layout

\begin_layout LyX-Code
\align block
     5  
\end_layout

\begin_layout LyX-Code
\align block
     6  for (int k = 0;k < 3;k++)
\end_layout

\begin_layout LyX-Code
\align block
     7  {
\end_layout

\begin_layout LyX-Code
\align block
     8      time_t when = time(NULL);
\end_layout

\begin_layout LyX-Code
\align block
     9  
\end_layout

\begin_layout LyX-Code
\align block
    10      DevString *ptr = new DevString [1];
\end_layout

\begin_layout LyX-Code
\align block
    11      ptr = CORBA::string_dup("Attr history data");
\end_layout

\begin_layout LyX-Code
\align block
    12  
\end_layout

\begin_layout LyX-Code
\align block
    13      TimedAttrData<DevString> tad(ptr,Tango::ATTR_VALID,true,when);
\end_layout

\begin_layout LyX-Code
\align block
    14      ahs.push(tad);
\end_layout

\begin_layout LyX-Code
\align block
    15  }
\end_layout

\begin_layout LyX-Code
\align block
    16  
\end_layout

\begin_layout LyX-Code
\align block
    17  Tango::Util *tg = Tango::Util::instance();
\end_layout

\begin_layout LyX-Code
\align block
    18  string attr_name("MyAttr");
\end_layout

\begin_layout LyX-Code
\align block
    19  DeviceImpl *dev = ....;
\end_layout

\begin_layout LyX-Code
\align block
    20  
\end_layout

\begin_layout LyX-Code
\align block
    21  tg->fill_attr_polling_buffer(dev,attr_name,ahs);
\end_layout

\begin_layout LyX-Code
\align block
    22  
\end_layout

\begin_layout LyX-Code
\align block
    23  .....
\end_layout

\begin_layout LyX-Code
\align block
  
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Line 3-4 : Create one instance of the AttrHistoryStack class and reserve
 space for an history with 3 elements
\end_layout

\begin_layout Standard
Line 6-7 : A loop on each history element
\end_layout

\begin_layout Standard
Line 8 : Get date (hardware simulation)
\end_layout

\begin_layout Standard
Line 10-11 : Create a string.
 Note that the DevString object is created on the heap
\end_layout

\begin_layout Standard
Line 13 : Create one instance of the TimedAttrData class with data and date
 requesting the memory to be released.
\end_layout

\begin_layout Standard
Line 14 : Store this attribute history element in the history stack.
 The element order will be the insertion order whatever the element date
 is.
\end_layout

\begin_layout Standard
Line 21 : Fill command polling buffer
\end_layout

\begin_layout Standard
It is not necessary to return the memory allocated at line 10.
 The 
\emph on
fill_attr_polling_buffer()
\emph default
 method will do it for you.
\end_layout

\begin_layout Subsection
Setting and tuning the polling in a Tango class
\end_layout

\begin_layout Standard
Even if the polling is normally set and tuned with external tool like Jive,
 it is possible to set it directly into the code of a Tango class.
 A set of methods belonging to the 
\emph on
DeviceImpl
\emph default
 class allows the user to deal with polling.
 These methods are:
\end_layout

\begin_layout Itemize

\emph on
is_attribute_polled()
\emph default
 and 
\emph on
is_command_polled()
\emph default
 to check if one command/attribute is polled
\end_layout

\begin_layout Itemize

\emph on
get_attribute_poll_period()
\emph default
 and 
\emph on
get_command_poll_period()
\emph default
 to get polled object polling period
\end_layout

\begin_layout Itemize

\emph on
poll_attribute()
\emph default
 and 
\emph on
poll_command()
\emph default
 to poll command or attribute
\end_layout

\begin_layout Itemize

\emph on
stop_poll_attribute()
\emph default
 and 
\emph on
stop_poll_command()
\emph default
 to stop polling a command or an attribute
\end_layout

\begin_layout Standard
The following code snippet is just an exmaple of how these methods could
 be used.
 They are documented in 
\begin_inset CommandInset citation
LatexCommand cite
key "Tango-dsclasses-doc"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
\align block
     
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "poll_in_ds.cpp.lines"
lstparams "language={C++}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Section
Threading
\begin_inset CommandInset label
LatexCommand label
name "sec:Threading"

\end_inset


\end_layout

\begin_layout Standard
When used with C++, Tango used omniORB as underlying ORB.
 This CORBA implementation is a threaded implementation and therefore a
 C++ Tango device server or client are multi-threaded processes.
\end_layout

\begin_layout Subsection
Device server process
\end_layout

\begin_layout Standard
A classical Tango device server without any connected clients has eight
 threads.
 These threads
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
thread
\end_layout

\end_inset

 are :
\end_layout

\begin_layout Itemize
The main thread waiting in the ORB main loop
\end_layout

\begin_layout Itemize
Two ORB implementation threads (the POA thread)
\end_layout

\begin_layout Itemize
The ORB scavanger thread
\end_layout

\begin_layout Itemize
The signal thread
\end_layout

\begin_layout Itemize
The heartbeat thread (needed by the Tango event system)
\end_layout

\begin_layout Itemize
Two Zmq implementation threads
\end_layout

\begin_layout Standard
On top of these eight threads, you have to add the thread(s) used by the
 polling threads pool.
 This number depends on the polling thread pool configuration and could
 be between 0 (no polling at all) and the maximun number of threads in the
 pool.
\end_layout

\begin_layout Standard
A new thread is started for each connected client.
 Device server are mostly used to interface hardware which most of the time
 does not support multi-threaded access.
 Therefore, all remote calls executed from a client are serialized within
 the device server code by using mutual exclusion.
 See chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Serialization-model-within"

\end_inset

 on which serialization model are available.
 In order to limit thread number, the underlying ORB (omniORB) is configured
 to shutdown threads dedicated to client if the connection is inactive for
 more than 3 minutes.
 To also limit thread number, the ORB is configured to create one thread
 per connection up to 55 threads.
 When this level is reached, the threading model is automatically switch
 to a "thread pool" model with up to 100 threads.
 If the number of threads decrease down to 50, the threading model will
 return to "thread per connection" model.
\end_layout

\begin_layout Standard
If you are using event, the event system for its internal heartbeat system
 periodically (every 200 seconds) sends a command to the device server administr
ation device.
 As explained above, a thread is created to execute these command.
 The omniORB scavanger will terminate this thread before the next event
 system heartbeat command arrives.
 For example, if you have a device server with three connected clients using
 only event, the process thread number will permanently change between 8
 and 11 threads.
\end_layout

\begin_layout Standard
In summary, the number of threads in a device server process can be evaluated
 with the following formula:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\series bold
8 + k + m
\series default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset

k is the number of polling threads used from the polling threads pool and
 m is the number of threads used for connected clients.
\end_layout

\begin_layout Subsubsection
Serialization model within a device server
\begin_inset CommandInset label
LatexCommand label
name "sub:Serialization-model-within"

\end_inset


\end_layout

\begin_layout Standard
Four serialization
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
serialization
\end_layout

\end_inset

 models are available within a device server.
 These models protect all requests coming from the network but also requests
 coming from the polling thread.
 These models are:
\end_layout

\begin_layout Enumerate
Serialization by device.
 All access to the same device are serialized.
 As an example, let's take a device server implementing one class of device
 with two instances (dev1 and dev2).
 Two clients are connected to these devices (client1 and client2).
 Client2 will not be able to access dev1 if client1 is using it.
 Nevertheless, client2 is able to access dev2 while client1 access dev1
 (There is one mutual exclusion object by device)
\end_layout

\begin_layout Enumerate
Serialization by class.
 With non multi-threaded legacy software, the preceding scenario could generate
 problem.
 In this mode of serialization, client2 is not able to access dev2 while
 client1 access dev1 because dev2 and dev1 are instances of the same class
 (There is one mutual exclusion object by class)
\end_layout

\begin_layout Enumerate
Serialization by process.
 This is one step further than the previous case.
 In this mode, only one client can access any device embedded within the
 device server at a time.
 There is only one mutual exclusion object for the whole process)
\end_layout

\begin_layout Enumerate
No serialization.
 This is an exotic kind of serialization and 
\series bold
should be used with extreme care
\series default
 only with device which are fully thread safe.
 In this model, most of the device access are not serialized at all.
 Due to Tango internal structure, the 
\emph on
get_attribute_config
\emph default
, 
\emph on
set_attribute_config
\emph default
, 
\emph on
read_attributes
\emph default
 and 
\emph on
write_attributes
\emph default
 CORBA calls are still protected.
 Reading the device state and status via commands or via CORBA attribute
 is also protected.
\end_layout

\begin_layout Standard
By default, every Tango device server is in serialization by device mode.
 A method of the Tango::Util class allows to change this default behavior.
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
     1  #include <tango.h>
\end_layout

\begin_layout LyX-Code
     2  
\end_layout

\begin_layout LyX-Code
     3  int main(int argc,char *argv[])
\end_layout

\begin_layout LyX-Code
     4  {
\end_layout

\begin_layout LyX-Code
     5  
\end_layout

\begin_layout LyX-Code
     6      try
\end_layout

\begin_layout LyX-Code
     7      {
\end_layout

\begin_layout LyX-Code
     8          
\end_layout

\begin_layout LyX-Code
     9          Tango::Util *tg = Tango::Util::init(argc,argv);
\end_layout

\begin_layout LyX-Code
    10  
\end_layout

\begin_layout LyX-Code
    11          tg->set_serial_model(Tango::BY_CLASS);
\end_layout

\begin_layout LyX-Code
    12  
\end_layout

\begin_layout LyX-Code
    13          tg->server_init();
\end_layout

\begin_layout LyX-Code
    14  
\end_layout

\begin_layout LyX-Code
    15          cout << "Ready to accept request" << endl;
\end_layout

\begin_layout LyX-Code
    16          tg->server_run();
\end_layout

\begin_layout LyX-Code
    17      }
\end_layout

\begin_layout LyX-Code
    18      catch (bad_alloc)
\end_layout

\begin_layout LyX-Code
    19      {
\end_layout

\begin_layout LyX-Code
    20           cout << "Can't allocate memory!!!" << endl;
\end_layout

\begin_layout LyX-Code
    21           cout << "Exiting" << endl;
\end_layout

\begin_layout LyX-Code
    22      }
\end_layout

\begin_layout LyX-Code
    23      catch (CORBA::Exception &e)
\end_layout

\begin_layout LyX-Code
    24      {
\end_layout

\begin_layout LyX-Code
    25           Tango::Except::print_exception(e);
\end_layout

\begin_layout LyX-Code
    26                  
\end_layout

\begin_layout LyX-Code
    27           cout << "Received a CORBA::Exception" << endl;
\end_layout

\begin_layout LyX-Code
    28           cout << "Exiting" << endl;
\end_layout

\begin_layout LyX-Code
    29      }
\end_layout

\begin_layout LyX-Code
    30          
\end_layout

\begin_layout LyX-Code
    31      return(0);
\end_layout

\begin_layout LyX-Code
    32  }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
The serialization model is set at line 11 before the server is initialized
 and the infinite loop is started.
 See 
\begin_inset CommandInset citation
LatexCommand cite
key "TANGO_ref_man"

\end_inset

 for all details on the methods to set/get serialization model.
\end_layout

\begin_layout Subsubsection
Attribute Serialization model
\end_layout

\begin_layout Standard
Even with the serialization model described previously, in case of attributes
 carrying a large number of data and several clients reading this attribute,
 a device attribute serialization has to be followed.
 Without this level of serialization, for attribute using a shared buffer,
 a thread scheduling may happens while the device server process is in the
 CORBA layer transferring the attribute data on the network.
 Three serialization
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
serialization
\end_layout

\end_inset

 models are available for attribute serialization.
 The default is well adapted to nearly all cases.
 Nevertheless, if the user code manages several attributes data buffer or
 if it manages its own buffer protection by one way or another, it could
 be interesting to tune this serialization level.
 The available models are:
\end_layout

\begin_layout Enumerate
Serialization by kernel.
 This is the default case.
 The kernel is managing the serialization
\end_layout

\begin_layout Enumerate
Serialization by user.
 The user code is in charge of the serialization.
 This serialization is done by the use of a omni_mutex object.
 An omni_mutex is an object provided by the omniORB package.
 It is the user responsability to lock this mutex when appropriate and to
 give this mutex to the Tango kernel before leaving the attribute read method
\end_layout

\begin_layout Enumerate
No serialization.
\end_layout

\begin_layout Standard
By default, every Tango device attribute is in serialization by kernel.
 Methods of the Tango::Attribute class allow to change the attribute serializati
on behavior and to give the user omni_mutex object to the kernel.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
1 void MyClass::init_device()
\end_layout

\begin_layout LyX-Code
2 {
\end_layout

\begin_layout LyX-Code
3    ...
\end_layout

\begin_layout LyX-Code
4    ...
\end_layout

\begin_layout LyX-Code
5    Tango::Attribute &att = dev_attr->get_attr_by_name("TheAttribute");
\end_layout

\begin_layout LyX-Code
6    att.set_attr_serial_model(Tango::ATTR_BY_USER);
\end_layout

\begin_layout LyX-Code
7    ....
\end_layout

\begin_layout LyX-Code
8    ....
\end_layout

\begin_layout LyX-Code
9 
\end_layout

\begin_layout LyX-Code
10 }
\end_layout

\begin_layout LyX-Code
11 
\end_layout

\begin_layout LyX-Code
12 
\end_layout

\begin_layout LyX-Code
13 void MyClass::read_TheAttribute(Tango::Attribute &attr)
\end_layout

\begin_layout LyX-Code
14 {
\end_layout

\begin_layout LyX-Code
15    ....
\end_layout

\begin_layout LyX-Code
16    ....
\end_layout

\begin_layout LyX-Code
17    the_mutex.lock();
\end_layout

\begin_layout LyX-Code
18    ....
\end_layout

\begin_layout LyX-Code
19    // Fill the attribute buffer
\end_layout

\begin_layout LyX-Code
20    ....
\end_layout

\begin_layout LyX-Code
21    attr.set_value(buffer,....);
\end_layout

\begin_layout LyX-Code
22    attr->set_user_attr_mutex(&the_mutex);
\end_layout

\begin_layout LyX-Code
23 }
\end_layout

\begin_layout LyX-Code
24 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
The serialization model is set at line 6 in the init_device() method.
 The user omni_mutex is passed to the Tango kernel at line 22.
 This omni_mutex object is a device data member.
 See 
\begin_inset CommandInset citation
LatexCommand cite
key "TANGO_ref_man"

\end_inset

 for all details on the methods to set attribute serialization model.
\end_layout

\begin_layout Subsection
Client process
\end_layout

\begin_layout Standard
Clients are also multi threaded processes.
 The underlying C++ ORB (omniORB) try to keep system resources to a minimum.
 To decrease process file descriptors usage, each connection to server is
 automatically closed if it is idle for more than 2 minutes and automatically
 re-opened when needed.
 A dedicated thread is spawned by the ORB to manage this automatic closing
 connection (the ORB scavenger thread).
\end_layout

\begin_layout Standard
Threrefore, a Tango client has two threads which are:
\end_layout

\begin_layout Enumerate
The main thread
\end_layout

\begin_layout Enumerate
The ORB scavanger thread
\end_layout

\begin_layout Standard
If the client is using the event system and as Tango is using the event
 push-push model, it has to be a server for receiving the events.
 This increases the number of threads
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
thread
\end_layout

\end_inset

.
 The client now has 6 threads which are:
\end_layout

\begin_layout Itemize
The main thread
\end_layout

\begin_layout Itemize
The ORB scavenger thread
\end_layout

\begin_layout Itemize
Two Zmq implementation threads
\end_layout

\begin_layout Itemize
Two Tango event system related threads (the KeepAliveThread and the EventConsume
r thread)
\end_layout

\begin_layout Section
Generating events in a device server
\end_layout

\begin_layout Standard
The server is at the origin of events
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
event
\end_layout

\end_inset

.
 It will fire events as soon as they occur.
 Standard events (
\emph on
change
\emph default
, 
\emph on
periodic
\emph default
 and 
\emph on
archive
\emph default
) are detected automatically in the polling thread and fired as soon as
 they are detected.
 The 
\emph on
periodic
\emph default
 events can only be handled by the polling thread.
 
\emph on
Change, Data ready
\emph default
 and 
\emph on
archive
\emph default
 events can also be pushed from the device server code.
 To allow a client to subscribe to events of non polled attributes the server
 has to declare that events are pushed from the code.
 Three methods are available for this purpose:
\end_layout

\begin_layout LyX-Code
Attr::set_change_event(bool implemented, bool detect = true);
\end_layout

\begin_layout LyX-Code
Attr::set_archive_event(bool implemented, bool detect = true);
\end_layout

\begin_layout LyX-Code
Attr::set_data_ready_event( bool implemented);
\end_layout

\begin_layout Standard
where 
\emph on
implemented
\emph default
=true indicates that events are pushed manually from the code and 
\emph on
detect
\emph default
=true (when used) triggers the verification of the same event properties
 as for events send by the polling thread.
 When setting 
\emph on
detect
\emph default
=false, no value checking is done on the pushed value! The class DeviceImpl
 also supports the first two methods with an addictional parameter attr_name
 defining the attribute name.
\end_layout

\begin_layout Standard
To push events manually from the code a set of data type dependent methods
 can be used:
\end_layout

\begin_layout LyX-Code
DeviceImpl::push_change_event (string attr_name, ....);
\end_layout

\begin_layout LyX-Code
DeviceImpl::push_archive_event(string attr_name, ....);
\end_layout

\begin_layout Standard
For the data ready event, a DeviceImpl class method has to be used to push
 the event.
\end_layout

\begin_layout LyX-Code
DeviceImpl::push_data_ready_event(string attr_name,Tango::DevLong ctr);
\end_layout

\begin_layout Standard
See the class documentation for all available interfaces.
\end_layout

\begin_layout Standard
For non-standard events a single call exists for pushing the data to the
 CORBA Notification Service (omniNotify).
 Clients who are subscribed to this event have to know what data type is
 in the DeviceAttribute and unpack it accordingly.
\end_layout

\begin_layout Standard
To push non-standard events, use the following api call is available to
 all device servers :
\end_layout

\begin_layout LyX-Code
DeviceImpl::push_event( string attr_name,
\end_layout

\begin_layout LyX-Code
             vector<string> &filterable_names,
\end_layout

\begin_layout LyX-Code
             vector<double> &filterable_vals,
\end_layout

\begin_layout LyX-Code
             Attribute &att)
\end_layout

\begin_layout Standard
where 
\emph on
attr_name
\emph default
 is the name of the attribute
\emph on
.
 Filterable_names
\emph default
 and 
\emph on
filterable_vals
\emph default
 represent any filterable data which can be used by clients to filter on.
 Here is a typical example of what a server will need to do to send its
 own events.
 We are in the read method of the "Sinusoide" attribute.
 This attribute is readable as any other attribute but an event is sent
 if its value is positive when it is read.
 On top of that, this event is sent with one filterable field called "value"
 which is set to the attribute value.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
1  void MyClass::read_Sinusoide(Tango::Attribute &attr)
\end_layout

\begin_layout LyX-Code
2  {
\end_layout

\begin_layout LyX-Code
3    ...
\end_layout

\begin_layout LyX-Code
4       struct timeval tv;
\end_layout

\begin_layout LyX-Code
5       gettimeofday(&tv, NULL);
\end_layout

\begin_layout LyX-Code
6       sinusoide = 100 * sin( 2 * 3.14 * frequency * tv.tv_sec);
\end_layout

\begin_layout LyX-Code
7  
\end_layout

\begin_layout LyX-Code
8       if (sinusoide >= 0) 
\end_layout

\begin_layout LyX-Code
9       {
\end_layout

\begin_layout LyX-Code
10          vector<string> filterable_names;
\end_layout

\begin_layout LyX-Code
11          vector<double> filterable_value;
\end_layout

\begin_layout LyX-Code
12 
\end_layout

\begin_layout LyX-Code
13          filterable_names.push_back("value");
\end_layout

\begin_layout LyX-Code
14          filterable_value.push_back((double)sinusoide);
\end_layout

\begin_layout LyX-Code
15 
\end_layout

\begin_layout LyX-Code
16          push_event( attr.get_name(),
\end_layout

\begin_layout LyX-Code
17                      filterable_names, filterable_value,
\end_layout

\begin_layout LyX-Code
18                      &sinusoide);
\end_layout

\begin_layout LyX-Code
19       }
\end_layout

\begin_layout LyX-Code
20    ....
\end_layout

\begin_layout LyX-Code
21    ....
\end_layout

\begin_layout LyX-Code
22 
\end_layout

\begin_layout LyX-Code
23 }
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
line 13-14 : The filter pair name/value is initialised
\end_layout

\begin_layout Standard
line 16-18 : The event is pushed
\end_layout

\begin_layout Section
Using multicast protocol to transfer events
\end_layout

\begin_layout Standard
This feature is available starting with Tango 8.1.
 Transferring events using a multicast
\begin_inset Index idx
status open

\begin_layout Plain Layout
multicasting
\end_layout

\end_inset

 protocol means delivering the events to a group of clients simultaneously
 in a single transmission from the event source.
 Tango, through ZMQ, uses the OpenPGM multicating protocol.
 This is one implementation of the PGM protocol defined by the RFC 3208
 (Reliable multicasting protocol).
 Nevertheless, the default event communication mode is unicast and propagating
 events via multicasting requires some specific configuration.
\end_layout

\begin_layout Subsection
Configuring events to use multicast transport
\end_layout

\begin_layout Standard
Before using multicasting transport for event(s), you have to choose which
 address and port have to be used.
 In a IP V4 network, only a limited set of addresses are associated with
 multicasting.
 These are the IP V4 addresses between 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset

224.0.1.0 and 238.255.255.255
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset

 Once the address is selected, you have to choose a port number.
 Together with the event name, these are the two minimum configuration informati
ons which have to be provided to Tango to get multicast transport.
 This configuration is done using the 
\series bold
MulticastEvent
\begin_inset Index idx
status open

\begin_layout Plain Layout

\series medium
MulticastEvent
\end_layout

\end_inset


\series default
 free property associated to the 
\series bold
CtrlSystem
\begin_inset Index idx
status open

\begin_layout Plain Layout

\series medium
CtrlSystem
\end_layout

\end_inset


\series default
 object.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename jive_simpl.jpg
	scale 70

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the above window dump of the Jive tool, the 
\emph on
change
\emph default
 event on the 
\emph on
state
\emph default
 attribute of the 
\emph on
dev/test/11
\emph default
 device has to be transferred using multicasting with the address 
\emph on
226.20.21.22
\emph default
 and the port number 
\emph on
2222
\emph default
.
 The exact definition of this CtrlSystem/MulticastEvent property for one
 event propagated using multicast is
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
\align block
1 CtrlSystem->MulticastEvent:   Multicast address,
\end_layout

\begin_layout LyX-Code
2                               port number,
\end_layout

\begin_layout LyX-Code
3                               [rate in Mbit/sec],
\end_layout

\begin_layout LyX-Code
4                               [ivl in seconds],
\end_layout

\begin_layout LyX-Code
5                               event name
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Rate
\begin_inset Index idx
status open

\begin_layout Plain Layout
rate
\end_layout

\end_inset

 and Ivl
\begin_inset Index idx
status open

\begin_layout Plain Layout
ivl
\end_layout

\end_inset

 are optional properties.
 In case several events have to be transferred using multicasting, simply
 extend the MulicastEvent property with the configuration parameters related
 to the other events.
 There is only one MultiCastEvent property per Tango control system.
 The underlying multicast protocol (PGM) is rate limited.
 This means that it limits its network bandwidth usage to a user defined
 value.
 The optional third configuration parameter is the maximum rate (in Mbit/sec)
 that the protocol will use to transfert this event.
 Because PGM is a reliable protocol, data has to be buffered for re-transmission
 in case a receiver signal some lost data.
 The optional forth configuration parameter specify the maximum amount of
 time (in seconds) that a receiver can be absent for a multicast group before
 unrecoverable data loss will occur.
 Exercise care when setting large recovery interval as the data needed for
 recovery will be held in memory.
 For example, a 60 seconds (1 minute) recovery interval at a data rate of
 1 Gbit/sec requires a 7 GBytes in-memory buffer.
 Whan any of these two optional parameters are not set, the default value
 (defined in next sub-chapter) are used.
 Here is another example of events using multicasting configuration
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\begin_inset Graphics
	filename jive_sophis.jpg
	scale 70

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset

 In this example, there are 5 events which are transmitted using multicasting:
\end_layout

\begin_layout Enumerate
Event 
\emph on
change
\emph default
 for attribute 
\emph on
state
\emph default
 on device 
\emph on
dev/test/11
\emph default
 which uses multicasting address 
\emph on
226.20.21.22
\emph default
 and port number 
\emph on
2222
\end_layout

\begin_layout Enumerate
Event 
\emph on
periodic
\emph default
 for attribute 
\emph on
state
\emph default
 on device 
\emph on
dev/test/10
\emph default
 which uses multicasting address 
\emph on
226.20.21.22
\emph default
 and port number 
\emph on
3333
\end_layout

\begin_layout Enumerate
Event 
\emph on
change
\emph default
 for attribute 
\emph on
ImaAttr
\emph default
 on device 
\emph on
et/ev/01
\emph default
 which uses multicasting address 
\emph on
226.30.31.32
\emph default
 and port number 
\emph on
4444
\emph default
.
 Note that this event uses a rate set to 
\emph on
40 Mbit/sec
\emph default
 and a ivl set to 
\emph on
20 seconds
\emph default
.
\end_layout

\begin_layout Enumerate
Event 
\emph on
change
\emph default
 for attribute 
\emph on
event_change_tst
\emph default
 on device 
\emph on
dev/test/12
\emph default
 which uses multicasting address 
\emph on
226.20.21.22
\emph default
 and port number 
\emph on
2233
\end_layout

\begin_layout Enumerate
Event 
\emph on
archive
\emph default
 for attribute 
\emph on
event_change_tst
\emph default
 on device 
\emph on
dev/tomasz/3
\emph default
 which uses multicasting address 
\emph on
226.20.21.22
\emph default
 and port number 
\emph on
2234
\end_layout

\begin_layout Subsection
Default multicast related properties
\end_layout

\begin_layout Standard
On top of the MulticastEvent property previously described, Tango supports
 three properties to defined default value for multicast transport tuning.
 These properties are:
\end_layout

\begin_layout Itemize

\series bold
MulticastRate
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
MulticastRate
\end_layout

\end_inset

 associated to the CtrlSystem
\begin_inset Index idx
status open

\begin_layout Plain Layout
CtrlSystem
\end_layout

\end_inset

 object.
 This defines the maximum rate will will be used by the multicast protocol
 when transferring event.
 The unit is Mbit/sec.
 In case this property is not defined, the Tango library used a value of
 80 Mbit/sec.
\end_layout

\begin_layout Itemize

\series bold
MulticastIvl
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
MulticastIvl
\end_layout

\end_inset

 associated to the CtrlSystem object.
 It specifies the maximum time (in sec) during which data has to be buffered
 for re-transmission in case a receiver signals some lost data.
 The unit is seconds.
 In case this property is not defined, the Tango library takes a value of
 20 seconds.
\end_layout

\begin_layout Itemize

\series bold
MulticastHops
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
MulticastHops
\end_layout

\end_inset

 associated to the CtrlSystem object.
 This property defines the maximum number of element (router), the multicast
 packet is able to cross.
 Each time one element is crossed, the value is decremented.
 When it reaches 0, the packet is not transferred any more.
 In case this property is not defined, the Tango library uses a value of
 5.
\end_layout

\begin_layout Section
Memorized attribute
\end_layout

\begin_layout Standard
It is possible to ask Tango to store in its database the last written value
 for attribute of the SCALAR data format and obviously only for READ_WRITE
 or READ_WITH_WRITE attribute.
 This is fully automatic.
 During device startup phase, for all device memorized
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
memorized
\end_layout

\end_inset

 attributes, the value written in the database is fetched and applied.
 A write_attribute call can be generated to apply the memorized value to
 the attribute or only the attribute set point can be initialised.
 The following piece of code shows how the source code should be written
 to set an attribute as memorized and to initialise only the attribute set
 point.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
\align block
1 void DevTestClass::attribute_factory(vector<Tango::Attr *> &att_list)
\end_layout

\begin_layout LyX-Code
2  {
\end_layout

\begin_layout LyX-Code
3      ...
\end_layout

\begin_layout LyX-Code
4      att_list.push_back(new String_attrAttr());
\end_layout

\begin_layout LyX-Code
5      att_list.back()->set_memorized();
\end_layout

\begin_layout LyX-Code
6      att_list.back()->set_memorized_init(false);
\end_layout

\begin_layout LyX-Code
7      ...
\end_layout

\begin_layout LyX-Code
8  }
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Line 4 : The attribute to be memorized is created and inserted in the attribute
 vector.
\end_layout

\begin_layout Standard
Line 5 : The 
\emph on
set_memorized()
\emph default
 method of the attribute base class is called to define the attribute as
 memorized.
\end_layout

\begin_layout Standard
Line 6 : The set_memorized_init() method is called with the parameter false
 to define that only the set point should be initialsied.
\end_layout

\begin_layout Section
Forwarded attribute
\end_layout

\begin_layout Subsection
Definition
\end_layout

\begin_layout Standard
Let's take an example to explain what is a forwarded attribute.
 We assume we have to write a Tango class for a ski lift in a ski resort
 somewhere in the Alps.
 Obviously, the ski lift has a motor for which we already have a Tango class.
 This motor Tango class has one attribute 
\emph on
speed
\emph default
.
 But for the ski lift, the motor speed is not the only thing which has to
 be controlled.
 For instance, you also want to give access to the wind sensor data installed
 on the top of the ski lift.
 Therefore, you write a ski-lift Tango class representing the whole ski-lift
 system.
 This ski-lift class will have at least two attributes which are:
\end_layout

\begin_layout Enumerate
The wind speed at the top of the ski-lift
\end_layout

\begin_layout Enumerate
The motor speed
\end_layout

\begin_layout Standard
The ski-lift Tango class motor speed attribute is nothing more than the
 motor Tango class speed attribute.
 All the ski-lift class has to do for this attribute is to forward the request
 (read/write) to the speed attribute of the motor Tango class.
 The speed attribute of the ski-lift Tango class is a 
\series bold
forwarded attribute
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout

\series medium
forwarded-attribute
\end_layout

\end_inset


\series default
 while the speed attribute of the motor Tango class is its 
\series bold
root attribute
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
root-attribute
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A forwarded attribute get its configuration from its root attribute and
 it forwards to its root attribute
\end_layout

\begin_layout Itemize
Its read / write / write_read requests
\end_layout

\begin_layout Itemize
Its configuration change
\end_layout

\begin_layout Itemize
Its event subscription
\end_layout

\begin_layout Itemize
Its locking behavior
\end_layout

\begin_layout Standard
As stated above, a forwarded attribute has the same configuration than its
 root attribute except its 
\emph on
name
\emph default
 and 
\emph on
label
\emph default
 which stays local.
 All other attribute configuration parameters are forwarded to the root
 attribute.
 If a root attribute configuration parameter is changed, the forwarded attribute
 is informed (via event) and its local configuration is also modified.
\end_layout

\begin_layout Standard
The association between the forwarded attribute and its root attribute is
 done using a property named 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset

__root_att
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset

 belonging to the forwarded attribute.
 This property value is simply the name of the root attribute.
 Muti-control system is supported and this __root_att
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
__root_att
\end_layout

\end_inset

 attribute property value can be something like 
\emph on
tango://my_tango_host:10000/my/favorite/dev/the_root_attribute
\emph default
.
 The name of the root attribute is included in attribute configuration.
\end_layout

\begin_layout Standard
It is forbidden to poll a forwarded attribute and one exception is thrown
 if such a case happens.
 Polling has to be done on the root attribute.
 Nevertheless, if the root attribute is polled, a request to read the forwarded
 attribute with the DeviceProxy object source parameter set to CACHE_DEVICE
 or CACHE will get its data from the root attribute polling buffer.
\end_layout

\begin_layout Standard
If you subscribe to event(s) on a forwarded attribute, the subscription
 is forwarded to the root attribute.
 When the event is received by the forwarded attribute, the attribute name
 in the event data is modified to reflect the forwarded attribute name and
 the event is pushed to the original client(s).
\end_layout

\begin_layout Standard
When a device with forwarded attribute is locked, the device to which the
 root attribute belongs is also locked.
\end_layout

\begin_layout Subsection
Coding
\end_layout

\begin_layout Standard
As explained in the chapter "Writing a Tango device server", each Tango
 class attribute is implemented via a C++ class which has to inherit from
 either 
\emph on
Attr
\emph default
, 
\emph on
SpectrumAttr
\emph default
 or 
\emph on
ImageAttr
\emph default
 according to the attribute data format.
 For forwarded attribute, the related class has to inherit from the 
\series bold
FwdAttr
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout

\series medium
FwdAttr
\end_layout

\end_inset


\series default
 class whatever its data format is.
 For classical attribute, the programmer can define in the Tango class code
 default value for the attribute properties using one instance of the 
\emph on
UserDefaultAttrProp
\emph default
 class.
 For forwarded attribute, the programmer has to create one instance of the
 
\series bold
UserDefaultFwdAttrProp
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout

\series medium
UserDefaultFwdAttrProp
\end_layout

\end_inset


\series default
 class but only the attribute label can be defined.
 One example of how to program a forwarded attribute is given below
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
\align block
1  class MyFwdAttr: public Tango::FwdAttr
\end_layout

\begin_layout LyX-Code
\align block
2  { 
\end_layout

\begin_layout LyX-Code
\align block
3  public:     
\end_layout

\begin_layout LyX-Code
\align block
4      MyFwdAttr(const string &_n):FwdAttr(_n) {}; 	
\end_layout

\begin_layout LyX-Code
\align block
5      ~MyFwdAttr() {}; 
\end_layout

\begin_layout LyX-Code
\align block
6  };
\end_layout

\begin_layout LyX-Code
7
\end_layout

\begin_layout LyX-Code
\align block
8  void DevTestClass::attribute_factory(vector<Tango::Attr *> &att_list)
\end_layout

\begin_layout LyX-Code
9  {
\end_layout

\begin_layout LyX-Code
10     ...
\end_layout

\begin_layout LyX-Code
11     MyFwdAttr *att1 = new MyFwdAttr("fwd_att_name");
\end_layout

\begin_layout LyX-Code
12     Tango::UserDefaultFwdAttrProp att1_prop; 	
\end_layout

\begin_layout LyX-Code
13     att1_prop.set_label("Gasp a fwd attribute");
\end_layout

\begin_layout LyX-Code
14     att1->set_default_properties(att1_prop); 	
\end_layout

\begin_layout LyX-Code
15     att_list.push_back(att1);
\end_layout

\begin_layout LyX-Code
14     ...
\end_layout

\begin_layout LyX-Code
15  }
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Line 1 : The forwarded attribute class inherits from FwdAttr class.
\end_layout

\begin_layout Standard
Line 4-5 : Only constructor and destructor methods are required
\end_layout

\begin_layout Standard
Line 11 : The attribute object is created
\end_layout

\begin_layout Standard
Line 12-14 : A default value for the forwarded attribute label is defined.
\end_layout

\begin_layout Standard
Line 15: The forwarded attribute is added to the list of attribute
\end_layout

\begin_layout Standard
In case of error in the forwarded attribute configuration (for instance
 missing __root_att property), the attribute is not created by the Tango
 kernel and is therefore not visible for the external world.
 The state of the device to which the forwarded attribute belongs to is
 set to ALARM (if not already FAULT) and a detailed error report is available
 in the device status.
 In case a device with forwarded attribute(s) is started before the device(s)
 with the root attribute(s), the same principle is used: forwarded attribute(s)
 are not created, device state is set to ALARM and device status is reporting
 the error.
 When the device(s) with the root attribute will start, the forwarded attributes
 will automatically be created.
 
\end_layout

\begin_layout Section
Transferring images
\end_layout

\begin_layout Standard
Some optimized methods have been written to optimize image transfer between
 client and server using the attribute DevEncoded
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
DevEncoded
\end_layout

\end_inset

 data type.
 All these methods have been merged in a class called EncodedAttribute.
 Within this class, you will find methods to:
\end_layout

\begin_layout Itemize
Encode an image in a compressed way (JPEG
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JPEG
\end_layout

\end_inset

) for images coded on 8 (gray scale), 24 or 32 bits
\end_layout

\begin_layout Itemize
Encode a grey scale image coded on 8 or 16 bits
\end_layout

\begin_layout Itemize
Encode a color image coded on 24 bits
\end_layout

\begin_layout Itemize
Decode images coded on 8 or 16 bits (gray scale) and returned a 8 or 16
 bits grey scale image
\end_layout

\begin_layout Itemize
Decode color images transmitted using a compressed format (JPEG) and returns
 a 32 bits RGB image
\end_layout

\begin_layout Standard
The following code snippets are examples of how these methods have to be
 used in a server and in a client.
 On the server side, creates an instance of the EncodedAttribute
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
EncodedAttribute
\end_layout

\end_inset

 class within your object
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
\align block
1 class MyDevice::Tango::Device_4Impl
\end_layout

\begin_layout LyX-Code
2  {
\end_layout

\begin_layout LyX-Code
3      ...
\end_layout

\begin_layout LyX-Code
4      Tango::EncodedAttribute jpeg;
\end_layout

\begin_layout LyX-Code
5      ...
\end_layout

\begin_layout LyX-Code
6  }
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
In the code of your device, use an encoding method of the EncodedAttribute
 class
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
\align block
1 void MyDevice::read_Encoded_attr_image(Tango::Attribute &att)
\end_layout

\begin_layout LyX-Code
2 {
\end_layout

\begin_layout LyX-Code
3      ....
\end_layout

\begin_layout LyX-Code
4      jpeg.encode_jpeg_gray8(imageData,256,256,50.0);
\end_layout

\begin_layout LyX-Code
5      att.set_value(&jpeg);
\end_layout

\begin_layout LyX-Code
6 }
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Line 4: Image encoding.
 The size of the image is 256 by 256.
 Each pixel is coded using 8 bits.
 The encoding quality is defined to 50 in a scale of 0 - 100.
 imageData is the pointer to the image data (pointer to unsigned char)
\end_layout

\begin_layout Standard
Line 5: Set the value of the attribute using a 
\emph on
Attribute::set_value()
\emph default
 method.
\end_layout

\begin_layout Standard
On the client side, the code is the following (without exception management)
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
\align block
1    ....
\end_layout

\begin_layout LyX-Code
\align block
2    DeviceAttribute da;
\end_layout

\begin_layout LyX-Code
\align block
3    EncodedAttribute att;
\end_layout

\begin_layout LyX-Code
\align block
4    int width,height;
\end_layout

\begin_layout LyX-Code
\align block
5    unsigned char *gray8;
\end_layout

\begin_layout LyX-Code
6      
\end_layout

\begin_layout LyX-Code
7    da = device.read_attribute("Encoded_attr_image");
\end_layout

\begin_layout LyX-Code
8    att.decode_gray8(&da,&width,&height,&gray8);
\end_layout

\begin_layout LyX-Code
9    ....
\end_layout

\begin_layout LyX-Code
10   delete [] gray8;
\end_layout

\begin_layout LyX-Code
11   ...
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
The attribute named Encoded_attr_image is read at line7.
 The image is decoded at line 8 in a 8 bits gray scale format.
 The image data are stored in the buffer pointed to by "gray8".
 The memory allocated by the image decoding at line 8 is returned to the
 system at line 10.
\end_layout

\begin_layout Section
Device server with user defined event loop
\end_layout

\begin_layout Standard
Sometimes, it could be usefull to write your own process event handling
 loop
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
event-loop
\end_layout

\end_inset

.
 For instance, this feature can be used in a device server process where
 the ORB is only one of several components that must perform event handling.
 A device server with a graphical user interface must allow the GUI to handle
 windowing events in addition to allowing the ORB to handle incoming requests.
 These types of device server therefore perform non-blocking event handling.
 They turn the main thread of control over each of the vvarious event-handling
 sub-systems while not allowing any of them to block for significants period
 of time.
 The 
\emph on
Tango::Util
\emph default
 class has a method called 
\emph on
server_set_event_loop()
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
server-set-event-loop
\end_layout

\end_inset


\emph default
 to deal with such a case.
 This method has only one argument which is a function pointer.
 This function does not receive any argument and returns a boolean.
 If this boolean is true, the device server process exits.
 The device server core will call this function in a loop without any sleeping
 time between the call.
 It is the user responsability to implement in this function some kind of
 sleeping mechanism in order not to make this loop too CPU consuming.
 The code of this function is executed by the device server main thread
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
thread
\end_layout

\end_inset

.
 The following piece of code is an example of how you can use this feature.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
\align block
     1  
\end_layout

\begin_layout LyX-Code
     2  bool my_event_loop()
\end_layout

\begin_layout LyX-Code
     3  {
\end_layout

\begin_layout LyX-Code
     4     bool ret;
\end_layout

\begin_layout LyX-Code
     5  
\end_layout

\begin_layout LyX-Code
     6     some_sleeping_time();
\end_layout

\begin_layout LyX-Code
     7  
\end_layout

\begin_layout LyX-Code
     8     ret = handle_gui_events();
\end_layout

\begin_layout LyX-Code
     9  
\end_layout

\begin_layout LyX-Code
    10     return ret;
\end_layout

\begin_layout LyX-Code
    11  }
\end_layout

\begin_layout LyX-Code
    12  
\end_layout

\begin_layout LyX-Code
    13  int main(int argc,char *argv[])
\end_layout

\begin_layout LyX-Code
    14  {
\end_layout

\begin_layout LyX-Code
    15     Tango::Util *tg;
\end_layout

\begin_layout LyX-Code
    16     try
\end_layout

\begin_layout LyX-Code
    17     {
\end_layout

\begin_layout LyX-Code
    18        // Initialise the device server
\end_layout

\begin_layout LyX-Code
    19        //----------------------------------------
\end_layout

\begin_layout LyX-Code
    20        tg = Tango::Util::init(argc,argv);
\end_layout

\begin_layout LyX-Code
    21  
\end_layout

\begin_layout LyX-Code
    22        tg->set_polling_threads_pool_size(5);
\end_layout

\begin_layout LyX-Code
    23  
\end_layout

\begin_layout LyX-Code
    24        // Create the device server singleton 
\end_layout

\begin_layout LyX-Code
    25        //        which will create everything
\end_layout

\begin_layout LyX-Code
    26        //----------------------------------------
\end_layout

\begin_layout LyX-Code
    27        tg->server_init(false);
\end_layout

\begin_layout LyX-Code
    28  
\end_layout

\begin_layout LyX-Code
    29        tg->server_set_event_loop(my_event_loop);
\end_layout

\begin_layout LyX-Code
    30  
\end_layout

\begin_layout LyX-Code
    31        // Run the endless loop
\end_layout

\begin_layout LyX-Code
    32        //----------------------------------------
\end_layout

\begin_layout LyX-Code
    33        cout << "Ready to accept request" << endl;
\end_layout

\begin_layout LyX-Code
    34        tg->server_run();
\end_layout

\begin_layout LyX-Code
    35     }
\end_layout

\begin_layout LyX-Code
    36     catch (bad_alloc)
\end_layout

\begin_layout LyX-Code
    37     {
\end_layout

\begin_layout LyX-Code
    38     ...
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
The device server main event loop is set at line 29 before the call to the
 Util::server_run() method.
 The function used as server loop is defined between lines 2 and 11.
\end_layout

\begin_layout Section
Device server using file
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
file
\end_layout

\end_inset

 as database
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
database
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sec:Device-server-file"

\end_inset


\end_layout

\begin_layout Standard
For device servers not able to access the Tango database (most of the time
 due to network route or security reason), it is possible to start them
 using file instead of a real database.
 This is done via the device server
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset

-file=<file name>
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset

 command line option.
 In this case,
\end_layout

\begin_layout Itemize
Getting, setting and deleting class properties
\end_layout

\begin_layout Itemize
Getting, setting and deleting device properties
\end_layout

\begin_layout Itemize
Getting, setting and deleting class attribute properties
\end_layout

\begin_layout Itemize
Getting, setting and deleting device attribute properties
\end_layout

\begin_layout Standard
are handled using the specified file instead of the Tango database.
 The file is an ASCII file and follows a well-defined syntax with predefined
 keywords.
 The simplest way to generate the file for a specific device server is to
 use the Jive application.
 See  
\begin_inset CommandInset citation
LatexCommand cite
key "Jive doc"

\end_inset

 to get Jive documentation.
 The Tango database is not only used to store device configuration parameters,
 it is also used to store device network access parameter (the CORBA IOR).
 To allow an application to connect to a device hosted by a device server
 using file instead of database, you need to start it on a pre-defined port
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
port
\end_layout

\end_inset

, and you must use one of the underlying ORB option called 
\emph on
endPoint
\emph default
 like 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset

myserver myinstance_name -file=/tmp/MyServerFile -ORBendPoint giop:tcp::<port
 number>
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset

 to start your device server.
 The device name passed to the client application must also be modified
 in order to refect the non-database usage.
 See 
\begin_inset CommandInset ref
LatexCommand ref
reference "DeviceNaming"

\end_inset

 to learn about Tango device name syntax.
 Nevertheless, using this Tango feature prevents some other features to
 be used :
\end_layout

\begin_layout Itemize
No check that the same device server is running twice.
\end_layout

\begin_layout Itemize
No device or attribute alias name.
\end_layout

\begin_layout Itemize
In case of several device servers running on the same host, the user must
 manually manage a list of already used network port.
\end_layout

\begin_layout Section
Device server without database
\begin_inset CommandInset label
LatexCommand label
name "sec:Device-server-without"

\end_inset


\end_layout

\begin_layout Standard
In some very specific cases (Running a device server within a lab during
 hardware development...), it could be very useful to have a device server
 able to run even if there is no database
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
database
\end_layout

\end_inset

 in the control system.
 Obviously, running a Tango device server without a database means loosing
 Tango features.
 The lost features are :
\end_layout

\begin_layout Itemize
No check that the same device server is running twice.
\end_layout

\begin_layout Itemize
No device configuration via properties.
\end_layout

\begin_layout Itemize
No event generated by the server.
\end_layout

\begin_layout Itemize
No memorized attributes
\end_layout

\begin_layout Itemize
No device attribute configuration via the database.
\end_layout

\begin_layout Itemize
No check that the same device name is used twice within the same control
 system.
\end_layout

\begin_layout Itemize
In case of several device servers running on the same host, the user must
 manually manage a list of already used network port.
\end_layout

\begin_layout Standard
To run a device server without a database, the 
\series bold
-nodb
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
nodb
\end_layout

\end_inset


\series default
 command line option must be used.
 One problem when running a device server without the database is to pass
 device name(s) to the device server.
 Within Tango, it is possible to define these device names at two different
 levels :
\end_layout

\begin_layout Enumerate
At the command line with the 
\series bold
-dlist
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
dlist
\end_layout

\end_inset


\series default
 option: In case of device server with several device pattern implementation,
 the device name list given at command line is only for the last device
 pattern created in the 
\emph on
class_factory()
\emph default
 method.
 In the device name list, the device name separator is the comma character.
\end_layout

\begin_layout Enumerate
At the device pattern implementation level: In the class inherited from
 the Tango::DeviceClass class via the re-definition of a well defined method
 called 
\emph on
device_name_factory()
\end_layout

\begin_layout Standard
If none of these two possibilities is used, the tango core classes defined
 one default device name for each device pattern implementation.
 This default device name is 
\emph on
NoName
\emph default
.
 Device definition at the command line has the highest priority.
\end_layout

\begin_layout Subsection
Example of device server started without database usage
\end_layout

\begin_layout Standard
Without database, you need to start a Tango device server on a pre-defined
 port
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
port
\end_layout

\end_inset

, and you must use one of the underlying ORB option called 
\emph on
endPoint
\emph default
 like 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset

myserver myinstance_name -ORBendPoint giop:tcp::<port number> -nodb -dlist
 a/b/c
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following is two examples of starting a device server not using the
 database when the 
\emph on
device_name_factory()
\emph default
 method is not re-defined.
\end_layout

\begin_layout Itemize
StepperMotor et -nodb -dlist id11/motor/1,id11/motor/2
\begin_inset Newline newline
\end_inset

This command line starts the device server with two devices named 
\emph on
id11/motor/1
\emph default
 and 
\emph on
id11/motor/2
\end_layout

\begin_layout Itemize
StepperMotor et -nodb
\begin_inset Newline newline
\end_inset

This command line starts a device server with one device named 
\emph on
NoName
\end_layout

\begin_layout Standard
When the 
\emph on
device_name_factory()
\emph default
 method is re-defined within the StepperMotorClass class.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout LyX-Code
     1  void StepperMotorClass::device_name_factory(vector<string> &list)
\end_layout

\begin_layout LyX-Code
     2  {
\end_layout

\begin_layout LyX-Code
     3      list.push_back("sr/cav-tuner/1");
\end_layout

\begin_layout LyX-Code
     4      list.push_back("sr/cav-tuner/2");
\end_layout

\begin_layout LyX-Code
     5  }
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Itemize
StepperMotor et -nodb
\begin_inset Newline newline
\end_inset

This commands starts a device server with two devices named 
\emph on
sr/cav-tuner/1
\emph default
 and 
\emph on
sr/cav-tuner/2
\emph default
.
\end_layout

\begin_layout Itemize
StepperMotor et -nodb -dlist id12/motor/1
\begin_inset Newline newline
\end_inset

Starts a device server with only one device named id12/motor/1
\end_layout

\begin_layout Subsection
Connecting client to device within a device server started without database
\end_layout

\begin_layout Standard
In this case, the host and port on which the device server is running are
 part of the device name.
 If the device name is 
\emph on
a/b/c
\emph default
, the host is 
\emph on
mycomputer
\emph default
 and the port 
\emph on
1234
\emph default
, the device name to be used by client is
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset

mycomputer:1234/a/b/c#dbase=no
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
See appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "DeviceNaming"

\end_inset

 for all details about Tango object naming.
\end_layout

\begin_layout Section
Multiple database servers within a Tango control system
\end_layout

\begin_layout Standard
Tango uses MySQL as database and allows access to this database via a specific
 Tango device server.
 It is possible for the same Tango control system to have several Tango
 database servers.
 The host name and port number of the database server is known via the TANGO_HOS
T
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
TANGO-HOST
\end_layout

\end_inset

 environment variable.
 If you want to start several database servers in order to prevent server
 crash, use the following TANGO_HOST syntax
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

TANGO_HOST=<host_1>:<port_1>,<host_2>:<port_2>,<host_3>:<port_3>
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All calls to the database server will automatically switch to a running
 servers in the given list if the one used dies.
\end_layout

\begin_layout Section
The Tango controlled access system
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
controlled-access
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
User rights definition
\end_layout

\begin_layout Standard
Within the Tango controlled system, you give rights to a user.
 User is the name of the user used to log-in the computer where the application
 trying to access a device is running.
 Two kind of users are defined:
\end_layout

\begin_layout Enumerate
Users with defined rights
\end_layout

\begin_layout Enumerate
Users without any rights defined in the controlled system.
 These users will have the rights associated with the pseudo-user called
 "All Users"
\end_layout

\begin_layout Standard
The controlled system manages two kind of rights:
\end_layout

\begin_layout Itemize
Write access meaning that all type of requests are allowed on the device
\end_layout

\begin_layout Itemize
Read access meaning that only read-like access are allowed (write_attribute,
 write_read_attribute and set_attribute_config network calls are forbidden).
 Executing a command is also forbidden except for commands defined as "
\series bold
Allowed commands
\series default
".
 Getting a device state or status using the command_inout call is always
 allowed.
 The definition of the allowed commands is done at the device class level.
 Therefore, all devices belonging to the same class will have the allowed
 commands set.
\end_layout

\begin_layout Standard
The rights given to a user is the check result splitted in two levels:
\end_layout

\begin_layout Enumerate
At the host level: You define from which hosts the user may have write access
 to the control system by specifying the host name.
 If the request comes from a host which is not defined, the right will be
 Read access.
 If nothing is defined at this level for the user, the rights of the "All
 Users" user will be used.
 It is also possible to specify the host by its IP address.
 You can define a host family using wide-card in the IP address (eg.
 160.103.11.* meaning any host with IP address starting with 160.103.11).
 Only IP V4 is supported.
 
\end_layout

\begin_layout Enumerate
At the device level: You define on which device(s) request are allowed using
 device name.
 Device family can be used using widecard in device name like domin/family/*
\end_layout

\begin_layout Standard
Therefore, the controlled system is doing the following checks when a client
 try to access a device:
\end_layout

\begin_layout Itemize
Get the user name
\end_layout

\begin_layout Itemize
Get the host IP address
\end_layout

\begin_layout Itemize
If rights defined at host level for this specific user and this IP address,
 gives user temporary write acccess to the control system
\end_layout

\begin_layout Itemize
If nothing is specified for this specific user on this host, gives to the
 user a temporary access right equal to the host access rights of the "All
 User" user.
\end_layout

\begin_layout Itemize
If the temporary right given to the user is write access to the control
 system
\end_layout

\begin_deeper
\begin_layout Itemize
If something defined at device level for this specific user
\end_layout

\begin_deeper
\begin_layout Itemize
If there is a right defined for the device to be accessed (or for the device
 family), give user the defined right
\end_layout

\begin_layout Itemize
Else
\end_layout

\begin_deeper
\begin_layout Itemize
If rights defined for the "All Users" user for this device, give this right
 to the user
\end_layout

\begin_layout Itemize
Else, give user the Read Access for this device
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Else
\end_layout

\begin_deeper
\begin_layout Itemize
If there is a right defined for the device to be accessed (or for the device
 family) for the "All User" user, give user this right
\end_layout

\begin_layout Itemize
Else, give user the Read Access right for this device
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Else, access right will be Read Access
\end_layout

\begin_layout Standard
Then, when the client tries to access the device, the following algorithm
 is used:
\end_layout

\begin_layout Itemize
If right is Read Access
\end_layout

\begin_deeper
\begin_layout Itemize
If the call is a write type call, refuse the call
\end_layout

\begin_layout Itemize
If the call is a command execution
\end_layout

\begin_deeper
\begin_layout Itemize
If the command is one of the command defined in the "Allowed commands" for
 the device class, send the call
\end_layout

\begin_layout Itemize
Else, refuse the call
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
All these checks are done during the DeviceProxy instance constructor except
 those related to the device class allowed commands which are checked during
 the command_inout call.
\end_layout

\begin_layout Standard
To simplify the rights management, give the "All Users" user host access
 right to all hosts ("*.*.*.*") and read access to all devices ("*/*/*").
 With such a set-up for this user, each new user without any rights defined
 in the controlled access will have only Read Access to all devices on the
 control system but from any hosts.
 Then, on request, gives Write Access to specific user on specific host
 (or family) and on specific device (or family).
 
\end_layout

\begin_layout Standard
The rights managements are done using the Tango Astor
\begin_inset CommandInset citation
LatexCommand cite
key "Astor_doc"

\end_inset

 tool which has some graphical windows allowing to grant/revoke user rights
 and to define device class allowed commands set.
 The following window dump shows this Astor window.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\begin_inset Graphics
	filename control.PNG

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align block
In this example, the user "taurel" has Write Access to the device "sr/d-ct/1"
 and to all devices belonging to the domain "fe" but only from the host
 "pcantares" He has read access to all other devices but always only from
 the host pcantares.
 The user "verdier" has write access to the device "sys/dev/01" from any
 host on the network "160.103.5" and Read Access to all the remaining devices
 from the same network.
 All the other users has only Read Access but from any host.
\end_layout

\begin_layout Subsection
Running a Tango control system with the controlled access
\end_layout

\begin_layout Standard
All the users rights are stored in two tables of the Tango database.
 A dedicated device server called 
\series bold
TangoAccessControl
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
TangoAccessControl
\end_layout

\end_inset


\series default
 access these tables without using the classical Tango database server.
 This TangoAccessControl device server must be configured with only one
 device.
 The property 
\series bold
Services
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Services
\end_layout

\end_inset

 
\series default
belonging to the free object
\series bold
 CtrlSystem
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
CtrlSystem
\end_layout

\end_inset


\series default
 is used to run a Tango control system with its controlled access.
 This property is an array of string with each string describing the service(s)
 running in the control system.
 For controlled access, the service name is "AccessControl".
 The service instance name has to be defined as "tango".
 The device name associated with this service must be the name of the TangoAcces
sControl server device.
 For instance, if the TangoAccessControl device server device is named 
\emph on
sys/access_control/1
\emph default
, one element of the Services property of the CtrlSystem object has to be
 set to
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset

AccessControl/tango:sys/access_control/1
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the service is defined but without a valid device name corresponding
 to the TangoAccessControl device server, all users from any host will have
 write access (simulating a Tango control system without controlled access).
 Note that this device server connects to the MySQL database and therefore
 may need the MySQL connection related environment variables MYSQL_USER
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
MYSQL-USER
\end_layout

\end_inset

 and MYSQL_PASSWORD
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
MYSQL-PASSWORD
\end_layout

\end_inset

 described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Db-Env-Variables"

\end_inset


\end_layout

\begin_layout Standard
Even if a controlled access system is running, it is possible to by-pass
 it if, in the environment of the client application, the environment variable
 SUPER_TANGO
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
SUPER-TANGO
\end_layout

\end_inset

 is defined to "true".
 If for one reason or another, the controlled access server is defined but
 not accessible, the device right checked at that time will be Read Access.
\begin_inset VSpace 1cm
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset label
LatexCommand label
name "FourRicardo"

\end_inset


\begin_inset Graphics
	filename ../dance/AT97-65-size.jpg
	scale 400

\end_inset


\end_layout

\end_body
\end_document
