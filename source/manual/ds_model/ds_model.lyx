#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage{a4wide}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding latin1
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 5
\tocdepth 5
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
The TANGO device server model
\end_layout

\begin_layout Standard
This chapter will present the TANGO device server object model hereafter
 referred as TDSOM
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
TDSOM
\end_layout

\end_inset

.
 First, it will introduce CORBA
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
CORBA
\end_layout

\end_inset

.
 Then, it will describe each of the basic features of the TDSOM and their
 function.
 The TDSOM can be divided into the following basic elements - the 
\emph on
device
\emph default
, the 
\emph on
server
\emph default
, the 
\emph on
database
\emph default
 and the 
\emph on
application programmers interface
\emph default
.
 This chapter will treat each of the above elements separately.
\end_layout

\begin_layout Section
Introduction to CORBA
\begin_inset CommandInset label
LatexCommand label
name "sec:corba"

\end_inset


\end_layout

\begin_layout Standard
CORBA is a definition of how to write object request brokers (ORB
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ORB
\end_layout

\end_inset

).
 The definition is managed by the Object Management Group (OMG
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
OMG
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "OMG-page"

\end_inset

).
 Various commercial and non-commercial implementations exist for CORBA for
 all the mainstream operating systems.
 CORBA
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
CORBA
\end_layout

\end_inset

 uses a programming language independent definition language (called IDL)
 to defined network object interfaces.
 Language mappings are defined from IDL
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
IDL
\end_layout

\end_inset

 to the main programming languages e.g.
 C++, Java, C, COBOL, Smalltalk and ADA.
 Within an interface, CORBA defines two kinds of actions available to the
 outside world.
 These actions are called 
\series bold
attributes
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
attribute
\end_layout

\end_inset


\series default
 and 
\series bold
operations
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
operation
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Operations are all the actions offered by an interface.
 For instance, within an interface for a Thermostat class, operations could
 be the action to read the temperature or to set the nominal temperature.
 An attribute defines a pair of operations a client can call to send or
 receive a value.
 For instance, the position of a motor can be defined as an attribute because
 it is a data that you only set or get.
 A read only attribute defines a single operation the client can call to
 receives a value.
 In case of error, an operation is able to throw an exception to the client,
 attributes cannot raises exception except system exception (du to network
 fault for instance).
\end_layout

\begin_layout Standard
Intuitively, IDL interface correspond to C++ classes and IDL operations
 correspond to C++ member functions and attributes as a way to read/write
 public member variable.
 Nevertheless, IDL defines only the interface to an object and say nothing
 about the object implementation.
 IDL is only a descriptive language.
 Once the interface is fully described in the IDL language, a compiler (from
 IDL to C++, from IDL to Java...) generates code to implement this interface.
 Obviously, you still have to write how operations are implemented.
\end_layout

\begin_layout Standard
The act of invoking an operation on an interface causes the ORB to send
 a message to the corresponding object implementation.
 If the target object is in another address space, the ORB run time sends
 a remote procedure call to the implementation.
 If the target object is in the same address space as the caller, the invocation
 is accomplished as an ordinary function call to avoid the overhead of using
 a networking protocol.
\end_layout

\begin_layout Standard
For an excellent reference on CORBA
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
CORBA
\end_layout

\end_inset

 with C++ refer to 
\begin_inset CommandInset citation
LatexCommand cite
key "Henning"

\end_inset

.
 The complete TANGO IDL
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
IDL
\end_layout

\end_inset

 file can be found in the TANGO web page
\begin_inset CommandInset citation
LatexCommand cite
key "Tango web"

\end_inset

 or at the end of this document in the appendix 2 chapter.
\end_layout

\begin_layout Section
The model
\end_layout

\begin_layout Standard
The basic idea of the TDSOM
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
TDSOM
\end_layout

\end_inset

 is to treat each device as an 
\series bold
object
\series default
.
 Each device is a separate entity which has its own data and behavior.
 Each device has a unique name which identifies it in network name space.
 Devices are organized according to 
\series bold
classes
\series default
, each device belonging to a class.
 All classes are derived from one root class thus allowing some common behavior
 for all devices.
 Four kind of requests can be sent to a device (locally i.e.
 in the same process, or remotely i.e.
 across the network) :
\end_layout

\begin_layout Itemize
Execute actions via 
\series bold
commands
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
command
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Read/Set data specific to each device belonging to a class via TANGO 
\series bold
attributes
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
attribute
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Read/Set data specific to each device belonging to a class via TANGO 
\series bold
pipes
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pipe
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Read some basic device data available for all devices via CORBA attributes.
\end_layout

\begin_layout Itemize
Execute a predefined set of actions available for every devices via CORBA
 operations
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
operation
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each device is stored in a process called a 
\series bold
device server
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
server
\end_layout

\end_inset

.
 Devices are configured at runtime via 
\series bold
properties
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
properties
\end_layout

\end_inset


\series default
 which are stored in a 
\series bold
database
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
database
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
The device
\begin_inset CommandInset label
LatexCommand label
name "sec:dev"

\end_inset


\end_layout

\begin_layout Standard
The device is the heart of the TDSOM.
 A device is an abstract concept defined by the TDSOM.
 In reality, it can be a piece of hardware (an interlock bit) a collection
 of hardware (a screen attached to a stepper motor) a logical device (a
 taper) or a combination of all these (an accelerator).
 Each device has a unique name in the control system and eventually one
 alias
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
alias
\end_layout

\end_inset

.
 Within Tango, a four field name
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
name
\end_layout

\end_inset

 space has been adopted consisting of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset

[//FACILITY/]DOMAIN/CLASS/MEMBER
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset

 Facility refers to the control system instance, domain refers to the sub-system
, class the class and member the instance of the device.
 Device name alias(es) must also be unique within a control system.
 There is no predefined syntax for device name alias.
\end_layout

\begin_layout Standard
Each device belongs to a class.
 The device class contains a complete description and implementation of
 the behavior of all members of that class.
 New device classes can be constructed out of existing device classes.
 This way a new hierarchy of classes can be built up in a short time.
 Device classes can use existing devices as sub-classes or as sub-objects.
 The practice of reusing existing classes is classical for Object Oriented
 Programming and is one of its main advantages.
\end_layout

\begin_layout Standard
All device classes are derived from the same class (the device root class)
 and implement 
\series bold
the same CORBA interface
\series default
.
 All devices implementing the same CORBA interface ensures all control object
 support the same set of CORBA operations and attributes.
 The device root class contains part of the common device code.
 By inheriting from this class, all devices shared a common behavior.
 This also makes maintenance and improvements to the TDSOM easy to carry
 out.
\end_layout

\begin_layout Standard
All devices also support a 
\series bold
black box
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
black-box
\end_layout

\end_inset


\series default
 where client requests for attributes or operations are recorded.
 This feature allows easier debugging session for device already installed
 in a running control system.
\end_layout

\begin_layout Subsection
The commands
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
command
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each device class implements a list of commands.
 Commands are very important because they are the client's major dials and
 knobs for controlling a device.
 Commands have a fixed calling syntax - consisting of one input argument
 and one output argument.
 Arguments type must be chosen in a fixed set of data types: All simple
 types (boolean, short, long (32 bits), long (64 bits), float, double, unsigned
 short, unsigned long (32 bits), unsigned long (64 bits) and string) and
 arrays of simple types plus array of strings and longs and array of strings
 and doubles).
 Commands can execute any sequence of actions.
 Commands can be executed synchronously (the requester is blocked until
 the command ended) or asynchronously (the requester send the request and
 is called back when the command ended).
\end_layout

\begin_layout Standard
Commands are executed using two CORBA operations named 
\series bold
command_inout
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
command-inout
\end_layout

\end_inset


\series default
 for synchronous commands and 
\series bold
command_inout_async
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
command-inout-async
\end_layout

\end_inset


\series default
 for asynchronous commands.
 These two operations called a special method implemented in the device
 root class - the 
\emph on
command_handler
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
command-handler
\end_layout

\end_inset


\emph default
 method.
 The 
\emph on
command_handler
\emph default
 calls an 
\emph on
is_allowed
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
is-allowed
\end_layout

\end_inset


\emph default
 method implemented in the device class before calling the command itself.
 The 
\emph on
is_allowed
\emph default
 method is specific to each command
\begin_inset Foot
status open

\begin_layout Plain Layout
In contrary to the state_handler method of the TACO device server model
 which is not specific to each command.
\end_layout

\end_inset

.
 It checks to see whether the command to be executed is compatible with
 the present device state.
 The command function is executed only if the 
\emph on
is_allowed
\emph default
 method allows it.
 Otherwise, an exception is sent to the client.
\end_layout

\begin_layout Subsection
The TANGO attributes
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
attribute
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In addition to commands, TANGO devices also support normalized data types
 called attributes
\begin_inset Foot
status open

\begin_layout Plain Layout
TANGO attributes were known as signals in the TACO device server model
\end_layout

\end_inset

.
 Commands are device specific and the data they transport are not normalized
 i.e.
 they can be any one of the TANGO data types with no restriction on what
 each byte means.
 This means that it is difficult to interpret the output of a command
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
command
\end_layout

\end_inset

 in terms of what kind of value(s) it represents.
 Generic display programs need to know what the data returned represents,
 in what units it is, plus additional information like minimum, maximum,
 quality etc.
 Tango attributes solve this problem.
\end_layout

\begin_layout Standard
TANGO attributes are zero, one or two dimensional data which have a fix
 set of properties e.g.
 quality, minimum and maximum, alarm low and high.
 They are transferred in a specialized TANGO type and can be read, write
 or read-write.
 A device can support a list of attributes.
 Clients can read one or more attributes from one or more devices.
 To read TANGO attributes, the client uses the 
\series bold
read_attributes
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
read-attributes
\end_layout

\end_inset


\series default
 operation.
 To write TANGO attributes, a client uses the 
\series bold
write_attributes
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
write-attributes
\end_layout

\end_inset


\series default
 operation.
 To write then read TANGO attributes within the same network request, the
 client uses the 
\series bold
write_read_attributes
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
write-read-attribute
\end_layout

\end_inset


\series default
 operation.
 To query a device for all the attributes it supports, a client uses the
 
\series bold
get_attribute_config
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
get-attribute-config
\end_layout

\end_inset


\series default
 operation.
 A client is also able to modify some of parameters defining an attribute
 with the 
\series bold
set_attribute_config
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
set-attribute-config
\end_layout

\end_inset


\series default
 operation.
 These five operations are defined in the device CORBA interface.
\end_layout

\begin_layout Standard
TANGO support thirteen data types for attributes (and arrays of for one
 or two dimensional data) which are: boolean, short, long (32 bits), long
 (64 bits), float, double, unsigned char, unsigned short, unsigned long
 (32 bits), unsigned long (64 bits), string, a specific data type for Tango
 device state and finally another specific data type to transfer data as
 an array of unsigned char with a string describing the coding of these
 data.
\end_layout

\begin_layout Subsection
The TANGO pipes
\begin_inset Index idx
status open

\begin_layout Plain Layout
pipe
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since release 9, in addition to commands and attributes, TANGO devices also
 support pipes.
\end_layout

\begin_layout Standard
In some cases, it is required to exchange data between client and device
 of varrying data type.
 This is for instance the case of data gathered during a scan on one experiment.
 Because the number of actuators and sensors involved in the scan may change
 from one scan to another, it is not possible to use a well defined data
 type.
 TANGO pipes have been designed for such cases.
 A TANGO pipe is basically a pipe dedicated to transfer data between client
 and device.
 A pipe has a set of two properties which are the pipe label and its description.
 A pipe can be read or read-write.
 A device can support a list of pipes.
 Clients can read one or more pipes from one or more devices.
 To read a TANGO pipe, the client uses the 
\series bold
read_pipe
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
read-pipe
\end_layout

\end_inset


\series default
 operation.
 To write a TANGO pipe, a client uses the 
\series bold
write_pipe
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
write-pipe
\end_layout

\end_inset


\series default
 operation.
 To write then read a TANGO pipe within the same network request, the client
 uses the 
\series bold
write_read_pipe
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
write-read-pipe
\end_layout

\end_inset


\series default
 operation.
 To query a device for all the pipes it supports, a client uses the 
\series bold
get_pipe_config
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
get-pipe-config
\end_layout

\end_inset


\series default
 operation.
 A client is also able to modify some of parameters defining a pipe with
 the 
\series bold
set_pipe_config
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
set-pipe-config
\end_layout

\end_inset


\series default
 operation.
 These five operations are defined in the device CORBA interface.
\end_layout

\begin_layout Standard
In contrary of commands or attributes, a TANGO pipe does not have a pre-defined
 data type.
 Data transferred through pipes may be of any basic Tango data type (or
 array of) and this may change every time a pipe is read or written.
 
\end_layout

\begin_layout Subsection
Command, attributes or pipes ?
\end_layout

\begin_layout Standard
There are no strict rules concerning what should be returned as command
 result and what should be implemented as an attribute or as a pipe.
 Nevertheless, attributes are more adapted to return physical value which
 have a kind of time consistency.
 Attribute also have more properties which help the client to precisely
 know what it represents.
 For instance, the state and the status of a power supply are not physical
 values and are returned as command result.
 The current generated by the power supply is a physical value and is implemente
d as an attribute.
 The attribute properties allow a client to know its unit, its label and
 some other informations which are related to a physical value.
 Command are well adapted to send order to a device like switching from
 one mode of operation to another mode of operation.
 For a power supply, the switch from a STANDBY mode to a ON mode is typically
 done via a command.
 Finally pipe is well adapted when the kind and number of data exchanged
 between the client and the device change with time.
\end_layout

\begin_layout Subsection
The CORBA attributes
\end_layout

\begin_layout Standard
Some key data implemented for each device can be read without the need to
 call a command or read an attribute.
 These data are :
\end_layout

\begin_layout Itemize
The device state
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
state
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The device status
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
status
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The device name
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
name
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The administration device name called adm_name
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
administration
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The device description
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
description
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The device state is a number representing its state.
 A set of predefined states are defined in the TDSOM.
 The device status is a string describing in plain text the device state
 and any additional useful information of the device as a formatted ascii
 string.
 The device name is its name as defined in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:dev"

\end_inset

.
 For each set of devices grouped within the same server, an administration
 device is automatically added.
 This adm_name is the name of the administration device.
 The device description is also an ascii string describing the device rule.
\end_layout

\begin_layout Standard
These five CORBA attributes are implemented in the device root class and
 therefore do not need any coding from the device class programmer.
 As explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:corba"

\end_inset

, the CORBA attributes are not allowed to raise exceptions whereas command
 (which are implemented using CORBA operations) can.
\end_layout

\begin_layout Subsection
The remaining CORBA operations
\end_layout

\begin_layout Standard
The TDSOM also supports a list of actions defined as CORBA operations in
 the device interface and implemented in the device root class.
 Therefore, these actions are implemented automatically for every TANGO
 device.
 These operations are :
\end_layout

\begin_layout Labeling
\labelwidthstring MMMMMMMMMMM
ping
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ping
\end_layout

\end_inset

 to ping a device to check if the device is alive.
 Obviously, it checks only the connection from a client to the device and
 not all the device functionalities
\end_layout

\begin_layout Labeling
\labelwidthstring MMMMMMMMMMM
command_list_query
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
command-list-query
\end_layout

\end_inset

 request a list of all the commands supported by a device with their input
 and output types and description
\end_layout

\begin_layout Labeling
\labelwidthstring MMMMMMMMMMM
command_query
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
command-query
\end_layout

\end_inset

 request information about a specific command which are its input and output
 type and description
\end_layout

\begin_layout Labeling
\labelwidthstring MMMMMMMMMMM
info
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
info
\end_layout

\end_inset

 request general information on the device like its name, the host where
 the device server hosting the device is running...
\end_layout

\begin_layout Labeling
\labelwidthstring MMMMMMMMMMM
black_box
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
black-box
\end_layout

\end_inset

 read the device black-box as an array of strings
\end_layout

\begin_layout Subsection
The special case of the device state and status
\end_layout

\begin_layout Standard
Device state
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
state
\end_layout

\end_inset

 and status
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
status
\end_layout

\end_inset

 are the most important key device informations.
 Nearly all client software dealing with Tango device needs device(s) state
 and/or status.
 In order to simplify client software developper work, it is possible to
 get these two piece of information in three different manners :
\end_layout

\begin_layout Enumerate
Using the appropriate CORBA attribute (state or status)
\end_layout

\begin_layout Enumerate
Using command on the device.
 The command are called State or Status
\end_layout

\begin_layout Enumerate
Using attribute.
 Even if the state and status are not real attribute, it is possible to
 get their value using the read_attributes operation.
 Nevertheless, it is not possible to set the attribute configuration for
 state and status.
 An error is reported by the server if a client try to do so.
\end_layout

\begin_layout Subsection
The device polling
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
polling
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Within the Tango framework, it is also possible to force executing command(s)
 or reading attribute(s) at a fixed frequency.
 It is called 
\emph on
device polling
\emph default
.
 This is automatically handled by Tango core software with a polling threads
 pool.
 The command result or attribute value are stored in circular buffers.
 When a client want to read attribute value (or command result) for a polled
 attribute (or a polled command), he has the choice to get the attribute
 value (or command result) with a real access to the device of from the
 last value stored in the device ring buffer.
 This is a great advantage for 
\begin_inset Quotes eld
\end_inset

slow
\begin_inset Quotes erd
\end_inset

 devices.
 Getting data from the buffer is much faster than accessing the device itself.
 The technical disadvantage is the time shift between the data returned
 from the polling buffer and the time of the request.
 Polling a command is only possible for command without input arguments.
 It is not possible to poll a device pipe
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pipe
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Two other CORBA operations called 
\emph on
command_inout_history_X
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
command-inout-history-X
\end_layout

\end_inset


\emph default
 and 
\emph on
read_attribute _history_X
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
read-attribute-history-X
\end_layout

\end_inset


\emph default
 allow a client to retrieve the history of polled command or attribute stored
 in the polling buffers.
 Obviously, this history is limited to the depth of the polling buffer.
 
\end_layout

\begin_layout Standard
The whole polling system is available only since Tango release 2.x and above
 in CPP and since TangORB release 3.7.x and above in Java.
\end_layout

\begin_layout Section
The server
\end_layout

\begin_layout Standard
Another integral part of the TDSOM is the server concept.
 The server (also referred as device server
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
server
\end_layout

\end_inset

) is a process whose main task is to offer one or more services to one or
 more clients.
 To do this, the server has to spend most of its time in a wait loop waiting
 for clients to connect to it.
 The devices are hosted in the server process.
 A server is able to host several classes of devices.
 In the TDSOM, a device of the 
\series bold
DServer
\series default
 class is automatically hosted by each device server.
 This class of device supports commands which enable remote device server
 process administration.
\end_layout

\begin_layout Standard
TANGO supports device server process on two families of operating system
 : Linux and Windows.
\end_layout

\begin_layout Section
The Tango Logging
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
logging
\end_layout

\end_inset

 Service
\begin_inset CommandInset label
LatexCommand label
name "sec:The-Tango-Logging"

\end_inset


\end_layout

\begin_layout Standard
During software life, it is always convenient to print miscellaneous information
s which help to:
\end_layout

\begin_layout Itemize
Debug the software
\end_layout

\begin_layout Itemize
Report on error
\end_layout

\begin_layout Itemize
Give regular information to user
\end_layout

\begin_layout Standard
This is classically done using cout (or C printf) in C++ or println method
 in Java language.
 In a highly distributed control system, it is difficult to get all these
 informations coming from a high number of different processes running on
 a large number of computers.
 Since its release 3, Tango has incorporated a Logging Service called the
 Tango Logging Service (TLS) which allows print messages to be:
\end_layout

\begin_layout Itemize
Displayed on a console (the classical way)
\end_layout

\begin_layout Itemize
Sent to a file
\end_layout

\begin_layout Itemize
Sent to specific Tango device called log consumer
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
consumer
\end_layout

\end_inset

.
 Tango package has an implementation of log consumer where every consumer
 device is associated to a graphical interface.
 This graphical interface display messages but could also be used to sort
 messages, to filter messages...
 Using this feature, it is possible to centralise display of these messages
 coming from different devices embedded within different processes.
 These log consumers can be:
\end_layout

\begin_deeper
\begin_layout Itemize
Statically configured meaning that it memorizes the list of Tango devices
 for which it will get and display messages.
\end_layout

\begin_layout Itemize
Dynamically configured.
 The user, with the help of the graphical interface, chooses devices from
 which he want to see messages.
\end_layout

\end_deeper
\begin_layout Section
The database
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
database
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To achieve complete device independence, it is necessary however to supplement
 device classes with a possibility for configuring device dependencies at
 runtime.
 The utility which does this in the TDSOM is the 
\series bold
property database
\series default
.
 Properties
\begin_inset Foot
status open

\begin_layout Plain Layout
Properties were known as resources in the TACO device server model
\end_layout

\end_inset

 are identified by an ascii string and the device name.
 TANGO attributes
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
attribute
\end_layout

\end_inset

 are also configured using properties
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
properties
\end_layout

\end_inset

.
 This database is also used to store device network addresses (CORBA IOR
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
IOR
\end_layout

\end_inset

's), list of classes hosted by a device server process and list of devices
 for each class in a device server process.
 The database ensure the uniqueness of device name and of alias.
 It also links device name and it list of aliases.
\end_layout

\begin_layout Standard
TANGO uses MySQL
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
MySQL
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "mysql"

\end_inset

 as its database.
 MySQL is a relational database which implements the SQL language.
 However, this is largely enough to implement all the functionalities needed
 by the TDSOM.
 The database is accessed via a classical TANGO device hosted in a device
 server.
 Therefore, client access the database via TANGO commands requested on the
 database device.
 For a good reference on MySQL refer to 
\begin_inset CommandInset citation
LatexCommand cite
key "MySQL book"

\end_inset


\end_layout

\begin_layout Section
The controlled access
\end_layout

\begin_layout Standard
Tango also provides a controlled access
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
controlled-access
\end_layout

\end_inset

 system.
 It's a simple controlled access system.
 It does not provide encrypted communication or sophisticated authentification.
 It simply defines which user (based on computer loggin authentification)
 is allowed to do which command (or write attribute) on which device and
 from which host.
 The information used to configure this controlled access feature are stored
 in the Tango database and accessed by a specific Tango device server which
 is not the classsical Tango database device server described in the previous
 section.
 Two access levels are defined:
\end_layout

\begin_layout Itemize
Everything is allowed for this user from this host
\end_layout

\begin_layout Itemize
The write-like calls on the device are forbidden and according to configuration,
 a command subset is also forbidden for this user from this host
\end_layout

\begin_layout Standard
This feature is precisely described in the chapter "Advanced features"
\end_layout

\begin_layout Section
The Application Programmers Interfaces
\end_layout

\begin_layout Subsection
Rules of the API
\end_layout

\begin_layout Standard
While it is true TANGO clients can be programmed using only the CORBA API,
 CORBA knows nothing about TANGO.
 This means client have to know all the details of retrieving IORs from
 the TANGO database, additional information to send on the wire, TANGO version
 control etc.
 These details can and should be wrapped in TANGO Application Programmer
 Interface (API).
 The API is implemented as a library in C++ and as a package in Java.
 The API is what makes TANGO clients easy to write.
 The API's consists the following basic classes :
\end_layout

\begin_layout Itemize
DeviceProxy which is a 
\emph on
proxy
\emph default
 to the real device
\end_layout

\begin_layout Itemize
DeviceData to encapsulate data send/receive from/to device via commands
\end_layout

\begin_layout Itemize
DeviceAttribute to encapsulate data send/receive from/to device via attributes
\end_layout

\begin_layout Itemize
Group which is a 
\emph on
proxy
\emph default
 to a group
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
group
\end_layout

\end_inset

 of devices
\end_layout

\begin_layout Standard
In addition to these main classes, many other classes allows a full interface
 to TANGO features.
 The following figure is a drawing of a typical client/server application
 using TANGO.
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.3cm
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename archi.eps
	width 12cm
	height 7cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.3cm
\end_inset


\end_layout

\begin_layout Standard
The database is used during server and client startup phase to establish
 connection between client and server.
\end_layout

\begin_layout Subsection
Communication between client and server using the API
\end_layout

\begin_layout Standard
With the API, it is possible to request command to be executed on a device
 or to read/write device attribute(s) using one of the two communication
 models implemented.
 These two models are:
\end_layout

\begin_layout Enumerate
The synchronous model where client waits (and is blocked) for the server
 to send the answer or until the timeout is reached
\end_layout

\begin_layout Enumerate
The asynchronous model.
 In this model, the clients send the request and immediately returns.
 It is not blocked.
 It is free to do whatever it has to do like updating a graphical user interface.
 The client has the choice to retrieve the server answer by checking if
 the reply is arrived by calling an API specific call or by requesting that
 a call-back method is executed when the client receives the server answer.
\end_layout

\begin_layout Standard
The asynchronous model is available with Tango release 3 and above.
\end_layout

\begin_layout Subsection
Tango events
\end_layout

\begin_layout Standard
On top of the two communication model previously described, TANGO offers
 an "event system"
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
event
\end_layout

\end_inset

.
 The standard TANGO communication paradigm is a synchronou/asynchronous
 two-way call.
 In this paradigm the call is initiated by the client who contacts the server.
 The server handles the client's request and sends the answer to the client
 or throws an exception which the client catches.
 This paradigm involves two calls to receive a single answer and requires
 the client to be active in initiating the request.
 If the client has a permanent interest in a value he is obliged to poll
 the server for an update in a value every time.
 This is not efficient in terms of network bandwidth nor in terms of client
 programming.
\end_layout

\begin_layout Standard
For clients who are permanently interested in values the event-driven communicat
ion paradigm is a more efficient and natural way of programming.
 In this paradigm the client registers his interest once in an event (value).
 After that the server informs the client every time the event has occurred.
 This paradigm avoids the client polling, frees it for doing other things,
 is fast and makes efficient use of the network.
\end_layout

\begin_layout Standard
Before TANGO release 8, TANGO used the CORBA OMG COS Notification Service
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Notification Service
\end_layout

\end_inset

 to generates events.
 TANGO uses the omniNotify
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
omniNotify
\end_layout

\end_inset

 implementation of the Notification service.
 omniNotify was developed in conjunction with the omniORB CORBA implementation
 also used by TANGO.
 The heart of the Notification Service is the notification daemon.
 The omniNotify daemons are the processes which receive events from device
 servers and distribute them to all clients which are subscribed.
 In order to distribute the load of the events there is one notification
 daemon per host.
 Servers send their events to the daemon on the local host.
 Clients and servers get the IOR for the host from the TANGO database.
 
\end_layout

\begin_layout Standard
The following figure is a schematic of the Tango event system for Tango
 releases before Tango 8.
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.3cm
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename event_schematic.eps
	scale 80
	BoundingBox 0bp 0bp 523bp 485bp
	clip

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.3cm
\end_inset


\end_layout

\begin_layout Standard
Starting with Tango 8, a new design of the event system has been implemented.
 This new design is based on the ZMQ
\begin_inset Index idx
status open

\begin_layout Plain Layout
ZMQ
\end_layout

\end_inset

 library.
 ZMQ is a library allowing users to create communicating system.
 It implements several well known communication pattern including the Publish/Su
bscribe
\begin_inset Index idx
status open

\begin_layout Plain Layout
Publish/Subscribe
\end_layout

\end_inset

 pattern which is the basic of the new Tango event system.
 Using this library, a separate notification service is not needed anymore
 and event communiction is available with only client and server processes
 which simplifies the overall design.
 Starting with Tango 8.1, the event propagation between devices and clients
 could be done using a multicasting
\begin_inset Index idx
status open

\begin_layout Plain Layout
multicasting
\end_layout

\end_inset

 protocol.
 The aim of this is to reduce both the network bandwidth use and the CPU
 consumption on the device server side.
 See chapter on Advanced Features to get all the details on this feature.
\end_layout

\begin_layout Standard
The following figure is a schematic of the Tango event system for Tango
 releases starting with Tango release 8.
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.3cm
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename event_schematic_zmq.eps
	scale 80
	BoundingBox 0bp 0bp 523bp 485bp
	clip

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.3cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "OneRicardo"

\end_inset


\begin_inset Graphics
	filename ../dance/Eltaita-reduc.jpg
	lyxscale 80
	scale 150

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
