%% LyX 2.1.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{book}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{4}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{array}
\usepackage{longtable}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxcode}
{\par\begin{list}{}{
\setlength{\rightmargin}{\leftmargin}
\setlength{\listparindent}{0pt}% needed for AMS classes
\raggedright
\setlength{\itemsep}{0pt}
\setlength{\parsep}{0pt}
\normalfont\ttfamily}%
 \item[]}
{\end{list}}
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
 \setlength{\leftmargin}{\labelwidth}
 \addtolength{\leftmargin}{\labelsep}
 \renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{a4wide}

\makeatother

\usepackage{babel}
\begin{document}

\chapter{The TANGO C++ Application Programmer Interface\label{cha:The-TANGO-C++}}


\section{Tango::DeviceProxy()}

The high level object which provides the client with an easy-to-use
interface to TANGO devices. DeviceProxy is a handle to the real Device
(hence the name Proxy) and is not the real Device (of course). DeviceProxy
provides interfaces to all TANGO Device interfaces. The DeviceProxy
manages timeouts, stateless connections (new DeviceProxy() nearly
always works), and reconnection if the device server is restarted.


\subsection{Constructors}


\subsubsection{DeviceProxy::DeviceProxy(string \&name, CORBA::ORB {*}orb=NULL)}

Create a DeviceProxy to a device of the specified name. The TANGO\_HOST
environment variable is used to determine which TANGO database to
connect to. The client can specify an ORB as argument if she wants
to. The constructor will connect to the TANGO database, query for
the client's network address and build a connection to the device.
If the device is defined in the TANGO database but the device server
is not running DeviceProxy will try to build a connection every time
the client tries to access the device. If the device is not defined
an exception is thrown. Example :

\input{line.tex}
\begin{lyxcode}
DeviceProxy~{*}my\_device~=~new~DeviceProxy(``my/own/device'');
\end{lyxcode}
\input{line.tex}

See appendix on device naming for all details about Tango device naming
syntax. If an alias\index{alias} name is defined for the device,
this alias name can be used to create the DeviceProxy instance.

\emph{Exception: WrongNameSyntax, ConnectionFailed}


\subsubsection{DeviceProxy::DeviceProxy(const char {*}name, CORBA::ORB {*}orb =
NULL)}

Idem previous call


\subsection{Miscellaneous methods}


\subsubsection{DeviceInfo DeviceProxy::info()}

A method which returns information on the device in a DeviceInfo structure.
Example :

\input{line.tex}
\begin{lyxcode}
cout~<\textcompwordmark{}<~\textquotedbl{}~device~info~:~\textquotedbl{}~<\textcompwordmark{}<~endl~

DeviceInfo~dev\_info~=~my\_device->info()~<\textcompwordmark{}<~endl;

cout~<\textcompwordmark{}<~\textquotedbl{}~dev\_class~\textquotedbl{}~<\textcompwordmark{}<~dev\_info.dev\_class;

cout~<\textcompwordmark{}<~\textquotedbl{}~server\_id~\textquotedbl{}~<\textcompwordmark{}<~dev\_info.server\_id;

cout~<\textcompwordmark{}<~\textquotedbl{}~server\_host~\textquotedbl{}~<\textcompwordmark{}<~dev\_info.server\_host;

cout~<\textcompwordmark{}<~\textquotedbl{}~server\_version~\textquotedbl{}~<\textcompwordmark{}<~dev\_info.server\_version;

cout~<\textcompwordmark{}<~\textquotedbl{}~doc\_url~\textquotedbl{}~<\textcompwordmark{}<~dev\_info.doc\_url;

cout~<\textcompwordmark{}<~\textquotedbl{}~device\_type~\textquotedbl{}~<\textcompwordmark{}<~dev\_info.dev\_type;
\end{lyxcode}
\input{line.tex}

All DeviceInfo fields are strings except for the server\_version server\_version
which is a long integer.

\emph{Exception: Connection Failed, CommunicationFailed, DevFailed
from device}


\subsubsection{DevState DeviceProxy::state()}

A method which return the state of the device as a Tango::DevState
type. Example :

\input{line.tex}
\begin{lyxcode}
dev\_state~=~my\_device->state()~<\textcompwordmark{}<~endl;
\end{lyxcode}
\input{line.tex}

\emph{Exception: ConnectionFailed, CommunicationFailed}


\subsubsection{string DeviceProxy::status()}

A method which return the status of the device as a string. Example
:

\input{line.tex}
\begin{lyxcode}
cout~<\textcompwordmark{}<~\textquotedbl{}device~status~\textquotedbl{}~<\textcompwordmark{}<~my\_device->status()~<\textcompwordmark{}<~endl;
\end{lyxcode}
\input{line.tex}

\emph{Exception: ConnectionFailed, CommunicationFailed}


\subsubsection{int DeviceProxy::ping()}

A method which sends a ping to the device and returns the time elapsed
as microseconds. Example :

\input{line.tex}
\begin{lyxcode}
cout~<\textcompwordmark{}<~\textquotedbl{}~device~ping~took~\textquotedbl{}~<\textcompwordmark{}<~my\_device->ping()~<\textcompwordmark{}<~\textquotedbl{}~microseconds\textquotedbl{}~<\textcompwordmark{}<~endl;
\end{lyxcode}
\input{line.tex}

\emph{Exception: ConnectionFailed, CommunicationFailed}


\subsubsection{void DeviceProxy::set\_timeout\_millis(int timeout)}

Set client side timeout for device in milliseconds. Any method which
takes longer than this time to execute will throw an exception.

\emph{Exception: none}


\subsubsection{int DeviceProxy::get\_timeout\_millis()}

Get the client side timeout in milliseconds.

\emph{Exception: none}


\subsubsection{int DeviceProxy::get\_idl\_version()}

Get the version of the Tango Device IDL interface implemented by the
device

\emph{Exception: none}


\subsubsection{void DeviceProxy::set\_source(DevSource source)}

Set the data source (device, polling buffer, polling buffer than device)
for command\_inout and read\_attribute methods. The DevSource is an
enumerated type which can be one of \{DEV, CACHE, CACHE\_DEV\}. The
default value is CACHE\_DEV. See chapter on Advanced Feature for all
details regarding polling.

\emph{Exception: none}


\subsubsection{DevSource DeviceProxy::get\_source()}

Get the device data source used by command\_inout or read\_attribute
methods. The DevSource is an enumerated type which can be one of \{DEV,
CACHE, CACHE\_DEV\}. See chapter on Advanced Feature for all details
regarding polling.

\emph{Exception: none}


\subsubsection{vector<string> {*}DeviceProxy::black\_box(int n)}

Get the last n commands executed on the device server and return a
pointer to a vector of strings containing the date, time, command,
and from which client computer the command was executed. This method
allocates memory for the vector of strings returned to the caller.
It is the caller responsibility to delete this memory.

\emph{Exception: ConnectionFailed, CommunicationFailed, DevFailed
from device}


\subsubsection{string DeviceProxy::name()}

Return the device name (from the device itself)

\emph{Exception: ConnectionFailed, CommunicationFailed}


\subsubsection{string DeviceProxy::adm\_name()}

Returns the name of the corresponding administrator device. This is
useful if you need to send an administration command to the device
server e.g. restart it.

\emph{Exception: ConnectionFailed, CommunicationFailed}


\subsubsection{string DeviceProxy::dev\_name()}

Return the device name as it is stored locally


\subsubsection{string DeviceProxy::description()}

Returns the device description as a string.

\emph{Exception: ConnectionFailed, CommunicationFailed}
\begin{lyxcode}

\end{lyxcode}

\subsubsection{DbDevImportInfo DeviceProxy::import\_info()}

Query the device for import info from the database. This method returns
a DbDevImprtInfo type. The DbDevImportInfo type is a struct defined
as follows :

\input{line.tex}
\begin{lyxcode}
class~DbDevImportInfo~\{~

public~:~

~~~~string~name;~

~~~~long~exported;~

~~~~string~ior;~

~~~~string~version;~\};~
\end{lyxcode}
\input{line.tex}

\emph{Exception: NonDbDevice}


\subsubsection{void DeviceProxy::set\_transparency\_reconnection(bool flag)}

If flag is true, no exception will be thrown in case of network communication
error between client and server. The API will try to re-build the
network connection between client and server as soon as an error is
detected. See \ref{sec:Reconnection-and-exception} more more details
on reconnection and exception


\subsubsection{bool DeviceProxy::get\_transparency\_reconnection()}

Returns the transparency reconnection flag.


\subsubsection{string DeviceProxy::alias()}

Returns the device alias name if one is defined otherwise, throws
a DevFailed exception with the reason field set to Db\_AliasNotDefined.


\subsubsection{AccessControlType DeviceProxy::get\_access\_right()}

Returns the device access right. AccessControlType is one enumeration
with 2 values which are ACCESS\_READ and ACCESS\_WRITE. In case the
Tango Access Control systemis not used, ACCESS\_WRITE is returned.


\subsection{Synchronous command oriented methods}


\subsubsection{CommandInfo DeviceProxy::command\_query(string command)}

Query the device for information about a single command. This command
returns a single CommandInfo type. The CommandInfo type is a struct
described in command\_list\_query().

\emph{Exception: ConnectionFailed, CommunicationFailed, DevFailed
from device}


\subsubsection{CommandInfoList {*}DeviceProxy::command\_list\_query()}

Query the device for info on all commands. This method returns a vector
of CommandInfo types. This method allocates memory for the vector
of CommandInfo returned to the caller. It is the caller responsibility
to delete this memory. The CommandInfo type is a struct defined as
follows :

\input{line.tex}
\begin{lyxcode}
typedef~\_CommandInfo

\{

~~~~string~~~~~~~~~~~cmd\_name;~~~~~~/{*}~command~name~as~ascii~string~{*}/

~~~~long~~~~~~~~~~~~~cmd\_tag;~~~~~~~/{*}~command~as~binary~value~(for~TACO)~{*}/

~~~~long~~~~~~~~~~~~~in\_type;~~~~~~~/{*}~in~type~as~binary~value~{*}/

~~~~long~~~~~~~~~~~~~out\_type;~~~~~~/{*}~out~type~as~binary~value~{*}/

~~~~string~~~~~~~~~~~in\_type\_desc;~~/{*}~description~of~in~type~(optional)~{*}/

~~~~string~~~~~~~~~~~out\_type\_desc;~/{*}~description~of~out~type~(optional)~{*}/

~~~~Tango::DispLevel~disp\_level;~~~~/{*}~Command~display~level~{*}/

\}~CommandInfo;

typedef~CommandInfoList~vector<CommandInfo>;
\end{lyxcode}
\input{line.tex}

\emph{Exception:} \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device}


\subsubsection{DeviceData DeviceProxy::command\_inout(string)}

Execute a command on a device which takes no input arguments (void).
The result is returned in a DeviceData object (cf. below how to insert
and extract data from DeviceData).

\emph{Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked,
DevFailed from device}


\subsubsection{DeviceData DeviceProxy::command\_inout(const char {*})}

Idem previous call


\subsubsection{DeviceData Deviceproxy::command\_inout(string, DeviceData \&)}

Execute a command on a device. Input arguments are passed in a DeviceData
object, output is returned as a DeviceData object (see below on how
to insert and extract data from DeviceData).

\emph{Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked,
DevFailed from device}


\subsubsection{DeviceData DeviceProxy::command\_inout(const char {*}, DeviceData
\&)}

Idem previous call


\subsubsection{vector<DeviceDataHistory> {*}command\_history(string \&, int)}

Retrieve command history from the command polling buffer. The first
argument is the command name. The second argument is the wanted history
depth. This method returns a vector of DeviceDataHistory types. This
method allocates memory for the vector of DeviceDataHistory returned
to the caller. It is the caller responsibility to delete this memory.
Class DeviceDataHistory is detailed on chapter \ref{DataHistory}.
See chapter on Advanced Feature for all details regarding polling.

\input{line.tex}
\begin{lyxcode}
\noindent DeviceProxy~dev~=~new~DeviceProxy(\textquotedbl{}...\textquotedbl{});~

vector<DeviceDataHistory>~{*}hist;

hist~=~dev->command\_history(\textquotedbl{}Status\textquotedbl{},5);

\noindent for~(int~i~=~0;i~<~5;i++)~

\noindent \{

\noindent 

~~~~bool~fail~=~({*}hist){[}i{]}.failed();

~~~~if~(fail~==~false)

~~~~\{

~~~~~~~~string~str;

~~~~~~~~({*}hist){[}i{]}~>\textcompwordmark{}>~str;

~~~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Status~=~\textquotedbl{}~<\textcompwordmark{}<~str~<\textcompwordmark{}<~endl;

~~~~\}

~~~~else

~~~~\{

~~~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Command~failed~!\textquotedbl{}~<\textcompwordmark{}<~endl;

~~~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Error~level~0~desc~=~\textquotedbl{}~<\textcompwordmark{}<~(({*}hist){[}i{]}.errors()){[}0{]}.desc~<\textcompwordmark{}<~endl;

~~~~\}

~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Date~=~\textquotedbl{}~<\textcompwordmark{}<~({*}hist){[}i{]}.date().tv\_sec~<\textcompwordmark{}<~endl;

\noindent \}

delete~hist;
\end{lyxcode}
\input{line.tex}

\emph{Exception:} \emph{NonSupportedFeature, ConnectionFailed, CommunicationFailed,
DevFailed from device}


\subsubsection{DeviceDataHistoryList {*}command\_history(const char {*}, int)}

Idem previous call


\subsection{Synchronous attribute related methods}


\subsubsection{Compatibility between Tango release 4 and release 5 regarding attribute
properties}

Between Tango V4 and Tango V5, attribute configuration has been modified
to incorporate alarm and event related parameters. This explains why
it exists two structure types for attribute configuration parameters.
All Tango V4 parameters are defined in a structure called \textbf{AttributeInfo\index{AttributeInfo}}
and a new structure called \textbf{AttributeInfoEx}\index{AttributeInfoEx}
has been defined for all Tango V5 parameters. Nevertheless, AttributeInfoEx
inherits from AttributeInfo and it is always possible to call the
Tango V5 \emph{DeviceProxy::attribute\_query()} method and to store
its result in one AttributeInfo structure thus allowing compatibility\index{compatibility}
for client written for Tango V4 but linked with Tango V5. It is also
possible for a client written and linked with Tango V5 to call Tango
V5 \emph{DeviceProxy::attribute\_query()} method to all kind of Tango
devices. For device using Tango V4, the alarm and event related parameters
will be retrieved from the database instead of from the device.


\subsubsection{AttributeInfoEx DeviceProxy::attribute\_query(string attribute)}

Query the device for information about a single attribute. This command
returns a single AttributeInfoEx type which inherits from the AttributeInfo
type. The AttributeInfoEx and AttributeInfo types are structures described
in get\_attribute\_config() and get\_attribute\_config\_ex().

\emph{Exception: ConnectionFailed, CommunicationFailed, DevFailed
from device}


\subsubsection{AttributeInfoList {*} DeviceProxy::attribute\_list\_query()}

Query the device for info on all attributes. This method returns a
vector of AttributeInfo types. The AttributeInfo type is a structure
described in get\_attribute\_config(). This method allocates memory
for the vector of AttributeInfo structures returned to the caller.
It is the caller responsibility to delete this memory.


\subsubsection{AttributeInfoListEx {*} DeviceProxy::attribute\_list\_query\_ex()}

Query the device for info on all attributes. This method returns a
vector of AttributeInfoEx types. The AttributeInfoEx type is a structure
described in get\_attribute\_config\_ex(). This method allocates memory
for the vector of AttributeInfoEx structures returned to the caller.
It is the caller responsibility to delete this memory.


\subsubsection{vector<string> {*}DeviceProxy::get\_attribute\_list()}

Return the names of all attributes implemented for this device as
a vector of strings. This method allocates memory for the vector of
strings returned to the caller. It is the caller responsibility to
delete this memory.

\emph{Exception: ConnectionFailed, CommunicationFailed, DevFailed
from device}


\subsubsection{AttributeInfoList {*}DeviceProxy::get\_attribute\_config(vector<string>\&)}

Return the attribute configuration for the list of specified attributes.
To get all the attributes pass a vector containing the string AllAttr
(defined in tango\_const.h). This method allocates memory for the
vector of AttributeInfo returned to the caller. It is the caller responsibility
to delete this memory. AttributeInfo is a struct defined as follows
:

\input{line.tex}
\begin{lyxcode}
typedef~struct~\_AttributeInfo

\{~

~~~string~~~~~~~~~~~~~name;~

~~~AttrWriteType~~~~~~writable;~

~~~AttrDataFormat~~~~~data\_format;~

~~~int~~~~~~~~~~~~~~~~data\_type;~

~~~int~~~~~~~~~~~~~~~~max\_dim\_x;~

~~~int~~~~~~~~~~~~~~~~max\_dim\_y;~

~~~string~~~~~~~~~~~~~description;~

~~~string~~~~~~~~~~~~~label;~

~~~string~~~~~~~~~~~~~unit;~

~~~string~~~~~~~~~~~~~standard\_unit;~

~~~string~~~~~~~~~~~~~display\_unit;~

~~~string~~~~~~~~~~~~~format;~

~~~string~~~~~~~~~~~~~min\_value;~

~~~string~~~~~~~~~~~~~max\_value;~

~~~string~~~~~~~~~~~~~min\_alarm;~

~~~string~~~~~~~~~~~~~max\_alarm;~

~~~string~~~~~~~~~~~~~writable\_attr\_name;~

~~~vector<string>~~~~~extensions;~

~~~Tango::DispLevel~~~disp\_level;

\}~AttributeInfo;~
\end{lyxcode}
\input{line.tex}

\emph{Exception: ConnectionFailed, CommunicationFailed, DevFailed
from device}


\subsubsection{AttributeInfoListEx {*}DeviceProxy::get\_attribute\_config\_ex(vector<string>\&)}

Return the extended attribute configuration for the list of specified
attributes. To get all the attributes pass a vector containing the
string AllAttr (defined in tango\_const.h). This method allocates
memory for the vector of AttributeInfoEx returned to the caller. It
is the caller responsibility to delete this memory. AttributeInfoEx
is a structure defined as follows :

\input{line.tex}
\begin{lyxcode}
struct~AttributeInfoEx:~public~AttributeInfo

\{~

~~~AttributeAlarmInfo~alarms;~

~~~AttributeEventInfo~events;

~~~vector<string>~~~~~sys\_extensions;~

\};

\noindent ~

struct~AttributeAlarmInfo

\{

~~~string~~~~~~~~~~~min\_alarm;

~~~string~~~~~~~~~~~max\_alarm;

~~~string~~~~~~~~~~~min\_warning;

~~~string~~~~~~~~~~~max\_warning;

~~~string~~~~~~~~~~~delta\_t;

~~~string~~~~~~~~~~~delta\_val;

~~~vector<string>~~~extensions;

\};

\noindent ~

struct~AttributeEventInfo

\{

~~~ChangeEventInfo~~~~~ch\_event;

~~~PeriodicEventInfo~~~per\_event;

~~~ArchiveEventInfo~~~~arch\_event;

\};

\noindent ~

struct~ChangeEventInfo

\{

~~~string~~~~~~~~~~~rel\_change;

~~~string~~~~~~~~~~~abs\_change;

~~~vector<string>~~~extensions;

\};

\noindent ~

struct~PeriodicEventInfo

\{

~~~string~~~~~~~~~~~period;

~~~vector<string>~~~extensions;

\};

\noindent ~

struct~ArchiveEventInfo

\{

~~~string~~~~~~~~~~~archive\_rel\_change;

~~~string~~~~~~~~~~~archive\_abs\_change;

~~~string~~~~~~~~~~~archive\_period;

~~~vector<string>~~~extensions;

\};
\end{lyxcode}
\input{line.tex}

\emph{Exception: ConnectionFailed, CommunicationFailed, DevFailed
from device}


\subsubsection{AttributeInfoEx DeviceProxy::get\_attribute\_config(string\&)}

Return the attribute configuration for a single attributes. The AttributeInfoEx
is a structure defined above.

\emph{Exception: ConnectionFailed, CommunicationFailed, DevFailed
from device}


\subsubsection{void DeviceProxy::set\_attribute\_config(AttributeInfoList \&)}

Change the attribute configuration for the specified attributes.

\emph{Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked,
DevFailed from device}


\subsubsection{void DeviceProxy::set\_attribute\_config(AttributeInfoListEx \&)}

Change the attribute configuration for the specified attributes.

\emph{Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked,
DevFailed from device}


\subsubsection{vector<DeviceAttribute> {*}DeviceProxy::read\_attributes(vector<string>\&)}

Read the list of specified attributes. To extract the value you have
to use the operator of the class DeviceAttribute which corresponds
to the data type of the attribute. NOTE: There is no automatic type
conversion from the attribute native type to user type e.g. if an
attribute returns a short you cannot extract it as a double, you have
to extract it as a short. By default, if the server reports error
for one of the attribute in the list, this error will be passed to
the user using exception when he (she) will try to extract the data
form the corresponding See sub-chapter on DeviceAttribute to learn
how to change this default behaviour. DeviceAttribute object. This
method allocates memory for the vector of DeviceAttribute objects
returned to the caller. This is the caller responsibility to delete
this memory. Example :

\input{line.tex}
\begin{lyxcode}
vector<DeviceAttribute>~{*}devattr;

vector<string>~attr\_names;

~

attr\_names.push\_back(\textquotedbl{}attribute\_1\textquotedbl{});

attr\_names.push\_back(\textquotedbl{}attribute\_2\textquotedbl{});



devattr~=~device->read\_attributes(attr\_names);



short~short\_attr\_1;

long~long\_attr\_2;

({*}devattr){[}0{]}~>\textcompwordmark{}>~short\_attr\_1;

({*}devattr){[}1{]}~>\textcompwordmark{}>~long\_attr\_2;

cout~<\textcompwordmark{}<~\textquotedbl{}my\_attribute~value~\textquotedbl{}~<\textcompwordmark{}<~short\_attr;



delete~devattr;
\end{lyxcode}
\input{line.tex}

\emph{Exception: ConnectionFailed, CommunicationFailed}


\subsubsection{DeviceAttribute DeviceProxy::read\_attribute(string\&)}

Read a single attribute. To extract the value you have to use the
operator of the class DeviceAttribute which corresponds to the data
type of the attribute. NOTE: There is no automatic type conversion
from the attribute native type to user type e.g. if an attribute returns
a short you cannot extract it as a double (this will return 0) you
have to extract it as a short. See example above.

\emph{Exception: ConnectionFailed, CommunicationFailed}


\subsubsection{DeviceAttribute DeviceProxy::read\_attribute(const char {*})}

Idem previous call


\subsubsection{void DeviceProxy::write\_attributes(vector<DeviceAttribute>\&)}

Write the specified attributes. To insert the values to write you
have to use the operator of the DeviceAttribute class which corresponds
to the data type of the attribute. NOTE: There is no automatic type
conversion from the user type to the attribute native type e.g. if
an attribute expects a short you cannot insert it as a double (this
will throw an exception) you have to insert it as a short. Note that
this is the only API call which could throw a NamedDevFailedList exception.
See \ref{sub:The-NamedDevFailedList-exception} to get all the details
on this exception. Example :

\input{line.tex}
\begin{lyxcode}
vector<DeviceAttribute>~attr\_in;

string~att1\_name(\textquotedbl{}First\_attr\textquotedbl{});

string~att2\_name(\textquotedbl{}Second\_attr\textquotedbl{});

short~short\_attr;

double~double\_attr;~attr\_in.push\_back(DeviceAttribute(att1\_name,short\_attr));

attr\_in.push\_back(DeviceAttribute(att2\_name,double\_attr));

device->write\_attributes(attr\_in);


\end{lyxcode}
\input{line.tex}
\begin{lyxcode}

\end{lyxcode}
\emph{Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked,
DevFailed or NamedDevFailedList\index{NamedDevFailedList} from device}


\subsubsection{void DeviceProxy::write\_attribute(DeviceAttribute\&)}

Write a single attribute. To insert the value to write you have to
use the operator of the class DeviceAttribute which corresponds to
the data type of the attribute. NOTE: There is no automatic type conversion
from the user type to the attribute native type e.g. if an attribute
expects a short you cannot insert it as a double (this will throw
an exception) you have to insert it as a short. See example above.

\emph{Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked,
DevFailed from device}


\subsubsection{DeviceAttribute DeviceProxy::write\_read\_attribute(DeviceAttribute\&)}

Write then read a single attribute in a single network call. By default
(serialisation by device), the execution of this call in the server
can't be interrupted by other clients. To insert/extract the value
to write/read you have to use the operator of the class DeviceAttribute
which corresponds to the data type of the attribute. NOTE: There is
no automatic type conversion from the user type to the attribute native
type e.g. if an attribute expects a short you cannot insert it as
a double (this will throw an exception) you have to insert it as a
short.

\emph{Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked,
DevFailed from device}


\subsubsection{vector<DeviceAttributeHistory> {*}DeviceProxy::attribute\_history(string
\&, int)}

Retrieve attribute history from the attribute polling buffer. The
first argument is the attribute name. The second argument is the wanted
history depth. This method returns a vector of DeviceAttributeHistory
types. This method allocates memory for the vector of DeviceAttributeHistory
returned to the caller. It is the caller responsibility to delete
this memory. Class DeviceAttributeHistory is detailed on chapter \ref{AttributeHistory}See
also chapter on Advanced Feature for all details regarding polling.

\input{line.tex}
\begin{lyxcode}
\noindent DeviceProxy~dev~=~new~DeviceProxy(\textquotedbl{}...\textquotedbl{});~

vector<DeviceAttributeHistory>~{*}hist;

hist~=~dev->attribute\_history(\textquotedbl{}Current\textquotedbl{},5);

\noindent for~(int~i~=~0;i~<~5;i++)~

\noindent \{

\noindent 

~~~~bool~fail~=~({*}hist){[}i{]}.has\_failed();

~~~~if~(fail~==~false)

~~~~\{

~~~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Attribute~name~=~\textquotedbl{}~<\textcompwordmark{}<~({*}hist){[}i{]}.get\_name()~<\textcompwordmark{}<~endl;

~~~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Attribute~quality~factor~=~\textquotedbl{}~<\textcompwordmark{}<~({*}hist){[}i{]}.get\_quality()~<\textcompwordmark{}<~endl;

~~~~~~~~long~value;

~~~~~~~~({*}hist){[}i{]}~>\textcompwordmark{}>~value;

~~~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Current~=~\textquotedbl{}~<\textcompwordmark{}<~value~<\textcompwordmark{}<~endl;

~~~~\}

~~~~else

~~~~\{

~~~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Attribute~failed~!\textquotedbl{}~<\textcompwordmark{}<~endl;

~~~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Error~level~0~desc~=~\textquotedbl{}~<\textcompwordmark{}<~(({*}hist){[}i{]}.get\_err\_stack()){[}0{]}.desc~<\textcompwordmark{}<~endl;

~~~~\}

~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Date~=~\textquotedbl{}~<\textcompwordmark{}<~({*}hist){[}i{]}.get\_date().tv\_sec~<\textcompwordmark{}<~endl;

\noindent \}

delete~hist;
\end{lyxcode}
\input{line.tex}

\emph{Exception:} \emph{NonSupportedFeature, ConnectionFailed, CommunicationFailed,
DevFailed from device}


\subsubsection{vector<DeviceAttributeHistory> {*}DeviceProxy::attribute\_history(const
char {*}, int)}

Idem previous call


\subsection{Asynchronous command oriented methods}


\subsubsection{long DeviceProxy::command\_inout\_asynch(string \&name, bool forget)}

Execute asynchronously (polling model) a command on a device which
takes no input argument. The last argument is a \emph{fire and forget}
flag. If this flag is set to true, this means that the client does
not care at all about the server answer and will even not try to get
it. A false default value is provided. Please, note that device re-connection
will not take place (in case it is needed) if the fire and forget
mode is used. Therefore, an application using only fire and forget
requests is not able to automatically re-connnect to device. This
call returns an \emph{asynchronous call identifier} which is needed
to get the command result.

\emph{Exception: ConnectionFailed}


\subsubsection{long DeviceProxy::command\_inout\_asynch(const char {*}name, bool
forget)}

Idem previous call


\subsubsection{long DeviceProxy::command\_inout\_asynch(string \&name, DeviceData
\&argin, bool forget)}

Execute asynchronously (polling model) a command on a device. Input
arguments are passed in a DeviceData object (see following chapters
on how to insert data into DeviceData object). The last argument is
a \emph{fire and forget} flag. If this flag is set to true, this means
that the client does not care at all about the server answer and will
even not try to get it. A false default value is provided. Please,
note that device re-connection will not take place (in case it is
needed) if the fire and forget mode is used. Therefore, an application
using only fire and forget requests is not able to automatically re-connnect
to device. This call returns an \emph{asynchronous call identifier}
which is needed to get the command result.

\emph{Exception: ConnectionFailed}


\subsubsection{long DeviceProxy::command\_inout\_asynch(const char {*}name, Devicedata
\&argin, bool forget)}

Idem previous call


\subsubsection{DeviceData DeviceProxy::command\_inout\_reply(long id)}

Check if the answer of an asynchronous command\_inout is arrived (polling
model). id is the asynchronous call identifier. If the reply is arrived
and if it is a valid reply, it is returned to the caller in a DeviceData
object. If the reply is an exception, it is re-thrown by this call.
An exception is also thrown in case of the reply is not yet arrived.
Example :

\input{line.tex}
\begin{lyxcode}
~~~~~~~~Tango::DeviceProxy~dev(\textquotedbl{}...\textquotedbl{});

~~~~~~~~long~asyn\_id;

~~~~~~~~asyn\_id~=~dev.command\_inout\_asynch(\textquotedbl{}MyCmd\textquotedbl{});

~~~~~~~~...

~~~~~~~~...

~~~~~~~~...

~~~~~~~~Tango::DeviceData~arg;

~~~~~~~~try

~~~~~~~~\{

~~~~~~~~~~~~~~~~arg~=~dev.command\_inout\_reply(asyn\_id);

~~~~~~~~\}

~~~~~~~~catch(Tango::AsynReplyNotArrived)

~~~~~~~~\{

~~~~~~~~~~~~~~~~cerr~<\textcompwordmark{}<~\textquotedbl{}Command~not~arrived~!\textquotedbl{}~<\textcompwordmark{}<~endl;

~~~~~~~~\}

~~~~~~~~catch~(Tango::DevFailed~\&e)

~~~~~~~~\{

~~~~~~~~~~~~~~~~Tango::Except::print\_exception(e);

~~~~~~~~\}~


\end{lyxcode}
\input{line.tex}

\emph{Exception: AsynCall, AsynReplyNotArrived, CommunicationFailed,
DevFailed from device}


\subsubsection{DeviceData DeviceProxy::command\_inout\_reply(long id, long timeout)}

Check if the answer of an asynchronous command\_inout is arrived (polling
model). id is the asynchronous call identifier. If the reply is arrived
and if it is a valid reply, it is returned to the caller in a DeviceData
object. If the reply is an exception, it is re-thrown by this call.
If the reply is not yet arrived, the call will wait (blocking the
process) for the time specified in timeout. If after timeout milliseconds,
the reply is still not there, an exception is thrown. If timeout is
set to 0, the call waits until the reply arrived.

\emph{Exception: AsynCall, AsynReplyNotArrived, CommunicationFailed,
DevFailed from device}


\subsubsection{void DeviceProxy::command\_inout\_asynch(string \&name, CallBack
\&cb)}

Execute asynchronously (callback model) a command on a device which
takes no input argument. The last argument is a reference to a callback
object. This callback object should be an instance of a user class
inheriting from the \emph{Tango::CallBack} class with the \emph{cmd\_ended()}
method overloaded.

\emph{Exception: ConnectionFailed}


\subsubsection{void DeviceProxy::command\_inout\_asynch(const char {*}name, CallBack
\&cb)}

Idem previous call


\subsubsection{void DeviceProxy::command\_inout\_asynch(string \&name, DeviceData
\&argin, CallBack \&cb)}

Execute asynchronously (callback model) a command on a device. Input
arguments are passed in a DeviceData object (see following chapters
on how to insert data into DeviceData object). The last argument is
a reference to a callback object. This callback object should be an
instance of a user class inheriting from the \emph{Tango::CallBack}
class with the \emph{cmd\_ended()} method overloaded.

\emph{Exception: ConnectionFailed}


\subsubsection{void DeviceProxy::command\_inout\_asynch(const char {*}name, DeviceData
\&argin, Callback \&cb)}

Idem previous call
\begin{lyxcode}

\end{lyxcode}

\subsection{Asynchronous attribute related methods}


\subsubsection{long DeviceProxy::read\_attribute\_asynch(string \&name)}

Read asynchronously (polling model) a single attribute. This call
returns an \emph{asynchronous call identifier} which is needed to
get the attribute value.

\emph{Exception: ConnectionFailed}


\subsubsection{long DeviceProxy::read\_attribute\_asynch(const char {*}name)}

Idem previous call


\subsubsection{long DeviceProxy::read\_attributes\_asynch(vector<string> \&names)}

Read asynchronously (polling model) the list of specified attributes.
This call returns an \emph{asynchronous call identifier} which is
needed to get attributes value.

\emph{Exception: ConnectionFailed}


\subsubsection{DeviceAttribute {*}DeviceProxy::read\_attribute\_reply(long id)}

Check if the answer of an asynchronous read\_attribute is arrived
(polling model). id is the asynchronous call identifier. If the reply
is arrived and if it is a valid reply, it is returned to the caller
in a DeviceAttribute object. If the reply is an exception, it is re-thrown
by this call. An exception is also thrown in case of the reply is
not yet arrived. To extract attribute value, you have to use the operator
of the class DeviceAttribute which corresponds to the data type of
the attribute. NOTE: There is no automatic type conversion from the
attribute native type to user type e.g. if an attribute returns a
short you cannot extract it as a double, you have to extract it as
a short. Memory has been allocated for the DeviceAttribute object
returned to the caller. This is the caller responsibility to delete
this memory.

\emph{Exception:} \emph{AsynCall, AsynReplyNotArrived, CommunicationFailed,
DevFailed from device}


\subsubsection{DeviceAttribute {*}DeviceProxy::read\_attribute\_reply(long id, long
timeout)}

Check if the answer of an asynchronous read\_attribute is arrived
(polling model). id is the asynchronous call identifier. If the reply
is arrived and if it is a valid reply, it is returned to the caller
in a DeviceAttribute object. If the reply is an exception, it is re-thrown
by this call. If the reply is not yet arrived, the call will wait
(blocking the process) for the time specified in timeout. If after
timeout milliseconds, the reply is still not there, an exception is
thrown. If timeout is set to 0, the call waits until the reply arrived.
To extract attribute value, you have to use the operator of the class
DeviceAttribute which corresponds to the data type of the attribute.
NOTE: There is no automatic type conversion from the attribute native
type to user type e.g. if an attribute returns a short you cannot
extract it as a double, you have to extract it as a short. Memory
has been allocated for the DeviceAttribute object returned to the
caller. This is the caller responsibility to delete this memory.

\emph{Exception:} \emph{AsynCall, AsynReplyNotArrived, CommunicationFailed,
DevFailed from device}


\subsubsection{vector<DeviceAttribute> {*}DeviceProxy::read\_attributes\_reply(long
id)}

Check if the answer of an asynchronous read\_attributes is arrived
(polling model). id is the asynchronous call identifier. If the reply
is arrived and if it is a valid reply, it is returned to the caller
in a vector<DeviceAttribute>. If the reply is an exception, it is
re-thrown by this call. An exception is also thrown in case of the
reply is not yet arrived. To extract attribute value, you have to
use the operator of the class DeviceAttribute which corresponds to
the data type of the attribute. NOTE: There is no automatic type conversion
from the attribute native type to user type e.g. if an attribute returns
a short you cannot extract it as a double, you have to extract it
as a short. Memory has been allocated for the vector<DeviceAttribute>
object returned to the caller. This is the caller responsibility to
delete this memory.

\emph{Exception:} \emph{AsynCall, AsynReplyNotArrived, CommunicationFailed,
DevFailed from device}


\subsubsection{vector<DeviceAttribute> {*}DeviceProxy::read\_attributes\_reply(long
id, long timeout)}

Check if the answer of an asynchronous read\_attributes is arrived
(polling model). id is the asynchronous call identifier. If the reply
is arrived and if it is a valid reply, it is returned to the caller
in a vector<DeviceAttribute>. If the reply is an exception, it is
re-thrown by this call. If the reply is not yet arrived, the call
will wait (blocking the process) for the time specified in timeout.
If after timeout milliseconds, the reply is still not there, an exception
is thrown. If timeout is set to 0, the call waits until the reply
arrived. To extract attribute value, you have to use the operator
of the class DeviceAttribute which corresponds to the data type of
the attribute. NOTE: There is no automatic type conversion from the
attribute native type to user type e.g. if an attribute returns a
short you cannot extract it as a double, you have to extract it as
a short. Memory has been allocated for the vector<DeviceAttribute>
object returned to the caller. This is the caller responsibility to
delete this memory.

\emph{Exception:} \emph{AsynCall, AsynReplyNotArrived, CommunicationFailed,
DevFailed from device}


\subsubsection{long DeviceProxy::write\_attribute\_asynch(DeviceAttribute \&argin)}

Write asynchronously (polling model) a single attribute. To insert
the value to write you have to use the operator of the class DeviceAttribute
which corresponds to the data type of the attribute. NOTE: There is
no automatic type conversion from the user type to the attribute native
type e.g. if an attribute expects a short you cannot insert it as
a double (this will throw an exception) you have to insert it as a
short. This call returns an \emph{asynchronous call identifier} which
is needed to get the server reply.

\emph{Exception:} \emph{ConnectionFailed}


\subsubsection{long DeviceProxy::write\_attributes\_asynch(vector<DeviceAttribute>
\&argin)}

Write asynchronously (polling model) the specified attributes. To
insert the value to write you have to use the operator of the class
DeviceAttribute which corresponds to the data type of the attribute.
NOTE: There is no automatic type conversion from the user type to
the attribute native type e.g. if an attribute expects a short you
cannot insert it as a double (this will throw an exception) you have
to insert it as a short. This call returns an \emph{asynchronous call
identifier} which is needed to get the server reply.

\emph{Exception:} \emph{ConnectionFailed}


\subsubsection{void DeviceProxy::write\_attribute\_reply(long id)}

Check if the answer of an asynchronous write\_attribute is arrived
(polling model). id is the asynchronous call identifier. If the reply
is arrived and if it is a valid reply, the call returned. If the reply
is an exception, it is re-thrown by this call. An exception is also
thrown in case of the reply is not yet arrived.

\emph{Exception:} \emph{AsynCall, AsynReplyNotArrived, CommunicationFailed,
DevFailed from device}


\subsubsection{void DeviceProxy::write\_attribute\_reply(long id, long timeout)}

Check if the answer of an asynchronous write\_attribute is arrived
(polling model). id is the asynchronous call identifier. If the reply
is arrived and if it is a valid reply, the call returned. If the reply
is an exception, it is re-thrown by this call. If the reply is not
yet arrived, the call will wait (blocking the process) for the time
specified in timeout. If after timeout milliseconds, the reply is
still not there, an exception is thrown. If timeout is set to 0, the
call waits until the reply arrived.

\emph{Exception:} \emph{AsynCall, AsynReplyNotArrived, CommunicationFailed,
DevFailed from device}


\subsubsection{void DeviceProxy::write\_attributes\_reply(long id)}

Check if the answer of an asynchronous write\_attributes is arrived
(polling model). id is the asynchronous call identifier. If the reply
is arrived and if it is a valid reply, the call returned. If the reply
is an exception, it is re-thrown by this call. An exception is also
thrown in case of the reply is not yet arrived.

\emph{Exception:} \emph{AsynCall, AsynReplyNotArrived, CommunicationFailed,
DevFailed from device}


\subsubsection{void DeviceProxy::write\_attributes\_reply(long id, long timeout)}

Check if the answer of an asynchronous write\_attributes is arrived
(polling model). id is the asynchronous call identifier. If the reply
is arrived and if it is a valid reply, the call returned. If the reply
is an exception, it is re-thrown by this call. If the reply is not
yet arrived, the call will wait (blocking the process) for the time
specified in timeout. If after timeout milliseconds, the reply is
still not there, an exception is thrown. If timeout is set to 0, the
call waits until the reply arrived.

\emph{Exception:} \emph{AsynCall, AsynReplyNotArrived, CommunicationFailed,
DevFailed from device}


\subsubsection{void DeviceProxy::read\_attribute\_asynch(string \&name, CallBack
\&cb)}

Read asynchronously (callback model) a single attribute. The last
argument is a reference to a callback object. This callback object
should be an instance of a user class inheriting from the \emph{Tango::CallBack}
class with the \emph{attr\_read()} method overloaded.

\emph{Exception:} \emph{ConnectionFailed}


\subsubsection{void DeviceProxy::read\_attribute\_asynch(const char {*}name, CallBack
\&cb)}

Idem previous call


\subsubsection{void DeviceProxy::read\_attributes\_asynch(vector<string> \&names,
CallBack \&cb)}

Read asynchronously (callback model) an attribute list. The last argument
is a reference to a callback object. This callback object should be
an instance of a user class inheriting from the \emph{Tango::CallBack}
class with the \emph{attr\_read()} method overloaded.

\emph{Exception:} \emph{ConnectionFailed}


\subsubsection{void DeviceProxy::write\_attribute\_asynch(DeviceAttribute \&argin,
CallBack \&cb)}

Write asynchronously (callback model) a single attribute. The last
argument is a reference to a callback object. This callback object
should be an instance of a user class inheriting from the \emph{Tango::CallBack}
class with the \emph{attr\_written()} method overloaded.

\emph{Exception:} \emph{ConnectionFailed}


\subsubsection{void DeviceProxy::write\_attributes\_asynch(vector<DeviceAttribute>
\&argin, CallBack \&cb)}

Write asynchronously (callback model) an attribute list. The last
argument is a reference to a callback object. This callback object
should be an instance of a user class inheriting from the \emph{Tango::CallBack}
class with the \emph{attr\_written()} method overloaded.

\emph{Exception:} \emph{ConnectionFailed}


\subsection{Miscellaneous asynchronous related methods}


\subsubsection{long DeviceProxy::pending\_asynch\_call(asyn\_req\_type req)}

Return number of device asynchronous pending requests. The input parameter
is an enumeration with three values which are:
\begin{lyxlist}{00.00.0000}
\item [{POLLING}] : Returns only device polling model asynchronous request
number
\item [{CALLBACK}] : Returns only device callback model asynchronous request
number
\item [{ALL\_ASYNCH}] : Returns device asynchronous request number
\end{lyxlist}
\emph{Exception: None}


\subsubsection{void DeviceProxy::get\_asynch\_replies()}

Fire callback methods for device asynchronous requests with already
arrived replied. Returns immediately if there is no replies already
arrived or if there is no asynchronous request for the device. Example
:

\input{line.tex}
\begin{lyxcode}
class~MyCallBack:~Tango::CallBack

\{

public:

~~~MyCallback(double~d):data(d)~\{\};

~~~virtual~void~cmd\_ended(Tango::CmdDoneEvent~{*});~\\


private:

~~~double~data;

\};~\\
~\\


void~MyCallBack::cmd\_ended(Tango~CmdDoneEvent~{*}cmd)

\{

~~~if~(cmd->err~==~true)

~~~~~~Tango::Except::print\_error\_stack(cmd->errors);

~~~else

~~~\{

~~~~~~short~cmd\_result;

~~~~~~cmd->argout~>\textcompwordmark{}>~cmd\_result;

~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Command~result~=~\textquotedbl{}~<\textcompwordmark{}<~cmd\_result~<\textcompwordmark{}<~endl;

~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Callback~personal~data~=~\textquotedbl{}~<\textcompwordmark{}<~data~<\textcompwordmark{}<~endl;

~~~\}

\}~\\
~\\


int~main(int~argc,~char~{*}argv{[}{]})

\{

~~~....

~~~....~

~~~Tango::DeviceProxy~dev(\textquotedbl{}...\textquotedbl{});

~~~double~my\_data~=~...;

~~~MyCallBack~cb(my\_data);~\\


~~~dev.command\_inout\_asynch(\textquotedbl{}MyCmd\textquotedbl{},cb);

~~~...

~~~...

~~~...

~~~dev.get\_asynch\_replies();

~~~...

~~~...

\}
\end{lyxcode}
\input{line.tex}

\emph{Exception: None, all errors are reported using the err and errors
fields of the parameter passed to the callback method. See chapter
\ref{sec:Asynchronous-callback-related} for details.}


\subsubsection{void DeviceProxy::get\_asynch\_replies(long timeout)}

Fire callback methods for device asynchronous requests (command and
attributes) with already arrived replied. Wait and block the caller
for timeout milliseconds if they are some device asynchronous requests
which are not yet arrived. Returns immediately if there is no asynchronous
request for the device. If timeout is set to 0, the call waits until
all the asynchronous requests sent to the device has received a reply.

\emph{Exception: AsynReplyNotArrived. All other errors are reported
using the err and errors fields of the object passed to the callback
methods. See chapter \ref{sec:Asynchronous-callback-related} for
details.}


\subsubsection{void DeviceProxy::cancel\_asynch\_request(long id)}

Cancel a pending asynchronous request. id is the asynchronous call
identifier. This is a call local to the client. It simply allows the
caller not to get the answer of the asynchronous request. It does
not interrupt the call execution on the remote device.

\emph{Exception: AsynCall}


\subsubsection{void DeviceProxy::cancel\_all\_polling\_asynch\_request()}

Cancel all pending polling asynchronous requests. This is a call local
to the client. It simply allows the caller not to get the answers
of the asynchronous requests. It does not interrupt the call execution
on the remote devices.


\subsection{Polling related methods}


\subsubsection{bool DeviceProxy::is\_command\_polled(string \&cmd\_name)}

Returns true if the command \textquotedbl{}cmd\_name\textquotedbl{}
is polled. Otherwise, returns false.


\subsubsection{bool DeviceProxy::is\_command\_polled(const char {*}cmd\_name)}

Idem previous call


\subsubsection{bool DeviceProxy::is\_attribute\_polled(string \&attr\_name)}

Returns true if the attribute \textquotedbl{}attr\_name\textquotedbl{}
is polled. Otherwise, returns false.


\subsubsection{bool Deviceproxy::is\_attribute\_polled(const char {*}attr\_name)}

Idem previous call


\subsubsection{int DeviceProxy::get\_command\_poll\_period(string \&cmd\_name)}

Returns the command \textquotedbl{}cmd\_name\textquotedbl{} polling
period in mS. If the command is not polled, it returns 0.


\subsubsection{int DeviceProxy::get\_command\_poll\_period(const char {*}cmd\_name)}

Idem previous call


\subsubsection{int DeviceProxy::get\_attribute\_poll\_period(string \&attr\_name)}

Returns the attribute \textquotedbl{}attr\_name\textquotedbl{} polling
period in mS. If the attribute is not polled, it returns 0.


\subsubsection{int Deviceproxy::get\_attribute\_poll\_period(const char {*}attr\_name)}

Idem previous call


\subsubsection{vector<string> {*}DeviceProxy::polling\_status()}

Returns the device polling status. There is one string for each polled
command/attribute. Each string is multi-line string with :
\begin{itemize}
\item The attribute/command name
\item The attribute/command polling period (in mS)
\item The attribute/command polling ring buffer depth
\item The time needed for the last command/attribute execution (in mS)
\item The time since data in the ring buffer has not been updated
\item The delta time between the last records in the ring buffer
\item The exception parameters in case of the last command/attribute execution
failed
\end{itemize}
This method allocates memory for the vector of string(s) returned
to the caller. It is the caller responsibility to delete this memory.


\subsubsection{void DeviceProxy::poll\_command(string \&cmd\_name,int period)}

Add the command \textquotedbl{}cmd\_name\textquotedbl{} to the list
of polled command. The polling period is specified by \textquotedbl{}period\textquotedbl{}
(in mS). If the command is already polled, this method will update
the polling period according to \textquotedbl{}period\textquotedbl{}.


\subsubsection{void DeviceProxy::poll\_command(const char {*}cmd\_name, int period)}

Idem previous call


\subsubsection{void DeviceProxy::poll\_attribute(string \&attr\_name, int period)}

Add the attribute \textquotedbl{}attr\_name\textquotedbl{} to the
list of polled attributes. The polling period is specified by \textquotedbl{}period\textquotedbl{}
(in mS). If the attribute is already polled, this method will update
the polling period according to \textquotedbl{}period\textquotedbl{}.


\subsubsection{void DeviceProxy::poll\_attribute(const char {*}attr\_name, int period)}

Idem previous call


\subsubsection{void DeviceProxy::stop\_poll\_command(string \&cmd\_name)}

Remove command \textquotedbl{}cmd\_name\textquotedbl{} from the list
of polled command.


\subsubsection{void DeviceProxy::stop\_poll\_command(const char {*}cmd\_name)}

Idem previous call


\subsubsection{void DeviceProxy::stop\_poll\_attribute(string \&attr\_name)}

Remove attribute \textquotedbl{}attr\_name\textquotedbl{} from the
list of polled attributes.


\subsubsection{void DeviceProxy::stop\_poll\_attribute(const char {*}attr\_name)}

Idem previous call


\subsection{Event related methods}


\subsubsection{int DeviceProxy::subscribe\_event(const string \&attribute, EventType
event, CallBack {*}cb)}

The client call to subscribe for event reception in the \textbf{push
model}. The client implements a callback method which is triggered
when the event is received. Filtering is done based on the event type.
For example when reading the state and the reason specified is \textquotedbl{}change\textquotedbl{}
the event will be fired only when the state changes. Events consist
of an attribute name and the event reason. A standard set of reasons
are implemented by the system, additional device specific reasons
can be implemented by device servers programmers.

The \emph{attribute} parameter is the device attribute name which
will be sent as an event e.g. ``current'', \emph{event} parameter
is the event reason and must be on the enumerated values:
\begin{itemize}
\item Tango::CHANGE\_EVENT
\item Tango::PERIODIC\_EVENT
\item Tango::ARCHIVE\_EVENT
\item Tango::ATTR\_CONF\_EVENT
\item Tango::DATA\_READY\_EVENT
\item Tango::USER\_EVENT
\end{itemize}
\emph{cb} is a pointer to a class inheriting from the Tango CallBack
class and implementing a \emph{push\_event()} method.

The \emph{subscribe\_event()} call returns an event id which has to
be specified when unsubscribing from this event. Please, note that
the \emph{cb} parameter is a pointer. The lifetime of the pointed
to object must at least be equal to the time when events are requested
because only the pointer is stored into the event machinery. The same
thing is true for the DeviceProxy instance on which the \emph{subscribe\_event()}
method is called.

\emph{Exception:} \emph{EventSystemFailed}

Note: For releases prior to Tango 8, a similar call with a forth argument
(const vector<string> \&filters) was available. This extra argument
gave the user a way to define extra event filtering. For compatibility
reason, this call still exist but the extra filtering features is
not implemented.


\subsubsection{int DeviceProxy::subscribe\_event(const string \&attribute, EventType
event, CallBack {*}cb, bool stateless)}

This subscribe event method has the same functionality as described
in the last section. It adds an additional flag called \emph{stateless.}
When the \emph{stateless} flag is set to \emph{false}, an exception
will be thrown when the event subscription encounters a problem. 

With the \emph{stateless} flag set to \emph{true}, the event subscription
will always succeed, even if the corresponding device server is not
running. The keep alive thread will try every 10 seconds to subscribe
for the specified event. At every subscription retry, a callback is
executed which contains the corresponding exception.

\emph{Exception:} \emph{EventSystemFailed}

Note: For releases prior to Tango 8, a similar call with a fifth argument
(const vector<string> \&filters) was available. This extra argument
gave the user a way to define extra event filtering and it was the
forth argument in the argument list. For compatibility reason, this
call still exist but the extra filtering features is not implemented.


\subsubsection{int DeviceProxy::subscribe\_event(const string \&attribute, EventType
event, int event\_queue\_size, bool stateless)}

The client call to subscribe for event reception in the \textbf{pull
model}. Instead of a callback method the client has to specify the
size of the event reception buffer.

The event reception buffer is implemented as a round robin buffer.
This way the client can set-up different ways to receive events.
\begin{itemize}
\item Event reception buffer size = 1 : The client is interested only in
the value of the last event received. All other events that have been
received since the last reading are discarded.
\item Event reception buffer size > 1 : The client has chosen to keep an
event history of a given size. When more events arrive since the last
reading, older events will be discarded.
\item Event reception buffer size = ALL\_EVENTS : The client buffers all
received events. The buffer size is unlimited and only restricted
by the available memory for the client.
\end{itemize}
All other parameters are similar to the descriptions given in the
last two sections.

\emph{Exception:} \emph{EventSystemFailed}

Note: For releases prior to Tango 8, a similar call with a fifth argument
(const vector<string> \&filters) was available. This extra argument
gave the user a way to define extra event filtering and it was the
forth argument in the argument list. For compatibility reason, this
call still exist but the extra filtering features is not implemented.


\subsubsection{void DeviceProxy::unsubscribe\_event(int event\_id)}

Unsubscribe a client from receiving the event specified by \emph{event\_id}.
\emph{event\_id} is the event identifier returned by the \emph{DeviceProxy::subscribe\_event()}
method.

\emph{Exception:} \emph{EventSystemFailed}


\subsubsection{void DeviceProxy::get\_events(int event\_id, CallBack {*}cb)}

The method extracts all waiting events from the event reception buffer
and executes the callback method \emph{cb} for every event. During
event subscription the client must have chosen the \textbf{pull model}
for this event. \emph{event\_id} is the event identifier returned
by the \emph{DeviceProxy::subscribe\_event()} method.

\emph{Exception:} \emph{EventSystemFailed}


\subsubsection{void DeviceProxy::get\_events(int event\_id, EventDataList \&event\_list)}

The method extracts all waiting events from the event reception buffer.
The returned \emph{event\_list} is a vector of EventData pointers.
The EventData object contains the event information as for the callback
methods. 

During event subscription the client must have chosen the \textbf{pull
model} for this event. \emph{event\_id} is the event identifier returned
by the \emph{DeviceProxy::subscribe\_event()} method.

\emph{Exception:} \emph{EventSystemFailed}


\subsubsection{void DeviceProxy::get\_events(int event\_id, AttrConfEventDataList
\&event\_list)}

The method extracts all waiting attribute configuration events from
the event reception buffer. The returned \emph{event\_list} is a vector
of AttrConfEventData pointers. The AttrConfEventData object contains
the event information as for the callback methods. 

During event subscription the client must have chosen the \textbf{pull
model} for this event. \emph{event\_id} is the event identifier returned
by the \emph{DeviceProxy::subscribe\_event()} method.

\emph{Exception:} \emph{EventSystemFailed}


\subsubsection{void DeviceProxy::get\_events(int event\_id, DataReadyEventDataList
\&event\_list)\index{DataReadyEventDataList}}

The method extracts all waiting attribute configuration events from
the event reception buffer. The returned \emph{event\_list} is a vector
of DataReadyEventData\index{DataReadyEventData} pointers. The DataReadyEventData
object contains the event information as for the callback methods. 

During event subscription the client must have chosen the \textbf{pull
model} for this event. \emph{event\_id} is the event identifier returned
by the \emph{DeviceProxy::subscribe\_event()} method.

\emph{Exception:} \emph{EventSystemFailed}


\subsubsection{int DeviceProxy::event\_queue\_size(int event\_id)}

Returns the number of stored events in the event reception buffer.
After every call to \emph{DeviceProxy:get\_events()}, the event queue
size is 0.

During event subscription the client must have chosen the \textbf{pull
model} for this event. \emph{event\_id} is the event identifier returned
by the \emph{DeviceProxy::subscribe\_event()} method.

\emph{Exception:} \emph{EventSystemFailed}


\subsubsection{TimeVal DeviceProxy::get\_last\_event\_date(int event\_id)}

Returns the arrival time of the last event stored in the event reception
buffer. After every call to \emph{DeviceProxy:get\_events()}, the
event reception buffer is empty. In this case an exception will be
returned.

During event subscription the client must have chosen the \textbf{pull
model} for this event. \emph{event\_id} is the event identifier returned
by the \emph{DeviceProxy::subscribe\_event()} method.

\emph{Exception:} \emph{EventSystemFailed}


\subsubsection{bool DeviceProxy::is\_event\_queue\_empty(int event\_id)}

Returns true when the event reception buffer is empty.

During event subscription the client must have chosen the \textbf{pull
model} for this event. \emph{event\_id} is the event identifier returned
by the \emph{DeviceProxy::subscribe\_event()} method.

\emph{Exception:} \emph{EventSystemFailed}


\subsection{Property related methods}


\subsubsection{void DeviceProxy::get\_property (string\&, DbData\&)}

Get a single property for a device. The property to get is specified
as a string. Refer to DbDevice::get\_property() and DbData sections
below for details on the DbData type.

\emph{Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
(with database), DevFailed from database device}


\subsubsection{void DeviceProxy::get\_property (vector<string>\&, DbData\&)}

Get a list of properties for a device. The properties to get are specified
as a vector of strings. Refer to DbDevice::get\_property() and DbData
sections below for details on the DbData type.

\emph{Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
(with database), DevFailed from database device}


\subsubsection{void DeviceProxy::get\_property(DbData\&)}

Get property(ies) for a device. Properties to get are specified using
the DbData type. Refer to DbDevice::get\_property() and DbData sections
below for details.

\emph{Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
(with database), DevFailed from database device}


\subsubsection{void DeviceProxy::put\_property(DbData\&)}

Put property(ies) for a device. Properties to put are specified using
the DbData type. Refer to DbDevice::put\_property() and DbData sections
below for details.

\emph{Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
(with database), DevFailed from database device}


\subsubsection{void DeviceProxy::delete\_property (string\&)}

Delete a single property for a device. The property to delete is specified
as a string.

\emph{Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
(with database), DevFailed from database device}


\subsubsection{void DeviceProxy::delete\_property (vector<string>\&)}

Delete a list of properties for a device. The properties to delete
are specified as a vector of strings.

\emph{Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
(with database), DevFailed from database device}


\subsubsection{void DeviceProxy::delete\_property(DbData\&)}

Delete property(ies) for a device. Properties to delete are specified
using the DbData type. Refer to DbDevice::get\_property() and DbData
sections below for details.

\emph{Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
(with database), DevFailed from database device}


\subsubsection{void DeviceProxy::get\_property\_list(const string \&filter,vector<string>
\&prop\_list)}

Get the list of property names for the device. The parameter \emph{filter}
allows the user to filter the returned name list. The wildcard character
is '{*}'. Only one wildcard character is allowed in the filter parameter.
The name list is returned in the vector of strings passed as the method
second argument. 

\emph{Exception: NonDbDevice, WrongNameSyntax, ConnectionFailed (with
database), CommunicationFailed (with database), DevFailed from database
device}


\subsection{Logging related methods }


\subsubsection{void DeviceProxy::add\_logging\_target(const string \&target\_type\_target\_name)}

Adds a new logging target to the device. The target\_type\_target\_name
input parameter must follow the format: target\_type::target\_name.
Supported target types are: \emph{console}, \emph{file} and \emph{device}.
For a device target, the target\_name part of the target\_type\_target\_name
parameter must contain the name of a log consumer device (as defined
in \ref{sec:Tango-log-consumer}). For a file target, target\_name
is the full path to the file to log to. If omitted, the device's name
is used to build the file name (which is something like domain\_family\_member.log).
Finally, the target\_name part of the target\_type\_target\_name input
parameter is ignored in case of a console target and can be omitted.

\emph{Exception: DevFailed from device}


\subsubsection{void DeviceProxy::add\_logging\_target (const char {*}target\_type\_target\_name)}

Idem previous call


\subsubsection{void DeviceProxy::remove\_logging\_target(const string \&target\_type\_target\_name)}

Removes a logging target from the device's target list. The target\_type\_target\_name
input parameter must follow the format: target\_type::target\_name.
Supported target types are: \emph{console}, \emph{file} and \emph{device}.
For a device target, the target\_name part of the target\_type\_target\_name
parameter must contain the name of a log consumer device (as defined
in ). For a file target, target\_name is the full path to the file
to remove. If omitted, the default log file is removed. Finally, the
target\_name part of the target\_type\_target\_name input parameter
is ignored in case of a console target and can be omitted.

If target\_name is set to \textquotedbl{}{*}\textquotedbl{}, all targets
of the specified target\_type are removed. 


\subsubsection{void DeviceProxy::remove\_logging\_target (const char {*}target\_type\_target\_name)}

Idem previous call


\subsubsection{vector<string> DeviceProxy::get\_logging\_target ()}

Returns a vector of string containing the current device's logging
targets. Each vector element has the following format: target\_type::target\_name.
An empty vector is returned is the device has no logging targets.


\subsubsection{int DeviceProxy::get\_logging\_level ()}

Returns the current device's logging level (0=OFF, 1=FATAL, 2=ERROR,
3=WARNING, 4=INFO, 5=DEBUG).


\subsubsection{void DeviceProxy::set\_logging\_level (int level)}

Changes the device's logging level. (0=OFF, 1=FATAL, 2=ERROR, 3=WARNING,
4=INFO, 5=DEBUG).


\subsection{Locking\index{Locking} related methods}


\subsubsection{void DeviceProxy::lock\index{lock}(int lock\_validity = 10)}

Lock a device. The lock\_validity is the time (in seconds) the lock
is kept valid after the previous lock call. A default value of 10
seconds is provided and should be fine in most cases. In case it is
necessary to change the lock validity, it's not possible to ask for
a validity less than a minimum value set to 2 seconds. The library
provided an automatic system to periodically re lock the device until
an unlock call. No code is needed to start/stop this automatic re-locking
system. The locking system is re-entrant. It is then allowed to call
this method on a device already locked by the same process. The locking
system has the following features:
\begin{itemize}
\item It is impossible to lock the database device or any device server
process admin device
\item Destroying a locked DeviceProxy unlocks the device
\item Restarting a locked device keeps the lock
\item It is impossible to restart a device locked by someone else
\item Restarting a server breaks the lock
\end{itemize}
A locked device is protected against the following calls when executed
by another client:
\begin{itemize}
\item \emph{command\_inout} call except for device state and status requested
via command and for the set of commands defined as allowed following
the definition of allowed command in the Tango control access schema.
\item \emph{write\_attribute} call
\item \emph{write\_read\_attribute} call
\item \emph{set\_attribute\_config} call
\end{itemize}

\subsubsection{void DeviceProxy::unlock\index{unlock}(bool force = false)}

Unlock a device. If used, the method argument provides a back door
on the locking system. If this argument is set to true, the device
will be unlocked even if the caller is not the locker. This feature
is provided for administration purpopse and should be used very carefully.
If this feature is used, the locker will receive a \emph{DeviceUnlocked}
during the next call which is normally protected by the locking Tango
system.


\subsubsection{string DeviceProxy::locking\_status\index{locking-status}()}

This method returns a plain string describing the device locking status.
This string can be:
\begin{itemize}
\item \textquotedbl{}Device <device name> is not locked\textquotedbl{} in
case the device is not locked
\item \textquotedbl{}Device <device name> is locked by CPP or Python client
with PID <pid> from host <host name>\textquotedbl{} in case the device
is locked by a CPP client
\item \textquotedbl{}Device <device name> is locked by JAVA client class
<main class> from host <host name>\textquotedbl{} in case the device
is locked by a JAVA client
\end{itemize}

\subsubsection{bool DeviceProxy::is\_locked\index{is-locked}()}

Returns true if the device is locked. Otherwise, returns false.


\subsubsection{bool DeviceProxy::is\_locked\_by\_me\index{is-locked-by-me}()}

Returns true if the device is locked by the caller. Otherwise, returns
false (device not locked or locked by someone else)


\subsubsection{bool DeviceProxy::get\_locker\index{get-locker}(LockerInfo \&li)}

If the device is locked, this method returns true an set some locker
process informations in the structure passed as argument. If the device
is not locked, the method returns false. The LockerInfo structure
definition is

\input{line.tex}
\begin{lyxcode}
typedef~union

\{

~~~pid\_t~~~~~~~~~~~LockerPid;

~~~unsigned~long~~~UUID{[}4{]};

\}LockerId;~\\
~\\


enum~LockerLanguage

\{

~~~CPP,

~~~JAVA

\};~\\
~\\


struct~LockerInfo

\{

~~~LockerLanguage~~ll;

~~~LockerId~~~~~~~~li;

~~~string~~~~~~~~~~locker\_host;

~~~string~~~~~~~~~~locker\_class;

\};
\end{lyxcode}
\input{line.tex}

The structure \emph{ll} field is set to either CPP or JAVA depending
on the locker process language. In case of CPP client, the \emph{li}
union is set to the locker process pid (\emph{LockerPid} field). In
case of Java client, it is set to the Java client UUID (Universal
Uniq IDentifier) in the \emph{UUID} field. The \emph{locker\_host}
field is initialised with the host name where the locker process is
running (or its IP adress as a string if it is not possiblr to get
the name associated with this address). The \emph{locker\_class} field
is set to the Java virtual machine main class name when the locker
client process is written in Java. For CPP client, it is set to the
string \textquotedbl{}Not defined\textquotedbl{}.


\section{\noindent Tango::DeviceData}

\noindent This is the fundamental type for sending and receiving data
from device commands. The values can be inserted and extracted using
the operators <\textcompwordmark{}< and >\textcompwordmark{}> respectively
and insert() for mixed data types. A status flag indicates if there
is data in the DbDatum object or not. An additional flag allows the
user to activate exceptions. 


\subsection{\noindent Constructors, assignement operators and C++11}

This class has a default constructor (\emph{DeviceData()}), a copy
constructor (\emph{DeviceData(const DeviceData \&)}) and one assignement
operator (\emph{DeviceData \& operator=(const DeviceData \&)}). Nevertheless,
the assignement operator and the copy constructor does not really
copy the data included in the instance. For efficiency reasons, they
rather move the data from one instance to another. Starting with Tango
8 and if Tango is compiled with gcc release 4.3 or above (or Windows
VC 10 and above), some move semantics from C++11\index{C++11} has
been added. This means that:
\begin{itemize}
\item A move constructor (\emph{DeviceData(DeviceData \&\&)}) has been added.
\item A move assignement operator (\emph{DeviceData \& operator=(DeviceData
\&\&)}) has been added.
\item The classical copy constructor and assignement operator really copy
the data.
\end{itemize}

\subsection{\noindent Operators}

\noindent The insert and extract operators are specified for the following
C++ types :
\begin{enumerate}
\item \noindent bool
\item \noindent short
\item \noindent unsigned short
\item \noindent DevLong
\item \noindent DevULong
\item \noindent DevLong64
\item DevULong64
\item \noindent float
\item \noindent double
\item \noindent string
\item \noindent char{*} (insert only)
\item \noindent const char {*}
\item \noindent vector<unsigned char>
\item \noindent vector<string>
\item \noindent vector<short>
\item \noindent vector<unsigned short>
\item \noindent vector<DevLong>
\item \noindent vector<DevULong>
\item vector<DevLong64>
\item vector<DevULong64>
\item \noindent vector<float>
\item \noindent vector<double>
\end{enumerate}
Operators exist for inserting and extracting the native TANGO CORBA
sequence types. These can be useful for programmers who want to use
the TANGO api internally in their device servers and do not want to
convert from CORBA to C++ types. Insert and extract operators exist
for the following types :
\begin{enumerate}
\item DevVarUCharArray {*} (const DevVarUCharArray {*} for extraction)
\item DevVarShortArray {*} (const DevVarShortArray {*} for extraction)
\item DevVarUShortArray {*} (const DevVarUShortArray {*} for extraction)
\item DevVarLongArray {*} (const DevVarLongArray {*} for extraction)
\item DevVarULongArray {*} (const DevVarULongArray {*} for extraction)
\item DevVarLong64Array {*} (const DevVarLong64Array {*} for extraction)
\item DevVarULong64Array {*} (const DevVarULong64Array {*} for extraction)
\item DevVarFloatArray {*} (const DevVarFloatArray {*} for extraction)
\item DevVarDoubleArray {*} (const DevVarDoubleArray {*} for extraction)
\item DevVarStringArray {*} (const DevVarStringArray {*} for extraction)
\item DevVarLongStringArray {*} (const DevVarLongStringArray {*} for extraction)
\item DevVarDoubleStringArray {*} (const DevVarDoubleStringArray {*} for
extraction)
\end{enumerate}
\input{line.tex}

\textbf{Note :}\\
\textbf{Insertion by pointers takes full ownership of the pointed
to memory. The insertion copy the data in the DeviceData object and
delete the pointed to memory. Therefore, the memory is not more usable
after the insertion. Also note that when using extraction by pointers,
the pointed to memory is inside the DeviceData object and its lifetime
is the same than the DeviceData object lifetime.}

\input{line.tex}

Operators also exist for inserting TANGO CORBA sequence type by reference.
The insertion copy the data into the DeviceData object. Insert operator
exist for the following types :
\begin{enumerate}
\item DevVarUCharArray \&
\item DevVarShortArray \&
\item DevVarUShortArray \&
\item DevVarLongArray \&
\item DevVarULongArray \&
\item DevVarLong64Array \&
\item DevVarULong64Array \&
\item DevVarFloatArray \&
\item DevVarDoubleArray \&
\item DevVarStringArray \&
\item DevVarLongStringArray \&
\item DevVarDoubleStringArray \&
\end{enumerate}
Additional methods exist for inserting a mixture of strings and long
(Tango::DevVarLongStringArray) and string and doubles (Tango::DevVarDoubleStringArray).
These are :
\begin{enumerate}
\item insert(vector<long>\&, vector<string>\&)
\item insert(vector<double>\&, vector<string>\&)
\item extract(vector<long>\&, vector<string>\&)
\item extract(vector<double>\&, vector<string>\&)
\end{enumerate}
\noindent All the extraction methods returns a boolean set to false
if the extraction has failed (empty DeviceData, wrong data type...)

\noindent Special care has been taken to avoid memory copy between
the network layer and the user application. Nevertheless, C++ vector
types are not the CORBA native type and one copy is unavoidable when
using vectors. Using the native TANGO CORBA sequence types avoid any
copy. When using these TANGO CORBA sequence types, insertion into
the DeviceData object consumes the memory pointed to by the pointer.
After the insertion, it is not necessary to delete the memory. It
will be done by the destruction of the DeviceData object. For extraction,
the pointer used for the extraction points into memory inside the
DeviceData object and you should not delete it

\noindent Here is an example of creating, inserting and extracting
some data type from/into DeviceData object :

\input{line.tex}
\begin{lyxcode}
\noindent DeviceData~my\_short,~my\_long,~my\_string;

\noindent DeviceData~my\_float\_vector,~my\_double\_vector;

\noindent string~a\_string;

\noindent short~a\_short;

\noindent DevLong~a\_long;

\noindent vector<float>~a\_float\_vector;

\noindent vector<double>~a\_double\_vector;

\noindent my\_short~<\textcompwordmark{}<~100;~//~insert~a~short

\noindent my\_short~>\textcompwordmark{}>~a\_short;~//~extract~a~short

\noindent my\_long~<\textcompwordmark{}<~1000;~//~insert~a~long

\noindent my\_long~>\textcompwordmark{}>~a\_long;~//~extract~a~long

\noindent my\_string~<\textcompwordmark{}<~string(``estas~lista~a~bailar~el~tango~?'');~//~insert~a~string

\noindent my\_string~>\textcompwordmark{}>~a\_string;~//~extract~a~string

\noindent my\_float\_vector~<\textcompwordmark{}<~a\_float\_vector~//~insert~a~vector~of~floats

\noindent my\_float\_vector~>\textcompwordmark{}>~a\_float\_vector;~//~extract~a~vector~of~floats

\noindent my\_double\_vector~<\textcompwordmark{}<~a\_double\_vector;~//~insert~a~vector~of~doubles

\noindent my\_double\_vector~>\textcompwordmark{}>~a\_double\_vector;~//~extract~a~vector~of~doubles~\\
//

//~Example~of~memory~management~with~TANGO~sequence~types~without~memory~leaks

//

for~(int~i~=~0;i~<~10;i++)

\{

~~~~DeviceData~din,dout;

~~~~DevVarLongArray~{*}in~=~new~DevVarLongArray();

~~~~in->length(2);

~~~~({*}in){[}0{]}~=~2;

~~~~({*}in){[}1{]}~=~4;

~~~~din~<\textcompwordmark{}<~in;

~~~~try

~~~~\{

~~~~~~~~dout~=~device->command\_inout(``Cmd'',din);

~~~~\}

~~~~catch(DevFailed~\&e)

~~~~\{

~~~~~~~....

~~~~\}

~~~~const~DevVarLongArray~{*}out;

~~~~dout~>\textcompwordmark{}>~out;

~~~~cout~<\textcompwordmark{}<~``Received~value~=~``~<\textcompwordmark{}<~({*}out){[}0{]};

\}




\end{lyxcode}
\input{line.tex}

\noindent \emph{Exception: WrongData if requested}


\subsection{\noindent bool DeviceData::is\_empty()}

\noindent is\_empty() is a boolean method which returns true or false
depending on whether the DeviceData object contains data or not. It
can be used to test whether the DeviceData has been initialized or
not e.g.

\input{line.tex}
\begin{lyxcode}
\noindent string~string\_read;

\noindent DeviceData~sl\_read~=~my\_device->command\_inout(``ReadLine'');

\noindent if~(!~sl\_read.is\_empty())~

\noindent \{

\noindent ~~~~sl\_read~>\textcompwordmark{}>~string\_read;

\noindent \}

\noindent else

\noindent \{

\noindent ~~~~cout~<\textcompwordmark{}<~``~no~data~read~from~serial~line~!''~<\textcompwordmark{}<~endl;

\noindent \}
\end{lyxcode}
\input{line.tex}

\emph{Exception: WrongData if requested}


\subsection{int DeviceData::get\_type()}

\noindent This method returns the Tango data type of the data inside
the DeviceData object


\subsection{\noindent void DeviceData::exceptions(bitset<DeviceData::numFlags>
)}

\noindent Is a method which allows the user to switch on/off exception
throwing when trying to extract data from an empty DeviceData object
or using a wrong data type. The default is to not throw exception.
The following flags are supported :
\begin{enumerate}
\item \noindent \textbf{isempty\_flag} - throw a WrongData exception (reason
= API\_EmptyDeviceData) if user tries to extract data from an empty
DeviceData object
\item \textbf{wrongtype\_flag} - throw a WrongData exception (reason = API\_IncompatibleCmdArgumentType)
if user tries to extract data with a type different than the type
used for insertion
\end{enumerate}

\subsection{bitset<DeviceData::numFlags> exceptions()}

Returns the whole exception flags.


\subsection{void DeviceData::reset\_exceptions(DeviceData::except\_flags fl)}

Resets one exception flag


\subsection{void DeviceData::set\_exceptions(DeviceData::except\_flags fl)}

Sets one exception flag

The following is an example of how to use these exceptions related
methods

\input{line.tex}
\begin{lyxcode}
\noindent ~~~~~1~~~~~~~~~~DeviceData~da;

~~~~~2~~

~~~~~3~~~~~~~~~~bitset<DeviceData::numFlags>~bs~=~da.exceptions();

~~~~~4~~~~~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}bs~=~\textquotedbl{}~<\textcompwordmark{}<~bs~<\textcompwordmark{}<~endl;

~~~~~5~~~~~~~~~~~~~~~~~~

~~~~~6~~~~~~~~~~da.set\_exceptions(DeviceData::wrongtype\_flag);

~~~~~7~~~~~~~~~~bs~=~da.exceptions();

~~~~~8~~~~~~~~~~~~~~~~~~

~~~~~9~~~~~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}bs~=~\textquotedbl{}~<\textcompwordmark{}<~bs~<\textcompwordmark{}<~endl;
\end{lyxcode}
\input{line.tex}


\subsection{ostream \&operator<\textcompwordmark{}<(ostream \&, DeviceData \&)}

Is an utility function to easily print the contents of a DeviceData
object. This function knows all types which could be inserted in a
DeviceData object and print them accordingly. A special string is
printed if the DeviceData object is empty

\input{line.tex}
\begin{lyxcode}
\noindent DeviceProxy~{*}dev~=~new~DeviceProxy(``...'');

DeviceData~out;

out~=~dev->command\_inout(``MyCommand'');



cout~<\textcompwordmark{}<~``Command~returned:~''~<\textcompwordmark{}<~out~<\textcompwordmark{}<~endl;


\end{lyxcode}
\input{line.tex}


\section{Tango::DeviceDataHistory\label{DataHistory}}

This is the fundamental type for receiving data from device command
polling buffers. This class inherits from the Tango::DeviceData class.
One instance of this class is created for each command result history.
Within this class, you find the command result data or the exception
parameters, a flag indicating if the command has failed when it was
invoked by the device server polling thread and the date when the
command was executed. For history calls, it is not possible to returns
command error as exception. See chapter on Advanced Features for all
details regarding device polling. On top of the methods inherited
from the DeviceData class, it offers the following methods


\subsection{bool DeviceDataHistory::has\_failed()}

Returns true if the corresponding command has failed when it was executed
by the device server polling thread. Otherwise returns false (amazing!)

\emph{Exception: none}


\subsection{TimeVal \&DeviceDataHistory::get\_date()}

Returns the date when the device server polling thread has executed
the command.

\emph{Exception: none}


\subsection{const DevErrorList \&DeviceDataHistory::get\_err\_stack()}

Return the error stack recorded by the device server polling thread
in case of the command failed when it was invoked.

\emph{Exception: none}


\subsection{ostream \&operator<\textcompwordmark{}<(ostream \&, DeviceDataHistory
\&)}

Is an utility function to easily print the contents of a DeviceDataHistory
object. This function knows all types which could be inserted in a
DeviceDataHistory object and print them accordingly. It also prints
date and error stack in case the command returned an error.

\input{line.tex}
\begin{lyxcode}
\noindent DeviceProxy~{*}dev~=~new~DeviceProxy(``...'');

int~hist\_depth~=~4;

vector<DeviceDataHistory>~{*}hist;



hist~=~dev->command\_history(``MyCommand'',hist\_depth);



for~(int~i~=~0;i~<~hist\_depth;i++)

\{

~~~~cout~<\textcompwordmark{}<~({*}hist){[}i{]}~<\textcompwordmark{}<~endl;

\}

delete~hist;


\end{lyxcode}
\input{line.tex}


\section{\noindent Tango::DeviceAttribute}

\noindent This is the fundamental type for sending and receiving data
to and from device attributes. The values can be inserted and extracted
using the operators <\textcompwordmark{}< and >\textcompwordmark{}>
respectively and insert() for mixed data types. There are two ways
to check if the extraction operator succeed :
\begin{enumerate}
\item By testing the extractor operators return value. All the extractors
operator returns a boolean value set to false in case of problem.
\item By asking the DeviceAttribute object to throw exception in case of
problem. By default, DeviceAttribute throws exception :

\begin{enumerate}
\item when the user try to extract data and the server reported an error
when the attribute was read.
\item When the user try to extract data from an empty DeviceAttribute
\end{enumerate}
\end{enumerate}

\subsection{Constructors, assignement operators}

Many constructors have been written for this class. The following
constructors exist :
\begin{enumerate}
\item The C++ basic constructors

\begin{enumerate}
\item DeviceAttribute();
\item DeviceAttribute(const DeviceAttribute\&)\textbf{;}
\end{enumerate}
\item Constructors for scalar type with name as C++ string or \textquotedbl{}const
char {*}\textquotedbl{}

\begin{enumerate}
\item DeviceAttribute(string \&, bool);
\item DeviceAttribute(string \&, short)\textbf{;}
\item DeviceAttribute(string \&, DevLong);
\item DeviceAttribute(string \&, DevLong64);
\item DeviceAttribute(string \&, float);
\item DeviceAttribute(string \&, double);
\item DeviceAttribute(string \&, unsigned char);
\item DeviceAttribute(string \&, unsigned short);
\item DeviceAttribute(string \&, DevULong);
\item DeviceAttribute(string \&, DevULong64);
\item DeviceAttribute(string \&, string \&);
\item DeviceAttribute(string \&, DevState);
\item DeviceAttribute(string \&, DevEncoded \&);
\item DeviceAttribute(const char {*}, bool);
\item DeviceAttribute(const char {*}, short)\textbf{;}
\item DeviceAttribute(const char {*}, DevLong);
\item DeviceAttribute(const char {*}, DevLong64);
\item DeviceAttribute(const char {*}, float)\textbf{;}
\item DeviceAttribute(const char {*}, double);
\item DeviceAttribute(const char {*}, unsigned char)\textbf{;}
\item DeviceAttribute(const char {*}, unsigned short);
\item DeviceAttribute(const char {*}, DevULong);
\item DeviceAttribute(const char {*}, DevULong64);
\item DeviceAttribute(const char {*}, string \&);
\item DeviceAttribute(const char {*}, DevState);
\item DeviceAttribute(const char {*},DevEncoded \&);
\end{enumerate}
\item Constructors for C++ vector types (for spectrum attribute) with name
as C++ string or \textquotedbl{}const char {*}\textquotedbl{}

\begin{enumerate}
\item DeviceAttribute(string \&, vector<bool> \&);
\item DeviceAttribute(string \&, vector\textbf{<}short\textbf{>} \&)\textbf{;}
\item DeviceAttribute(string \&, vector<DevLong> \&);
\item DeviceAttribute(string \&, vector<DevLong64> \&);
\item DeviceAttribute(string \&, vector<float> \&);
\item DeviceAttribute(string \&, vector<double> \&);
\item DeviceAttribute(string \&, vector<unsigned char> \&);
\item DeviceAttribute(string \&, vector<unsigned short> \&);
\item DeviceAttribute(string \&, vector<DevULong> \&);
\item DeviceAttribute(string \&, vector<DevULong64> \&);
\item DeviceAttribute(string \&, vector<string> \& );
\item DeviceAttribute(string \&, vector<DevState> \&);
\item DeviceAttribute(const char {*}, vector<bool> \&);
\item DeviceAttribute(const char {*}, vector<short> \&)\textbf{;}
\item DeviceAttribute(const char {*}, vector<DevLong> \&);
\item DeviceAttribute(const char {*}, vector<DevLong64> \&);
\item DeviceAttribute(const char {*}, vector<float> \&)\textbf{;}
\item DeviceAttribute(const char {*}, vector<double> \&);
\item DeviceAttribute(const char {*}, vector<unsigned char> \&)\textbf{;}
\item DeviceAttribute(const char {*}, vector<unsigned short> \&);
\item DeviceAttribute(const char {*}, vector<DevULong> \&);
\item DeviceAttribute(const char {*}, vector<DevULong64> \&);
\item DeviceAttribute(const char {*}, vector<string> \& );
\item DeviceAttribute(const char {*}, vector<DevState> \&);
\end{enumerate}
\item Constructors for C++ vector types (for image attribute) with name
as C++ string or \textquotedbl{}const char {*}\textquotedbl{}. These
constructors have two more parameters allowing the user to define
the x and y image dimensions.

\begin{enumerate}
\item DeviceAttribute(string \&, vector<bool> \&, int, int);
\item DeviceAttribute(string \&, vector<short> \&, int, int\textbf{)};
\item DeviceAttribute(string \&, vector<DevLong> \&, int, int);
\item DeviceAttribute(string \&, vector<DevLong64> \&, int, int);
\item DeviceAttribute(string \&, vector<float> \&, int, int);
\item DeviceAttribute(string \&, vector<double> \&, int, int);
\item DeviceAttribute(string \&, vector<unsigned char> \&, int, int);
\item DeviceAttribute(string \&, vector<unsigned short> \&, int, int);
\item DeviceAttribute(string \&, vector<DevULong> \&, int, int);
\item DeviceAttribute(string \&, vector<DevULong64> \&, int, int);
\item DeviceAttribute(string \&, vector<string> \&, int, int );
\item DeviceAttribute(string \&, vector<DevState> \&, int, int);
\item DeviceAttribute(const char {*}, vector<bool> \&, int, int);
\item DeviceAttribute(const char {*}, vector<short> \&, int, int)\textbf{;}
\item DeviceAttribute(const char {*}, vector<DevLong> \&, int, int);
\item DeviceAttribute(const char {*}, vector<DevLong64> \&, int, int);
\item DeviceAttribute(const char {*}, vector<float> \&, int, int)\textbf{;}
\item DeviceAttribute(const char {*}, vector<double> \&, int, int);
\item DeviceAttribute(const char {*}, vector<unsigned char> \&, int, int)\textbf{;}
\item DeviceAttribute(const char {*}, vector<unsigned short> \&, int, int);
\item DeviceAttribute(const char {*}, vector<DevULong> \&, int, int);
\item DeviceAttribute(const char {*}, vector<DevULong64> \&, int, int);
\item DeviceAttribute(const char {*}, vector<string> \& , int, int);
\item DeviceAttribute(const char {*}, vector<DevState) \&, int, int);
\end{enumerate}
\end{enumerate}
Note that the assignement operator and the copy constructor does not
really copy the data included in the instance. For efficiency reasons,
they rather move the data from one instance to another. Starting with
Tango 8 and if Tango is compiled with gcc release 4.3 or above (or
Windows VC 10 and above), some move semantics from C++11\index{C++11}
has been added. This means that:
\begin{itemize}
\item A move constructor (\emph{DeviceAttribute(DeviceAttribute \&\&)})
has been added.
\item A move assignement operator (\emph{DeviceAttribute \& operator=(DeviceAttribute
\&\&)}) has been added.
\item The classical copy constructor and assignement operator really copy
the data.
\end{itemize}

\subsection{\noindent Data Extraction and Insertion : Operators and Methods}

\noindent Special care has been taken to avoid memory copy between
the network layer and the user application. Nevertheless, C++ vector
types are not the CORBA native type and one copy is unavoidable when
using vectors. Using the native TANGO CORBA sequence types in most
cases avoid any copy but needs some more care about memory usage. 
\begin{itemize}
\item \noindent \textbf{For insertion into DeviceAttribute instance from
TANGO CORBA sequence pointers, the DeviceAttribute object takes ownership
of the pointed to memory. This means that the pointed to memory will
be freed when the DeviceAttribute object is destroyed or when another
data is inserted into it.}
\item \textbf{The insertion into DeviceAttribute instance from TANGO CORBA
sequence reference copy the data into the DeviceAttribute object.}
\item \noindent \textbf{For extraction into TANGO CORBA sequence types,
the extraction method consumes the memory allocated to store the data
and it is the caller responsibility to delete this memory.}
\end{itemize}
\noindent As it has been done for constructors, a lot of insertors
operator for classical C++ data types have been defined :
\begin{enumerate}
\item \noindent Insert operators for the following scalar C++ types :

\begin{enumerate}
\item \noindent bool
\item \noindent short
\item \noindent DevLong
\item DevLong64
\item \noindent float
\item \noindent double
\item \noindent unsigned char
\item \noindent unsigned short
\item DevULong
\item DevULong64
\item \noindent string
\item DevState
\item DevEncoded
\item DevString
\item const char {*}
\end{enumerate}
\item Insert operators for the following C++ vector types for spectrum attributes
:

\begin{enumerate}
\item \noindent vector<bool>
\item \noindent vector<short>
\item \noindent vector<DevLong>
\item vector<DevLong64>
\item \noindent vector<float>
\item \noindent vector<double>
\item \noindent vector<unsigned char>
\item \noindent vector<unsigned short>
\item vector<DevULong>
\item vector<DevULong64>
\item \noindent vector<string>
\item vector<DevState>
\end{enumerate}
\item Insert methods for the DevEncoded\index{DevEncoded} data type

\begin{enumerate}
\item insert(char {*}\&, unsigned char {*}\&, unsigned int)\\
The last argument is the size of the buffer passed to the method as
its second argument
\item insert(string \&, vector<unsigned char \&>)
\end{enumerate}
\item Insert methods for the following C++ vector types for image attributes
allowing the specification of the x and y image dimensions :

\begin{enumerate}
\item \noindent insert(vector<bool> \&,int, int)
\item \noindent insert(vector<short> \&,int, int)
\item \noindent insert(vector<DevLong> \&,int, int)
\item \noindent insert(vector<DevLong64> \&,int, int)
\item \noindent insert(vector<float> \&,int, int)
\item \noindent insert(vector<double> \&,int, int)
\item \noindent insert(vector<unsigned char> \&,int, int)
\item \noindent insert(vector<unsigned short> \&,int, int)
\item \noindent insert(vector<DevULong> \&,int, int)
\item \noindent insert(vector<DevULong64> \&,int, int)
\item \noindent insert(vector<string> \&,int, int)
\item insert(vector<DevState> \&,int, int)
\end{enumerate}
\end{enumerate}
Extractor operators are specified for the following C++ basic types
\begin{enumerate}
\item Extract operators for the following scalar C++ types :

\begin{enumerate}
\item \noindent bool
\item \noindent short
\item \noindent DevLong
\item DevLong64
\item \noindent float
\item \noindent double
\item \noindent unsigned char
\item \noindent unsigned short
\item \noindent DevULong
\item DevULong64
\item \noindent string
\item Tango::DevState
\item Tango::DevEncoded
\end{enumerate}
\item Extract operators for the following C++ vector types for spectrum
and image attributes :

\begin{enumerate}
\item \noindent vector<bool>
\item \noindent vector<short>
\item \noindent vector<DevLong>
\item vector<DevLong64>
\item \noindent vector<float>
\item \noindent vector<double>
\item \noindent vector<unsigned char>
\item \noindent vector<unsigned short>
\item \noindent vector<DevULong>
\item vector<DevULong64>
\item \noindent vector<string>
\item vector<DevState>
\end{enumerate}
\item Extract methods to extract only the read value of an attribute into
a C++ vector. The dimension of the read value can be read by using
the methods get\_dim\_x() and get\_dim\_y() or get\_r\_dimension().
The methods use the same return values as the extraction operators
with exceptions triggered by the exception flags:

\begin{enumerate}
\item bool DeviceAttribute::extract\_read (vector<bool>\&);
\item \noindent bool DeviceAttribute::extract\_read (vector<short>\&);
\item \noindent bool DeviceAttribute::extract\_read (vector<DevLong>\&);
\item bool DeviceAttribute::extract\_read (vector<DevLong64>\&);
\item \noindent bool DeviceAttribute::extract\_read (vector<float>\&);
\item bool DeviceAttribute::extract\_read (vector<double>\&);
\item \noindent bool DeviceAttribute::extract\_read (vector<unsigned char>\&);
\item \noindent bool DeviceAttribute::extract\_read (vector<unsigned short>\&);
\item \noindent bool DeviceAttribute::extract\_read (vector<DevULong>\&);
\item bool DeviceAttribute::extract\_read (vector<DevULong64>\&);
\item \noindent bool DeviceAttribute::extract\_read (vector<string>\&);
\item bool DeviceAttribute::extract\_read (vector<DevState>\&);
\item bool DeviceAttribute::extract\_read(string \&, vector<unsigned char>
\&);
\end{enumerate}
\item Extract methods to extract only the set value of an attribute into
a C++ vector. The dimension of the set value can be read by using
the methods get\_written\_dim\_x() and get\_written\_dim\_y() or get\_w\_dimension().
The methods use the same return values as the extraction operators
with exceptions triggered by the exception flags:

\begin{enumerate}
\item bool DeviceAttribute::extract\_set (vector<bool>\&);
\item \noindent bool DeviceAttribute::extract\_set (vector<short>\&);
\item \noindent bool DeviceAttribute::extract\_set (vector<DevLong>\&);
\item bool DeviceAttribute::extract\_set (vector<DevLong64>\&);
\item \noindent bool DeviceAttribute::extract\_set (vector<float>\&);
\item bool DeviceAttribute::extract\_set (vector<double>\&);
\item \noindent bool DeviceAttribute::extract\_set (vector<unsigned char>\&);
\item \noindent bool DeviceAttribute::extract\_set (vector<unsigned short>\&);
\item \noindent bool DeviceAttribute::extract\_set (vector<DevULong>\&);
\item bool DeviceAttribute::extract\_set (vector<DevULong64>\&);
\item \noindent bool DeviceAttribute::extract\_set (vector<string>\&);
\item bool DeviceAttribute::extract\_set (vector<DevState>\&);
\item bool DeviceAttribute::extract\_set(string \&, vector<unsigned char>
\&);
\end{enumerate}
\item Special extract method for the Tango::DevEncoded data type

\begin{enumerate}
\item bool DeviceAttribute::extract(const char {*}\&, unsigned char {*}\&,
unsigned int \&);\\
The last argument is the size of the buffer passed to the method as
its second argument
\item bool DeviceAttribute::extract(string \&, vector<unsigned char> \&);
\end{enumerate}
\end{enumerate}
\noindent Operators also exist for extracting some native TANGO CORBA
sequence types. These can be useful for programmers who want to use
the TANGO api internally in their device servers and do not want to
convert from CORBA to C++ types. 
\begin{enumerate}
\item \noindent Insert operators for spectrum attribute and for the following
types by pointer :

\begin{enumerate}
\item DevVarBooleanArray {*}
\item DevVarShortArray {*}
\item DevVarLongArray {*}
\item DevVarLong64Array {*}
\item DevVarFloatArray {*}
\item DevVarDoubleArray {*}
\item DevVarUCharArray {*}
\item DevVarUShortArray {*}
\item DevVarULongArray {*}
\item DevVarULong64Array {*}
\item DevVarStringArray {*}
\item DevVarStateArray {*}
\end{enumerate}
\item Insert operators for spectrum attribute and for the following types
by reference :

\begin{enumerate}
\item const DevVarBooleanArray \&
\item const DevVarShortArray \&
\item const DevVarLongArray \&
\item const DevVarLong64Array \&
\item const DevVarFloatArray \&
\item const DevVarDoubleArray \&
\item const DevVarUCharArray \&
\item const DevVarUShortArray \&
\item const DevVarULongArray \&
\item const DevVarULong64Array \&
\item const DevVarStringArray \&
\item const DevVarStateArray \&
\end{enumerate}
\item Insert methods for image attribute and pointers. These method allow
the programmer to define the x and y image dimensions. The following
methods are defined :

\begin{enumerate}
\item insert(DevVarBooleanArray {*}, int , int )
\item insert(DevVarShortArray {*}, int , int )
\item insert(DevVarLongArray {*}, int , int )
\item insert(DevVarLong64Array {*}, int, int )
\item insert(DevVarFloatArray {*}, int , int )
\item insert(DevVarDoubleArray {*}, int , int )
\item insert(DevVarUCharArray {*}, int , int )
\item insert(DevVarUShortArray {*}, int , int )
\item insert(DevVarULongArray {*}, int , int )
\item insert(DevVarULong64Array {*}, int, int )
\item insert(DevVarStringArray {*}, int , int )
\item insert(DevVarStateArray {*}, int, int)
\end{enumerate}
\item Insert methods for image attribute and reference. These method allow
the programmer to define the x and y image dimensions. The following
methods are defined :

\begin{enumerate}
\item insert(const DevVarBooleanArray \&, int , int )
\item insert(const DevVarShortArray \&, int , int )
\item insert(const DevVarLongArray \&, int , int )
\item insert(const DevVarLong64Array \&, int, int )
\item insert(const DevVarFloatArray \&, int , int )
\item insert(const DevVarDoubleArray \&, int , int )
\item insert(const DevVarUCharArray \&, int , int )
\item insert(const DevVarUShortArray \&, int , int )
\item insert(const DevVarULongArray \&, int , int )
\item insert(const DevVarULong64Array \&, int, int )
\item insert(const DevVarStringArray \&, int , int )
\item insert(const DevVarStateArray \&, int, int )
\end{enumerate}
\item Extract operators for the following types :

\begin{enumerate}
\item DevVarBooleanArray {*}
\item DevVarShortArray {*}
\item DevVarLongArray {*}
\item DevVarLong64Array {*}
\item DevVarFloatArray {*}
\item DevVarDoubleArray {*}
\item DevVarUCharArray {*}
\item DevVarUShortArray {*}
\item DevVarULongArray {*}
\item DevVarULong64Array {*}
\item DevVarStringArray {*}
\item DevVarStateArray {*}
\item DevVarEncodedArray {*}
\end{enumerate}
\end{enumerate}
\noindent Here is an example of creating, inserting and extracting
some DeviceAttribute types :

\input{line.tex}
\begin{lyxcode}
\noindent DeviceAttribute~my\_short,~my\_long,~my\_string;

\noindent DeviceAttribute~my\_float\_vector,~my\_double\_vector;

\noindent string~a\_string;

\noindent short~a\_short;

\noindent DevLong~a\_long;

\noindent vector<float>~a\_float\_vector;

\noindent vector<double>~a\_double\_vector;

\noindent my\_short~<\textcompwordmark{}<~100;~//~insert~a~short

\noindent my\_short~>\textcompwordmark{}>~a\_short;~//~extract~a~short

\noindent my\_long~<\textcompwordmark{}<~1000;~//~insert~a~long

\noindent my\_long~>\textcompwordmark{}>~a\_long;~//~extract~a~DevLong

\noindent my\_string~<\textcompwordmark{}<~string(\textquotedbl{}estas~lista~a~bailar~el~tango~?\textquotedbl{});~//~insert~a~string

\noindent my\_string~>\textcompwordmark{}>~a\_string;~//~extract~a~string

\noindent my\_float\_vector~<\textcompwordmark{}<~a\_float\_vector~//~insert~a~vector~of~floats

\noindent my\_float\_vector~>\textcompwordmark{}>~a\_float\_vector;~//~extract~a~vector~of~floats

\noindent my\_double\_vector~<\textcompwordmark{}<~a\_double\_vector;~//~insert~a~vector~of~doubles

\noindent my\_double\_vector~>\textcompwordmark{}>~a\_double\_vector;~//~extract~a~vector~of~doubles

//

//~Extract~read~and~set~value~of~an~attribute~separately

//~and~get~their~dimensions

//

\noindent vector<float>~r\_float\_vector,~w\_float\_vector;

my\_float\_vector.extract\_read~(r\_float\_vector)~//~extract~read~values

int~dim\_x~=~my\_float\_vector.get\_dim\_x();~~~~~~//~get~x~dimension

int~dim\_y~=~my\_float\_vector.get\_dim\_y();~~~~~~//~get~y~dimension



my\_float\_vector.extract\_set~~(w\_float\_vector)~//~extract~set~values

int~w\_dim\_x~=~my\_float\_vector.get\_written\_dim\_x();~~//~get~x~dimension

int~W\_dim\_y~=~my\_float\_vector.get\_written\_dim\_y();~~//~get~y~dimension



//

//~Example~of~memory~management~with~TANGO~sequence~types~without~memory~leaks

//

for~(int~i~=~0;i~<~10;i++)

\{

~~~~DeviceAttribute~da;

~~~~DevVarLongArray~{*}out;



~~~~try

~~~~\{

~~~~~~~~da~=~device->read\_attribute(\textquotedbl{}Attr\textquotedbl{});

~~~~~~~~da~>\textcompwordmark{}>~out;

~~~~\}

~~~~catch(DevFailed~\&e)

~~~~\{

~~~~~~~....

~~~~\}



~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Received~value~=~\textquotedbl{}~<\textcompwordmark{}<~({*}out){[}0{]};

~~~~delete~out;

\}
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exception: WrongData if requested}


\subsection{\noindent bool DeviceAttribute::is\_empty()}

\noindent is\_empty() is a boolean method which returns true or false
depending on whether the DeviceAttribute object contains data or not.
It can be used to test whether the DeviceAttribute has been initialized
or not e.g.

\input{line.tex}
\begin{lyxcode}
\noindent string~parity;

\noindent DeviceAttribute~sl\_parity~=~my\_device->read\_attribute(\textquotedbl{}parity\textquotedbl{});

\noindent if~(!~sl\_read.is\_empty())~

\noindent \{

\noindent ~~~~sl\_parity~>\textcompwordmark{}>~parity;

\noindent \}

\noindent else

\noindent \{

\noindent ~~~~cout~<\textcompwordmark{}<~\textquotedbl{}~no~parity~attribute~defined~for~serial~line~!\textquotedbl{}~<\textcompwordmark{}<~endl;

\noindent \}
\end{lyxcode}
\input{line.tex}

\emph{Exception: WrongData if requested}


\subsection{\noindent void DeviceAttribute::exceptions(bitset<DeviceAttribute::numFlags>)}

\noindent Is a method which allows the user to switch on/off exception
throwing when trying to extract data from an empty DeviceAttribute
object or with a wrong data type. The following flags are supported
:
\begin{enumerate}
\item \noindent \textbf{isempty\_flag} - throw a WrongData exception (reason=
API\_EmptyDeviceAttribute) if user tries to extract data from an empty
DeviceAttribute object. By default, this flag is set.
\item \textbf{wrongtype\_flag} - throw a WrongData exception (reason = API\_IncompatibleAttrArgumentType)
if user tries to extract data with a type different than the type
used for insertion. By default, this flag is not set.
\item \textbf{failed\_flag} - throw an exception when the user try to extract
data from the DeviceAttribute object and an error was reported by
the server when the user try to read the attribute. The type of the
exception thrown is the type of the error reported by the server.
By default, this flag is set.
\item \textbf{unknown\_format\_flag} - throw an exception when the user
try to get the attribute data format from the DeviceAttribute object
when this information is not yet available. This information is available
only after the \emph{read\_attribute} call has been sucessfully executed.
The type of the exception thrown is WrongData exception (reason =
API\_EmptyDeviceAttribute). By default, this flag is not set.
\end{enumerate}

\subsection{bitset<DeviceAttribute::numFlags> exceptions()}

Return the whole exception flags.


\subsection{void DeviceAttribute::reset\_exceptions(DeviceAttribute::except\_flags
fl)}

Reset one exception flag


\subsection{void DeviceAttribute::set\_exceptions(DeviceAttribute::except\_flags
fl)}

Set one exception flag

The following is an example of how to use these exceptions related
methods

\input{line.tex}
\begin{lyxcode}
\noindent ~~~~~1~~DeviceAttribute~da;

~~~~~2~~

~~~~~3~~bitset<DeviceAttribute::numFlags>~bs~=~da.exceptions();

~~~~~4~~cout~<\textcompwordmark{}<~\textquotedbl{}bs~=~\textquotedbl{}~<\textcompwordmark{}<~bs~<\textcompwordmark{}<~endl;

~~~~~5~~~~~~~~~~~~~~~~~~

~~~~~6~~da.set\_exceptions(DeviceAttribute::wrongtype\_flag);

~~~~~7~~bs~=~da.exceptions();

~~~~~8~~~~~~~~~~~~~~~~~~

~~~~~9~~cout~<\textcompwordmark{}<~\textquotedbl{}bs~=~\textquotedbl{}~<\textcompwordmark{}<~bs~<\textcompwordmark{}<~endl;
\end{lyxcode}
\input{line.tex}


\subsection{bool DeviceAttribute::has\_failed()}

Returns a boolean set to true if the server report an error when the
attribute was read.


\subsection{const DevErrorList \&DeviceAttribute::get\_err\_stack()}

Returns the error stack reported by the server when the attribute
was read.

The following is an example of the three available ways to get data
out of a DeviceAttribute object.

\input{line.tex}
\begin{lyxcode}
\noindent ~~~~~1~~DeviceAttribute~da;

~~~~~2~~vector<short>~attr\_data;

~~~~~3~~

~~~~~4~~try

~~~~~5~~\{

~~~~~6~~~~~~da~=~device->read\_attribute(\textquotedbl{}Attr\textquotedbl{});

~~~~~7~~~~~~da~>\textcompwordmark{}>~attr\_data;

~~~~~8~~\}

~~~~~9~~catch~(DevFailed~\&e)

~~~~10~~\{

~~~~11~~~~~~....

~~~~12~~\}

~~~~13~~

~~~~14~~

~~~~15~~-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

~~~~16~~

~~~~17~~DeviceAttribute~da;

~~~~18~~vector<short>~attr\_data;

~~~~19~~

~~~~20~~da.reset\_exceptions(DeviceAttribute::failed\_flag);

~~~~21~~

~~~~22~~try

~~~~23~~\{

~~~~24~~~~~~da~=~device->read\_attribute(\textquotedbl{}Attr\textquotedbl{});

~~~~25~~\}

~~~~26~~catch~(DevFailed~\&e)

~~~~27~~\{

~~~~28~~~~~~.....

~~~~29~~\}

~~~~30~~

~~~~31~~if~(!(da~>\textcompwordmark{}>~attr\_data))

~~~~32~~\{

~~~~33~~~~~~DevErrorList~\&err~=~da.get\_err\_stack();

~~~~34~~~~~~.....

~~~~35~~\}

~~~~36~~else

~~~~37~~\{

~~~~38~~~~~~.....

~~~~39~~\}

~~~~40~~

~~~~41~~-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

~~~~42~~

~~~~43~~DeviceAttribute~da;

~~~~44~~vector<short>~attr\_data;

~~~~45~~

~~~~46~~try

~~~~47~~\{

~~~~48~~~~~~da~=~device->read\_attribute(\textquotedbl{}Attr\textquotedbl{});

~~~~49~~\}

~~~~50~~catch~(DevFailed~\&e)

~~~~51~~\{

~~~~52~~~~~~......

~~~~53~~\}

~~~~54~~

~~~~55~~if~(da.has\_failed())

~~~~56~~\{

~~~~57~~~~~~DevErrorList~\&err~=~da.get\_err\_stack();

~~~~58~~~~~~....

~~~~59~~\}

~~~~60~~else

~~~~61~~\{

~~~~62~~~~~~da~>\textcompwordmark{}>~attr\_data;~~~~~~~~

~~~~63~~\}
\end{lyxcode}
\input{line.tex}

The first way is coded between lines 1 and 13. It uses the default
behaviour of the DeviceAttribute object which is to throw an exception
when the user try to extract data when the server reports an error
when the attribute was read. The second way is coded between line
17 and 40. The DeviceAttribute object now does not throw \textquotedbl{}failed\textquotedbl{}
exception any more and the return value of the extractor operator
is checked. The third way is coded between line 43 and 63. In this
case, the attribute data validity is checked before trying to extract
them.


\subsection{string \&DeviceAttribute::get\_name()}

Returns the name of the attribute


\subsection{void DeviceAttribute::set\_name(string \&)}

Sets attribute name


\subsection{void DeviceAttribute::set\_name(const char {*})}

Sets attribute name


\subsection{AttrQuality \&DeviceAttribute::get\_quality()}

Returns the quality of the attribute: an enumerate type which can
be one of \{ATTR\_VALID, ATTR\_INVALID, ATTR\_ALARM, ATTR\_CHANGING
or ATTR\_WARNING\}.


\subsection{int DeviceAttribute::get\_dim\_x()}

Returns the attribute read x dimension


\subsection{int DeviceAttribute::get\_dim\_y()}

Returns the attribute read y dimension


\subsection{int DeviceAttribute::get\_written\_dim\_x()}

Returns the attribute write x dimension


\subsection{int DeviceAttribute::get\_written\_dim\_y()}

Returns the attribute write y dimension


\subsection{AttributeDimension DeviceAttribute::get\_r\_dimension()}

Returns the attribute read dimension


\subsection{AttributeDimension DeviceAttribute::get\_w\_dimension()}

Returns the attribute write dimension


\subsection{long DeviceAttribute::get\_nb\_read()}

Returns the number of read values


\subsection{long DeviceAttribute::get\_nb\_written()}

Returns the number of written values. Here is an example of these
last methods usage.

\input{line.tex}
\begin{lyxcode}
\noindent ~1~~DeviceAttribute~da;

~2~~vector<short>~attr\_data;

~3~~

~4~~try

~5~~\{

~6~~~~~da~=~device->read\_attribute(\textquotedbl{}Attr\textquotedbl{});

~7~~~~~da~>\textcompwordmark{}>~attr\_data;

~8~~\}

~9~~catch~(DevFailed~\&e)

10~~\{

11~~~~~....

12~~\}

13~~

14~~long~read~=~da.get\_nb\_read();

15~~long~written~=~da.get\_nb\_written();

16~~size\_t~size~=~attr\_data.size();

17~~

18~~for~(long~i~=~0;i~<~read;i++)

19~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Read~value~\textquotedbl{}~<\textcompwordmark{}<~i+1~<\textcompwordmark{}<~\textquotedbl{}~=~\textquotedbl{}~<\textcompwordmark{}<~attr\_data{[}i{]}~<\textcompwordmark{}<~~endl;

20

21~~int~ind;

22~~for~(long~j~=~0;~j~<~written;j++)

23~~\{

24~~~~~size~==~1~?~ind~=~j~:~ind~=~j~+~read;

25~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Last~written~value~\textquotedbl{}~<\textcompwordmark{}<~j+1~<\textcompwordmark{}<~\textquotedbl{}~=~\textquotedbl{}~<\textcompwordmark{}<~attr\_data{[}ind{]}~<\textcompwordmark{}<~endl;

26~~\}
\end{lyxcode}
\input{line.tex}

Line 24 is needed to cover the case of scalar write attribute where
only one value is returned but both get\_nb\_read() and get\_nb\_written()
methods return 1.


\subsection{TimeVal \&DeviceAttribute::get\_date()}

Returns a reference to the time when the attribute was read in server


\subsection{int DeviceAttribute::get\_type()}

Returns the type of the attribute data.


\subsection{AttrDataFormat DeviceAttribute::get\_data\_format()}

Returns the attribute data format. Note that this information is valid
only after the call to the device has been executed. Otherwise the
FMT\_UNKNOWN value of the AttrDataFormat enumeration is returned or
an exception is thrown according to the object exception flags.


\subsection{ostream \&operator<\textcompwordmark{}<(ostream \&, DeviceAttribute
\&)}

Is an utility function to easily print the contents of a DeviceAttribute
object. This function knows all types which could be inserted in a
DeviceAttribute object and print them accordingly if the data are
valid. It also prints the date returned within the attribute, the
attribute name, the dim\_x and dim\_y attribute parameter and its
quality factor.

\input{line.tex}
\begin{lyxcode}
\noindent DeviceProxy~{*}dev~=~new~DeviceProxy(\textquotedbl{}...\textquotedbl{});

DeviceAttribute~attr;

attr~=~dev->read\_attribute(\textquotedbl{}MyAttribute\textquotedbl{});



cout~<\textcompwordmark{}<~\textquotedbl{}Attribute~returned:~\textquotedbl{}~<\textcompwordmark{}<~attr~<\textcompwordmark{}<~endl;


\end{lyxcode}
\input{line.tex}


\section{Tango::DeviceAttributeHistory\label{AttributeHistory}}

This is the fundamental type for receiving data from device attribute
polling buffers. This class inherits from the Tango::DeviceAttribute
class. One instance of this class is created for each attribute result
history. Within this class, you find the attribute result data or
the exception parameters and a flag indicating if the attribute has
failed when it was invoked by the device server polling thread. For
history calls, it is not possible to returns attribute error as exception.
See chapter on Advanced Features for all details regarding device
polling. On top of the methods inherited from the DeviceAttribute
class, it offers the following methods


\subsection{ostream \&operator<\textcompwordmark{}<(ostream \&, DeviceAttributeHistory
\&)}

Is an utility function to easily print the contents of a DeviceAttributeHistory
object. This function knows all types which could be inserted in a
DeviceAttributeHistory object and print them accordingly. It also
prints date, attribute name, attribute dim\_x and dim\_y parameters,
attribute quality factor and error stack in case the attribute returned
an error.

\input{line.tex}
\begin{lyxcode}
\noindent DeviceProxy~{*}dev~=~new~DeviceProxy(``...'');

int~hist\_depth~=~4;

vector<DeviceAttributeHistory>~{*}hist;



hist~=~dev->attribute\_history(``MyAttribute'',hist\_depth);



for~(int~i~=~0;i~<~hist\_depth;i++)

\{

~~~~cout~<\textcompwordmark{}<~({*}hist){[}i{]}~<\textcompwordmark{}<~endl;

\}

delete~hist;


\end{lyxcode}
\input{line.tex}


\section{Tango::AttributeProxy()}

The high level object which provides the client with an easy-to-use
interface to TANGO device attributes. AttributeProxy is a handle to
the real Attribute (hence the name Proxy) and is not the real Attribute
(of course). The AttributeProxy manages timeouts, stateless connections
(new AttributeProxy() nearly always works), and reconnection if the
device server is restarted.


\subsection{Constructors}


\subsubsection{AttributeProxy::AttributeProxy(string \&name)}

Create an AttributeProxy to an attribute of the specified name. The
constructor will connect to the TANGO database, query for the device
to which the attribute belongs to network address and build a connection
to this device. If the device to which the attribute belongs to is
defined in the TANGO database but the device server is not running,
AttributeProxy will try to build a connection every time the client
tries to access the attribute. If an alias\index{alias} name is defined
for the attribute, this alias name can be used to create the AttributeProxy
instance. If a device name alias is defined for the device, it can
be used instead of the three fields device name. If the device to
which the attribute belongs to is not defined in the database, an
exception is thrown. Examples :

\input{line.tex}
\begin{lyxcode}
AttributeProxy~{*}my\_attr~=~new~AttributeProxy(\textquotedbl{}my/own/device/attr\textquotedbl{});

AttributeProxy~{*}my\_attr\_bis~=~new~AttributeProxy(\textquotedbl{}attr\_alias\textquotedbl{});

AttributeProxy~{*}my\_attr\_ter~=~new~AttributeProxy(\textquotedbl{}dev\_alias/attr\textquotedbl{});
\end{lyxcode}
\input{line.tex}

See appendix on device/attribute naming for all details about Tango
device or attribute naming syntax. 

\emph{Exception: WrongNameSyntax, ConnectionFailed}


\subsubsection{AttributeProxy::AttributeProxy(const char {*}name)}

Idem previous call


\subsection{Miscellaneous methods}


\subsubsection{DevState AttributeProxy::state()}

A method which returns the state of the device to which the attribute
belongs to. This state is returned as a Tango::DevState type. Example
:

\input{line.tex}
\begin{lyxcode}
dev\_state~=~my\_attr->state()~<\textcompwordmark{}<~endl;
\end{lyxcode}
\input{line.tex}

\emph{Exception: ConnectionFailed, CommunicationFailed}


\subsubsection{string AttributeProxy::status()}

A method which return the status of the device to which the attribute
belongs to. The status is returned as a string. Example :

\input{line.tex}
\begin{lyxcode}
cout~<\textcompwordmark{}<~\textquotedbl{}device~status\textquotedbl{}~<\textcompwordmark{}<~my\_attr->status()~<\textcompwordmark{}<~endl;
\end{lyxcode}
\input{line.tex}

\emph{Exception: ConnectionFailed, CommunicationFailed}


\subsubsection{int AttributeProxy::ping()}

A method which sends a ping to the device to which the attribute belongs
and returns the time elapsed in microseconds. Example :

\input{line.tex}
\begin{lyxcode}
cout~<\textcompwordmark{}<~\textquotedbl{}device~ping~took~\textquotedbl{}~<\textcompwordmark{}<~my\_device->ping()~<\textcompwordmark{}<~``~microseconds''~<\textcompwordmark{}<~endl;
\end{lyxcode}
\input{line.tex}

\emph{Exception: ConnectionFailed, CommunicationFailed}


\subsubsection{string AttributeProxy::name()}

Returns the attribute name


\subsubsection{DeviceProxy {*}get\_device\_proxy()}

Returns the DeviceProxy instance used to communicate with the device
to which the attributes belongs.
\begin{lyxcode}
\noindent 
\end{lyxcode}

\subsection{Synchronous related methods}


\subsubsection{AttributeInfo AttributeProxy::get\_config()}

Return the attribute configuration. AttributeInfo is a struct defined
as follows :

\input{line.tex}
\begin{lyxcode}
typedef~struct~\_AttributeInfo~\{~

~~~string~name;~

~~~AttrWriteType~writable;~

~~~AttrDataFormat~data\_format;~

~~~int~data\_type;~

~~~int~max\_dim\_x;~

~~~int~max\_dim\_y;~

~~~string~description;~

~~~string~label;~

~~~string~unit;~

~~~string~standard\_unit;~

~~~string~display\_unit;~

~~~string~format;~

~~~string~min\_value;~

~~~string~max\_value;~

~~~string~min\_alarm;~

~~~string~max\_alarm;~

~~~string~writable\_attr\_name;~

~~~vector<string>~extensions;~

~~~Tango::DispLevel~disp\_level;

\}~AttributeInfo;~
\end{lyxcode}
\input{line.tex}

\emph{Exception: ConnectionFailed, CommunicationFailed, DevFailed
from device}


\subsubsection{void AttributeProxy::set\_config(AttributeInfo \&)}

Change the attribute configuration.

\emph{Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked,
DevFailed from device}


\subsubsection{DeviceAttribute AttributeProxy::read()}

Read the attribute. To extract the value you have to use the operator
of the class DeviceAttribute which corresponds to the data type of
the attribute. NOTE: There is no automatic type conversion from the
attribute native type to user type e.g. if an attribute returns a
short you cannot extract it as a double (this will return 0) you have
to extract it as a short.

\emph{Exception: ConnectionFailed, CommunicationFailed, DevFailed
from device}


\subsubsection{void AttributeProxy::write(DeviceAttribute\&)}

Write the attribute. To insert the value to write you have to use
the operator of the class DeviceAttribute which corresponds to the
data type of the attribute. NOTE: There is no automatic type conversion
from the user type to the attribute native type e.g. if an attribute
expects a short you cannot insert it as a double (this will throw
an exception) you have to insert it as a short.

\emph{Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked,
DevFailed from device}


\subsubsection{DeviceAttribute AttributeProxy::write\_read(DeviceAttribute\&)}

Write then read a single attribute in a single network call. By default
(serialisation by device), the execution of this call in the server
can't be interrupted by other clients. To insert/extract the value
to write/read you have to use the operator of the class DeviceAttribute
which corresponds to the data type of the attribute. NOTE: There is
no automatic type conversion from the user type to the attribute native
type e.g. if an attribute expects a short you cannot insert it as
a double (this will throw an exception) you have to insert it as a
short.

\emph{Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked,
DevFailed from device}


\subsubsection{vector<DeviceAttributeHistory> {*}AttributeProxy::history(int)}

Retrieve attribute history from the attribute polling buffer. The
argument is the wanted history depth. This method returns a vector
of DeviceAttributeHistory types. This method allocates memory for
the vector of DeviceAttributeHistory returned to the caller. It is
the caller responsibility to delete this memory. Class DeviceAttributeHistory
is detailed on chapter \ref{AttributeHistory}See chapter on Advanced
Feature for all details regarding polling.

\input{line.tex}
\begin{lyxcode}
\noindent AttributeProxy~attr~=~new~AttributeProxy(\textquotedbl{}my/own/device/Current\textquotedbl{});~

vector<DeviceAttributeHistory>~{*}hist;

hist~=~attr->history(5);

\noindent for~(int~i~=~0;i~<~5;i++)~

\noindent \{

\noindent 

~~~~bool~fail~=~({*}hist){[}i{]}.has\_failed();

~~~~if~(fail~==~false)

~~~~\{

~~~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Attribute~name~=~\textquotedbl{}~<\textcompwordmark{}<~({*}hist){[}i{]}.get\_name()~<\textcompwordmark{}<~endl;

~~~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Attribute~quality~factor~=~\textquotedbl{}~<\textcompwordmark{}<~({*}hist){[}i{]}.get\_quality()~<\textcompwordmark{}<~endl;

~~~~~~~~long~value;

~~~~~~~~({*}hist){[}i{]}~>\textcompwordmark{}>~value;

~~~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Current~=~\textquotedbl{}~<\textcompwordmark{}<~value~<\textcompwordmark{}<~endl;

~~~~\}

~~~~else

~~~~\{

~~~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Attribute~failed~!\textquotedbl{}~<\textcompwordmark{}<~endl;

~~~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Error~level~0~desc~=~\textquotedbl{}~<\textcompwordmark{}<~(({*}hist){[}i{]}.get\_err\_stack()){[}0{]}.desc~<\textcompwordmark{}<~endl;

~~~~\}

~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Date~=~\textquotedbl{}~<\textcompwordmark{}<~({*}hist){[}i{]}.get\_date().tv\_sec~<\textcompwordmark{}<~endl;

\noindent \}

delete~hist;
\end{lyxcode}
\input{line.tex}

\emph{Exception:} \emph{NonSupportedFeature, ConnectionFailed, CommunicationFailed,
DevFailed from device}
\begin{lyxcode}



\end{lyxcode}

\subsection{Asynchronous methods}


\subsubsection{long AttributeProxy::read\_asynch()}

Read the attribute asynchronously (polling model). This call returns
an \emph{asynchronous call identifier} which is needed to get the
attribute value.

\emph{Exception: ConnectionFailed}


\subsubsection{DeviceAttribute {*}AttributeProxy::read\_reply(long id)}

Check if the answer of an asynchronous read is arrived (polling model).
id is the asynchronous call identifier. If the reply is arrived and
if it is a valid reply, it is returned to the caller in a DeviceAttribute
object. If the reply is an exception, it is re-thrown by this call.
An exception is also thrown in case of the reply is not yet arrived.
To extract attribute value, you have to use the operator of the class
DeviceAttribute which corresponds to the data type of the attribute.
NOTE: There is no automatic type conversion from the attribute native
type to user type e.g. if an attribute returns a short you cannot
extract it as a double, you have to extract it as a short. Memory
has been allocated for the DeviceAttribute object returned to the
caller. This is the caller responsibility to delete this memory.

\emph{Exception:} \emph{AsynCall, AsynReplyNotArrived, CommunicationFailed,
DevFailed from device}


\subsubsection{DeviceAttribute {*}AttributeProxy::read\_reply(long id, long timeout)}

Check if the answer of an asynchronous read is arrived (polling model).
id is the asynchronous call identifier. If the reply is arrived and
if it is a valid reply, it is returned to the caller in a DeviceAttribute
object. If the reply is an exception, it is re-thrown by this call.
If the reply is not yet arrived, the call will wait (blocking the
process) for the time specified in timeout. If after timeout milliseconds,
the reply is still not there, an exception is thrown. If timeout is
set to 0, the call waits until the reply arrived. To extract attribute
value, you have to use the operator of the class DeviceAttribute which
corresponds to the data type of the attribute. NOTE: There is no automatic
type conversion from the attribute native type to user type e.g. if
an attribute returns a short you cannot extract it as a double, you
have to extract it as a short. Memory has been allocated for the DeviceAttribute
object returned to the caller. This is the caller responsibility to
delete this memory.

\emph{Exception:} \emph{AsynCall, AsynReplyNotArrived, CommunicationFailed,
DevFailed from device}


\subsubsection{long AttributeProxy::write\_asynch(DeviceAttribute \&argin)}

Write the attribute asynchronously (polling model). To insert the
value to write you have to use the operator of the class DeviceAttribute
which corresponds to the data type of the attribute. NOTE: There is
no automatic type conversion from the user type to the attribute native
type e.g. if an attribute expects a short you cannot insert it as
a double (this will throw an exception) you have to insert it as a
short. This call returns an \emph{asynchronous call identifier} which
is needed to get the server reply.

\emph{Exception:} \emph{ConnectionFailed}


\subsubsection{void AttributeProxy::write\_reply(long id)}

Check if the answer of an asynchronous write is arrived (polling model).
id is the asynchronous call identifier. If the reply is arrived and
if it is a valid reply, the call returned. If the reply is an exception,
it is re-thrown by this call. An exception is also thrown in case
of the reply is not yet arrived.

\emph{Exception:} \emph{AsynCall, AsynReplyNotArrived, CommunicationFailed,
DevFailed from device}


\subsubsection{void AttributeProxy::write\_reply(long id, long timeout)}

Check if the answer of an asynchronous write is arrived (polling model).
id is the asynchronous call identifier. If the reply is arrived and
if it is a valid reply, the call returned. If the reply is an exception,
it is re-thrown by this call. If the reply is not yet arrived, the
call will wait (blocking the process) for the time specified in timeout.
If after timeout milliseconds, the reply is still not there, an exception
is thrown. If timeout is set to 0, the call waits until the reply
arrived.

\emph{Exception:} \emph{AsynCall, AsynReplyNotArrived, CommunicationFailed,
DevFailed from device}


\subsubsection{void AttributeProxy::read\_asynch(CallBack \&cb)}

Read the attribute asynchronously using the callback model. The argument
is a reference to a callback object. This callback object should be
an instance of a user class inheriting from the \emph{Tango::CallBack}
class with the \emph{attr\_read()} method overloaded.

\emph{Exception:} \emph{ConnectionFailed}


\subsubsection{void AttributeProxy::write\_asynch(DeviceAttribute \&argin, CallBack
\&cb)}

Write the attribute asynchronously using the callback model. The argument
is a reference to a callback object. This callback object should be
an instance of a user class inheriting from the \emph{Tango::CallBack}
class with the \emph{attr\_written()} method overloaded.

\emph{Exception:} \emph{ConnectionFailed}


\subsection{Polling related methods}


\subsubsection{bool AttributeProxy::is\_polled()}

Returns true if the attribute is polled. Otherwise, returns false.


\subsubsection{int AttributeProxy::get\_poll\_period()}

Returns the attribute polling period in mS. If the attribute is not
polled, it returns 0.


\subsubsection{void AttributeProxy::poll(int period)}

Add the attribute to the list of polled attributes. The polling period
is specified by \textquotedbl{}period\textquotedbl{} (in mS). If the
attribute is already polled, this method will update the polling period
according to \textquotedbl{}period\textquotedbl{}.


\subsubsection{void AttributeProxy::stop\_poll()}

Remove attribute from the list of polled attributes.


\subsection{Event related methods}


\subsubsection{int AttributeProxy::subscribe\_event(EventType event, CallBack {*}cb)}

The client call to subscribe for event reception in the \textbf{push
model}. The client implements a callback method which is triggered
when the event is received either by polling or a dedicated thread.
Filtering is done based on the reason specified and the event type.
For example when reading the state and the reason specified is \textquotedbl{}change\textquotedbl{}
the event will be fired only when the state changes. Events consist
of an attribute name and the event reason. A standard set of reasons
are implemented by the system, additional device specific reasons
can be implemented by device servers programmers.

The \emph{event} parameter is the event reason and must be on the
enumerated values:
\begin{itemize}
\item Tango::CHANGE\_EVENT
\item Tango::PERIODIC\_EVENT
\item Tango::ARCHIVE\_EVENT
\item Tango::ATTR\_CONF\_EVENT
\end{itemize}
\emph{cb} is a pointer to a class inheriting from the Tango CallBack
class and implementing a \emph{push\_event()} method, \emph{filters}
is a variable list of name,value pairs which define additional filters
for events. The \emph{subscribe\_event()} call returns an event id
which has to be specified when unsubscribing from this event.

\emph{Exception:} \emph{EventSystemFailed}

Note: For releases prior to Tango 8, a similar call with a third argument
(const vector<string> \&filters) was available. This extra argument
gave the user a way to define extra event filtering. For compatibility
reason, this call still exist but the extra filtering features is
not implemented.


\subsubsection{int AttributeProxy::subscribe\_event(EventType event, CallBack {*}cb,
bool stateless)}

This subscribe event method has the same functionality as described
in the last section. It adds an additional flag called \emph{stateless}.
When the \emph{stateless} flag is set to \emph{false}, an exception
will be thrown when the event subscription encounters a problem. 

With the \emph{stateless} flag set to \emph{true}, the event subscription
will always succeed, even if the corresponding device server is not
running. The keep alive thread will try every 10 seconds to subscribe
for the specified event. At every subscription retry, a callback is
executed which contains the corresponding exception.

\emph{Exception: EventSystemFailed}

Note: For releases prior to Tango 8, a similar call with a forth argument
(const vector<string> \&filters) was available. This extra argument
gave the user a way to define extra event filtering and it was the
third argument in the argument list. For compatibility reason, this
call still exist but the extra filtering features is not implemented.


\subsubsection{int AttributeProxy::subscribe\_event(EventType event, int event\_queue\_size,
bool stateless)}

The client call to subscribe for event reception in the \textbf{pull
model}. Instead of a callback method the client has to specify the
size of the event reception buffer.

The event reception buffer is implemented as a round robin buffer.
This way the client can set-up different ways to receive events.

Event reception buffer size = 1 : The client is interested only in
the value of the last event received. All other events that have been
received since the last reading are discarded.

Event reception buffer size > 1 : The client has chosen to keep an
event history of a given size. When more events arrive since the last
reading, older events will be discarded.

Event reception buffer size = ALL\_EVENTS : The client buffers all
received events. The buffer size is unlimited and only restricted
by the available memory for the client.

All other parameters are similar to the descriptions given in the
last two sections.

\emph{Exception: EventSystemFailed}

Note: For releases prior to Tango 8, a similar call with a forth argument
(const vector<string> \&filters) was available. This extra argument
gave the user a way to define extra event filtering and it was the
third argument in the argument list. For compatibility reason, this
call still exist but the extra filtering features is not implemented.


\subsubsection{void AttributeProxy::unsubscribe\_event(int event\_id)}

Unsubscribe a client from receiving the event specified by \emph{event\_id}.
\emph{event\_id} is the event identifier returned by the \emph{AttributeProxy::subscribe\_event()}
method.

\emph{Exception:} \emph{EventSystemFailed}


\subsubsection{void AttributeProxy::get\_events(int event\_id, CallBack {*}cb)}

The method extracts all waiting events from the event reception buffer
and executes the callback method cb for every event. During event
subscription the client must have chosen the pull model for this event.
event\_id is the event identifier returned by the AttributeProxy::subscribe\_event()
method.

\emph{Exception: EventSystemFailed}


\subsubsection{void AttributeProxy::get\_events(int event\_id, EventDataList \&event\_list)}

The method extracts all waiting events from the event reception buffer.
The returned event\_list is a vector of EventData pointers. The EventData
object contains the event information as for the callback methods. 

During event subscription the client must have chosen the pull model
for this event. event\_id is the event identifier returned by the
AttributeProxy::subscribe\_event() method.

\emph{Exception: EventSystemFailed}


\subsubsection{void AttributeProxy::get\_events(int event\_id, AttrConfEventDataList
\&event\_list)}

The method extracts all waiting attribute configuration events from
the event reception buffer. The returned event\_list is a vector of
AttrConfEventData pointers. The AttrConfEventData object contains
the event information as for the callback methods. 

During event subscription the client must have chosen the pull model
for this event. event\_id is the event identifier returned by the
AttributeProxy::subscribe\_event() method.

\emph{Exception: EventSystemFailed}


\subsubsection{int AttributeProxy::event\_queue\_size(int event\_id)}

Returns the number of stored events in the event reception buffer.
After every call to DeviceProxy:get\_events(), the event queue size
is 0.

During event subscription the client must have chosen the pull model
for this event. event\_id is the event identifier returned by the
AttributeProxy::subscribe\_event() method.

\emph{Exception: EventSystemFailed}


\subsubsection{TimeVal AttributeProxy::get\_last\_event\_date(int event\_id)}

Returns the arrival time of the last event stored in the event reception
buffer. After every call to DeviceProxy:get\_events(), the event reception
buffer is empty. In this case an exception will be returned.

During event subscription the client must have chosen the pull model
for this event. event\_id is the event identifier returned by the
AttributeProxy::subscribe\_event() method.

\emph{Exception: EventSystemFailed}


\subsubsection{bool AttributeProxy::is\_event\_queue\_empty(int event\_id)}

Returns true when the event reception buffer is empty.

During event subscription the client must have chosen the pull model
for this event. event\_id is the event identifier returned by the
AttributeProxy::subscribe\_event() method.

\emph{Exception: EventSystemFailed}


\subsection{Property related methods}


\subsubsection{void AttributeProxy::get\_property (string\&, DbData\&)}

Get a single property for the attribute. The property to get is specified
as a string. Refer to DbDevice::get\_property() and DbData sections
below for details on the DbData type.

\emph{Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
(with database), DevFailed from database device}


\subsubsection{void AttributeProxy::get\_property (vector<string>\&, DbData\&)}

Get a list of properties for the attribute. The properties to get
are specified as a vector of strings. Refer to DbDevice::get\_property()
and DbData sections below for details on the DbData type.

\emph{Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
(with database), DevFailed from database device}


\subsubsection{void AttributeProxy::get\_property(DbData\&)}

Get property(ies) for the attribute. Properties to get are specified
using the DbData type. Refer to DbDevice::get\_property() and DbData
sections below for details.

\emph{Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
(with database), DevFailed from database device}


\subsubsection{void AttributeProxy::put\_property(DbData\&)}

Put property(ies) for an attribute. Properties to put are specified
using the DbData type. Refer to DbDevice::put\_property() and DbData
sections below for details.

\emph{Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
(with database), DevFailed from database device}


\subsubsection{void AttributeProxy::delete\_property (string\&, DbData\&)}

Delete a single property for an attribute. The property to delete
is specified as a string. Refer to DbDevice::delete\_property() and
DbData sections below for details on the DbData type.

\emph{Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
(with database), DevFailed from database device}


\subsubsection{void AttributeProxy::delete\_property (vector<string>\&, DbData\&)}

Delete a list of properties for an attribute. The properties to delete
are specified as a vector of strings. Refer to DbDevice::get\_property()
and DbData sections below for details on the DbData type.

\emph{Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
(with database), DevFailed from database device}


\subsubsection{void AttributeProxy::delete\_property(DbData\&)}

Delete property(ies) for an attribute. Properties to delete are specified
using the DbData type. Refer to DbDevice::get\_property() and DbData
sections below for details.

\emph{Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
(with database), DevFailed from database device}


\section{Tango::ApiUtil\label{sec:Tango::ApiUtil}}

This class is a singleton. Therefore, it is not necessary to create
it. It will be automatically done. A static method allows a user to
retrieve the instance


\subsection{static ApiUtil {*}ApiUtil::instance()}

Return the ApiUtil singleton instance.


\subsection{static void ApiUtil::cleanup()}

Destroy the ApiUtil singleton instance.


\subsection{long ApiUtil::pending\_asynch\_call(asyn\_req\_type req)}

Return number of asynchronous pending requests (any device). The input
parameter is an enumeration with three values which are:
\begin{lyxlist}{00.00.0000}
\item [{POLLING}] : Return only polling model asynchronous request number
\item [{CALL\_BACK}] : Return only callback model asynchronous request
number
\item [{ALL\_ASYNCH}] : Return all asynchronous request number
\end{lyxlist}
\emph{Exception: None}


\subsection{void ApiUtil::get\_asynch\_replies()}

Fire callback methods for all (any device) asynchronous requests (command
and attribute) with already arrived replied. Returns immediately if
there is no replies already arrived or if there is no asynchronous
requests.

\emph{Exception: None, all errors are reported using the err and errors
fields of the parameter passed to the callback method. See chapter
\ref{sec:Asynchronous-callback-related} for details.}


\subsection{void ApiUtil::get\_asynch\_replies(long timeout)}

Fire callback methods for all (any device) asynchronous requests (command
and attributes) with already arrived replied. Wait and block the caller
for timeout milliseconds if they are some device asynchronous requests
which are not yet arrived. Returns immediately if there is no asynchronous
request. If timeout is set to 0, the call waits until all the asynchronous
requests sent has received a reply.

\emph{Exception: AsynReplyNotArrived. All other errors are reported
using the err and errors fields of the object passed to the callback
methods. See chapter \ref{sec:Asynchronous-callback-related} for
details.}


\subsection{void ApiUtil::set\_asynch\_cb\_sub\_model(cb\_sub\_model model)}

Set the asynchronous callback sub-model between the pull and push
sub-model. See chapter \ref{sec:Request-model} to read the definition
of these sub-model. The cb\_sub\_model data type is an enumeration
with two values which are :
\begin{lyxlist}{00.00.0000}
\item [{PUSH\_CALLBACK}] : The push sub-model
\item [{PULL\_CALLBACK}] : The pull sub-model
\end{lyxlist}
By default, all Tango client using asynchronous callback model are
in pull sub-model. This call must be used to switch to the push sub-model.
NOTE that in push sub-model, a separate thread is spawned to deal
with server replies.

\emph{Exception: None}


\subsection{cb\_sub\_model ApiUtil::get\_asynch\_cb\_sub\_model()}

Get the asynchronous callback sub-model.

\emph{Exception: None}


\subsection{static int ApiUtil::get\_env\_var(const char {*}name,string \&value)}

Get environment variable. On Unixes OS, this call tries to get the
variable in the caller environment then in a file \emph{.tangorc\index{tangorc}}
in the user home directory and finally in a file \emph{/etc/tangorc}.
On Windows, this call looks in the user environment then in a file
stored in \%TANGO\_HOME\%/tangorc. This method returns 0 of the environment
variable is found. Otherwise, it returns -1.

\emph{Exception: None}


\subsection{void set\_event\_buffer\_hwm(DevLong val)}

Set the client event buffer high water mark (HWM\index{HWM})


\section{Asynchronous callback related classes\label{sec:Asynchronous-callback-related}}


\subsection{Tango::CallBack}

When using the event push model (callback automatically executed),
there are some cases (same callback used for events coming from different
devices hosted in device server process running on different hosts)
where the callback method could be executed concurently by different
threads started by the ORB. The user has to code his callback method
in a \textbf{thread}\index{thread} \textbf{safe} manner.


\subsubsection{void CallBack::cmd\_ended(CmdDoneEvent {*}event)}

This method is defined as being empty and must be overloaded by the
user when the asynchronous callback model is used. This is the method
which will be executed when the server reply from a command\_inout
is received in both push and pull sub-mode.


\subsubsection{void CallBack::attr\_read(AttrReadEvent {*}event)}

This method is defined as being empty and must be overloaded by the
user when the asynchronous callback model is used. This is the method
which will be executed when the server reply from a read\_attribute(s)
is received in both push and pull sub-mode.


\subsubsection{void CallBack::attr\_written(AttrWrittenEvent {*}event)}

This method is defined as being empty and must be overloaded by the
user when the asynchronous callback model is used. This is the method
which will be executed when the server reply from a write\_attribute(s)
is received in both push and pull sub-mode.


\subsubsection{void CallBack::push\_event(EventData {*}event)}

This method is defined as being empty and must be overloaded by the
user when events are used. This is the method which will be executed
when the server send event(s) to the client.


\subsubsection{void CallBack::push\_event(AttrConfEventData {*}event)}

This method is defined as being empty and must be overloaded by the
user when events are used. This is the method which will be executed
when the server send attribute configuration change event(s) to the
client.


\subsubsection{void CallBack::push\_event(DataReadyEventData {*}event)}

This method is defined as being empty and must be overloaded by the
user when events are used. This is the method which will be executed
when the server send attribute data ready event(s) to the client.


\subsection{Tango::CmdDoneEvent}

This class is used to pass data to the callback method in asynchronous
callback model for command execution. It contains the following public
field
\begin{lyxlist}{00.00.0000}
\item [{device}] : The DeviceProxy object on which the call was executed
(Tango::DeviceProxy {*})
\item [{cmd\_name}] : The command name (string \&)
\item [{argout}] : The command argout (DeviceData \&)
\item [{err}] : A boolean flag set to true if the command failed. False
otherwise (bool)
\item [{errors}] : The error stack (DevErrorList \&)
\end{lyxlist}

\subsection{Tango::AttrReadEvent}

This class is used to pass data to the callback method in asynchronous
callback model for read\_attribute(s) execution. It contains the following
public field
\begin{lyxlist}{00.00.0000}
\item [{device}] : The DeviceProxy object on which the call was executed
(Tango::DeviceProxy {*})
\item [{attr\_names}] : The attribute name list (vector<string> \&)
\item [{argout}] : The attribute data (vector<DeviceAttribute> {*})
\item [{err}] : A boolean flag set to true if the request failed. False
otherwise (bool)
\item [{errors}] : The error stack (DevErrorList \&)
\end{lyxlist}
To extract attribute value(s), you have to use the operator of the
class DeviceAttribute which corresponds to the data type of the attribute.
NOTE: There is no automatic type conversion from the attribute native
type to user type e.g. if an attribute returns a short you cannot
extract it as a double, you have to extract it as a short. Memory
has been allocated for the vector of DeviceAttribute objects passed
to the caller. This is the caller responsibility to delete this memory.


\subsection{Tango::AttrWrittenEvent}

This class is used to pass data to the callback method in asynchronous
callback model for write\_attribute(s) execution. It contains the
following public field
\begin{lyxlist}{00.00.0000}
\item [{device}] : The DeviceProxy object on which the call was executed
(Tango::DeviceProxy {*})
\item [{attr\_names}] : The attribute name list (vector<string> \&)
\item [{err}] : A boolean flag set to true if the request failed. False
otherwise (bool)
\item [{errors}] : The error stack (DevErrorList \&)
\end{lyxlist}

\subsection{Tango::EventData}

This class is used to pass data to the callback method when an event
is sent to the client. It contains the following public field
\begin{lyxlist}{00.00.0000}
\item [{device}] : The DeviceProxy object on which the call was executed
(Tango::DeviceProxy {*})
\item [{attr\_name}] : The attribute name (std::string \&)
\item [{event}] : The event name (std::string \&)
\item [{attr\_value}] : The attribute data (DeviceAttribute {*})
\item [{err}] : A boolean flag set to true if the request failed. False
otherwise (bool)
\item [{errors}] : The error stack (DevErrorList \&)
\end{lyxlist}
To extract attribute value(s), you have to use the operator of the
class DeviceAttribute which corresponds to the data type of the attribute.
NOTE: There is no automatic type conversion from the attribute native
type to user type e.g. if an attribute returns a short you cannot
extract it as a double, you have to extract it as a short. Memory
has been allocated for the vector of DeviceAttribute objects passed
to the caller. This is the caller responsibility to delete this memory.


\subsection{Tango::AttrConfEventData}

This class is used to pass data to the callback method when an attribute
configuration event is sent to the client. It contains the following
public field
\begin{lyxlist}{00.00.0000}
\item [{device}] : The DeviceProxy object on which the call was executed
(Tango::DeviceProxy {*})
\item [{attr\_name}] : The attribute name (std::string \&)
\item [{event}] : The event name (std::string \&)
\item [{attr\_conf}] : The attribute configuration (AttributeInfoEx {*})
\item [{err}] : A boolean flag set to true if the request failed. False
otherwise (bool)
\item [{errors}] : The error stack (DevErrorList \&)
\end{lyxlist}

\subsection{Tango::DataReadyEventData\index{DataReadyEventData}}

This class is used to pass data to the callback method when an attribute
data ready event is sent to the client. It contains the following
public field
\begin{lyxlist}{00.00.0000}
\item [{device}] : The DeviceProxy object on which the call was executed
(Tango::DeviceProxy {*})
\item [{attr\_name}] : The attribute name (std::string \&)
\item [{event}] : The event name (std::string \&)
\item [{attr\_data\_type}] :The attribute data type (int)
\item [{ctr}] : The user counter. Set to 0 if not defined when sent by
the server (int)
\item [{err}] : A boolean flag set to true if the request failed. False
otherwise (bool)
\item [{errors}] : The error stack (DevErrorList \&)
\end{lyxlist}

\section{Tango::Group}


\subsection{Constructor and Destructor}


\subsubsection{Group::Group (const std::string\& name)}

Instanciate an empty group. The group name allows retrieving a sub-group
in the hierarchy. 

See also: Group::\textasciitilde{}Group(), Group::get\_group(). 


\subsubsection{Group::\textasciitilde{}Group ()}

Delete a group and all its elements. 

Be aware that a group always gets the ownership of its children and
deletes them when it is itself deleted. Therefore, never try to delete
a Group (respectively a DeviceProxy) returned by a call to \emph{Tango::Group::get\_group()}
(respectively to \emph{Tango::Group::get\_device()}). Use the \emph{Tango::Group::remove()}
method instead.

See also: Group::Group(), Group::remove(), Group::remove\_all(). 


\subsection{Group Management Related Methods}


\subsubsection{void Group::add (Group{*} group, int timeout\_ms = -1)}

Attaches a (sub)group. 

Be aware that a group always gets the ownership of its children and
deletes them when it is itself deleted. Therefore, never try to delete
a Group attached to a Group. Use the \emph{Group::remove()} method
instead.

If \emph{timeout\_ms} parameter is different from -1, the client side
timeout associated to each device composing the group added is set
to \emph{timeout\_ms} milliseconds. If \emph{timeout\_ms} is -1, timeouts
are not changed.

This method does nothing if the specified group is already attached
(i.e. it is silently ignored) and \emph{timeout\_ms} = -1.

If the specified group is already attached and \emph{timeout\_ms}
is different from -1, the client side timeout of each device composing
the group given in parameter is set to \emph{timeout\_ms} milliseconds.

See also: all other forms of Group::add() and Group::set\_timeout\_millis().


\subsubsection{void Group::add (const std::string\& pattern, int timeout\_ms = -1)}

Attaches any device which name matches the specified \emph{pattern}. 

The pattern parameter can be a simple device name or a device name
pattern (e.g. domain\_{*}/ family/member\_{*}).

This method first asks to the Tango database the list of device names
matching the pattern. Devices are then attached to the group in the
order in which they are returned by the database.

Any device already present in the hierarchy (i.e. a device belonging
to the group or to one of its subgroups) is silently ignored but its
client side timeout is set to \emph{timeout\_ms} milliseconds if \emph{timeout\_ms}
is different from -1.

Set the client side timeout of each device matching the specified
\emph{pattern} to \emph{timeout\_ms} milliseconds if \emph{timeout\_ms}
is different from -1.

See also: all other forms of Group::add() and Group::set\_timeout\_millis().


\subsubsection{void Group::add (const std::vector<std::string>\& patterns, int timeout\_ms
= -1)}

Attaches any device which name matches one of the specified patterns. 

The \emph{patterns} parameter can be an array of device names and/or
device name patterns.

This method first asks to the Tango database the list of device names
matching one the patterns. Devices are then attached to the group
in the order in which they are returned by the database.

Any device already present in the hierarchy (i.e. a device belonging
to the group or to one of its subgroups), is silently ignored but
its client side timeout is set to \emph{timeout\_ms} milliseconds
if \emph{timeout\_ms} is different from -1.

If \emph{timeout\_ms} is different from -1, the client side timeouts
of all devices matching the specified \emph{patterns} are set to \emph{timeout\_ms}
milliseconds.

See also: all other forms of Group::add() and Group::set\_timeout\_millis().


\subsubsection{void Group::remove (const std::string\& pattern, bool fwd = true)}

Removes any group or device which name matches the specified pattern. 

The \emph{pattern} parameter can be a group name, a device name or
a device name pattern (e.g domain\_{*}/family/member\_{*}). 

Since we can have groups with the same name in the hierarchy, a group
name can be fully qualified to specify which group should be removed.
Considering the following group:
\begin{lyxcode}
->~gauges~

~~~|~->~cell-01~

~~~|~~~~~|->~penning~

~~~|~~~~~|~~~~|->~...

~~~|~~~~~|->~pirani

~~~|~~~~~~~~~~|->~...

~~~|~->~cell-02

~~~|~~~~~|->~penning

~~~|~~~~~|~~~~|->~...

~~~|~~~~~|->~pirani

~~~|~~~~~~~~~~|->~...

~~~|~->~cell-03

~~~|~~~~~|->~...~

~~~|~~~~~

~~~|~->~...~
\end{lyxcode}
A call to gauges->remove(\textquotedbl{}penning\textquotedbl{}) will
remove any group named \textquotedbl{}penning\textquotedbl{} in the
hierarchy while gauges->remove(\textquotedbl{}gauges.cell-02.penning\textquotedbl{})
will only remove the specified group.

If \emph{fwd} is set to true (the default), the remove request is
also forwarded to subgroups. Otherwise, it is only applied to the
local set of elements. For instance, the following code remove any
stepper motor in the hierarchy:
\begin{lyxcode}
root\_group->remove(\textquotedbl{}{*}/stepper\_motor/{*}\textquotedbl{});
\end{lyxcode}
See also: all other forms of Group::remove(). 


\subsubsection{void Group::remove (const std::vector<std::string>\& patterns, bool
fwd = true)}

Removes any group or device which name matches the specified patterns. 

The \emph{patterns} parameter can be an array of group names and/or
device names and/or device name patterns.

Since we can have groups with the same name in the hierarchy, a group
name can be fully qualified to specify which group should be removed.
See previous method for details.

If \emph{fwd} is set to true (the default), the remove request is
also forwarded to subgroups. Otherwise, it is only applied to the
local set of elements. 

See also: all other forms of Group::remove(). 


\subsubsection{void Group::remove\_all (void)}

Removes all elements in the group. After such a call, the group is
empty.

See also: all forms of Group::remove(). 


\subsubsection{bool Group::contains (const std::string\& pattern, bool fwd = true)}

Returns true if the hierarchy contains groups and/or devices which
name matches the specified \emph{pattern}. Returns false otherwise. 

The pattern can be a fully qualified or simple group name, a device
name or a device name pattern.

If \emph{fwd} is set to true (the default), the request is also forwarded
to subgroups. Otherwise, it is only applied to the local set of elements. 

See also: Group::get\_device(), Group::get\_group(). 


\subsubsection{DeviceProxy{*} Group::get\_device (const std::string\& device\_name)}

Returns a reference to the specified device or NULL if there is no
device by that name in the group. This method may throw an exception
in case the specified device belongs to the group but can't be reached
(not registered, down...). See example below. See also the Tango::DeviceProxy
class documentation for details.

\input{line.tex}
\begin{lyxcode}
\noindent try

\{

~~Tango::DeviceProxy~{*}dp~=~g->get\_device(\textquotedbl{}my/device/01\textquotedbl{});

~~if~(dp~==~0)

~~\{

//~my/device/01~doe~snot~belongs~to~the~group

~~\{

\}

catch~(const~Tango::DevFailed~\&df)

\{

//~my/device/01~belongs~to~the~group~but~can't~be~reached

\}
\end{lyxcode}
\input{line.tex}

The request is systematically forwarded to subgroups (i.e. if no device
named device\_name could be found in the local set of devices, the
request is forwarded to subgroups). 

Be aware that a group always gets the ownership of its children and
deletes them when it is itself deleted. Therefore, never try to delete
a DeviceProxy returned by the \emph{Group::get\_device()} method.
Use the \emph{Tango::Group::remove()} method instead.

See also: other form of Group::get\_device(), Group::get\_size(),
Group::get\_group(), Group::contains(). 


\subsubsection{DeviceProxy{*} Group::get\_device (long idx)}

Returns a reference to the \textquotedbl{}idx-th\textquotedbl{} device
in the hierarchy or NULL if the hierarchy contains less than \textquotedbl{}\emph{idx}\textquotedbl{}
devices. This method may throw an exception in case the specified
device belongs to the group but can't be reached (not registered,
down...). See previous example. See also the Tango::DeviceProxy class
documentation for details.

The request is systematically forwarded to subgroups (i.e. if the
local set of devices contains less than \textquotedbl{}idx\textquotedbl{}
devices, the request is forwarded to subgroups). 

Be aware that a group always gets the ownership of its children and
deletes them when it is itself deleted. Therefore, never try to delete
a DeviceProxy returned by the \emph{Group::get\_device()} method.
Use the \emph{Tango::Group::remove()} method instead.

See also: other form of Group::get\_device(), Group::get\_size(),
Group::get\_group, Group::contains(). 


\subsubsection{DeviceProxy{*} Group::operator{[}{]} (long i)}

Returns a reference to the \textquotedbl{}idx-th\textquotedbl{} device
in the hierarchy or NULL if the hierarchy contains less than \textquotedbl{}idx\textquotedbl{}
devices. See the Tango::DeviceProxy class documentation for details.

The request is systematically forwarded to subgroups (i.e. if the
local set of devices contains less than \textquotedbl{}idx\textquotedbl{}
devices, the request is forwarded to subgroups).

Be aware that a group always gets the ownership of its children and
deletes them when it is itself deleted. Therefore, never try to delete
a DeviceProxy returned by the \emph{Group::get\_device()} method.
Use the \emph{Tango::Group::remove()} method instead.

See also: other form of Group::get\_device(), Group::get\_size(),
Group::get\_group(), Group::contains(). 


\subsubsection{Group{*} Group::get\_group (const std::string\& group\_name)}

Returns a reference to the specified group or NULL if there is no
group by that name. The group\_name can be a fully qualified name. 

Considering the following group:
\begin{lyxcode}
->~gauges

~~~~|->~cell-01

~~~~|~~~~|->~penning

~~~~|~~~~|~~~~|->~...~

~~~~|~~~~|->~pirani

~~~~|~~~~|->~...~

~~~~|->~cell-02

~~~~|~~~~|->~penning

~~~~|~~~~|~~~~|->~...

~~~~|~~~~|->~pirani

~~~~|~~~~|->~...

~~~~|~->~cell-03

~~~~|~~~~|->~...

~~~~|

~~~~|~->~...~
\end{lyxcode}
A call to gauges->get\_group(\textquotedbl{}penning\textquotedbl{})
returns the first group named \textquotedbl{}penning\textquotedbl{}
in the hierarchy (i.e. gauges.cell-01.penning) while gauges->get\_group(\textquotedbl{}gauges.cell-02.penning'')
returns the specified group.

The request is systematically forwarded to subgroups (i.e. if no group
named group\_name could be found in the local set of elements, the
request is forwarded to subgroups). 

Be aware that a group always gets the ownership of its children and
deletes them when it is itself deleted. Therefore, never try to delete
a Group returned by the \emph{Group::get\_group()} method. Use the
\emph{Tango::Group::remove()} method instead.

See also: Group::get\_device(), Group::contains(). 


\subsubsection{long Group::get\_size (bool fwd = true)}

Return the number of devices in the hierarchy (respectively the number
of device in the group) if the forward option is set to true (respectively
set to false). 


\subsubsection{std::vector<std::string> Group::get\_device\_list (bool fwd = true)}

Returns the list of devices currently in the hierarchy.

If \emph{fwd} is set to true (the default) the request is forwarded
to subgroups. Otherwise, it is only applied to the local set of devices. 

Considering the following hierarchy:
\begin{lyxcode}
g2->add(\textquotedbl{}my/device/04\textquotedbl{});~g2->add(\textquotedbl{}my/device/05\textquotedbl{});

~



g4->add(\textquotedbl{}my/device/08\textquotedbl{});~g4->add(\textquotedbl{}my/device/09\textquotedbl{});

~



g3->add(\textquotedbl{}my/device/06\textquotedbl{});

g3->addg(g4);

g3->add(\textquotedbl{}my/device/07\textquotedbl{});

~



g1->add(\textquotedbl{}my/device/01\textquotedbl{});

g1->add(g2);

g1->add(\textquotedbl{}my/device/03\textquotedbl{});

g1->add(g3);

g1->add(\textquotedbl{}my/device/02\textquotedbl{});
\end{lyxcode}
The returned vector content depends on the value of the forward option.
If set to true, the results will be organized as follows:
\begin{lyxcode}
std::vector<std::string>~dl~=~g1->get\_device\_list(true);
\end{lyxcode}
\emph{dl{[}0{]}} contains \textquotedbl{}my/device/01\textquotedbl{}
which belongs to g1\\
\emph{dl{[}1{]}} contains \textquotedbl{}my/device/04\textquotedbl{}
which belongs to g1.g2\\
\emph{dl{[}2{]}} contains \textquotedbl{}my/device/05\textquotedbl{}
which belongs to g1.g2\\
\emph{dl{[}3{]}} contains \textquotedbl{}my/device/03\textquotedbl{}
which belongs to g1\\
\emph{dl{[}4{]}} contains \textquotedbl{}my/device/06\textquotedbl{}
which belongs to g1.g3\\
\emph{dl{[}5{]}} contains \textquotedbl{}my/device/08\textquotedbl{}
which belongs to g1.g3.g4\\
\emph{dl{[}6{]}} contains \textquotedbl{}my/device/09\textquotedbl{}
which belongs to g1.g3.g4\\
\emph{dl{[}7{]}} contains \textquotedbl{}my/device/07\textquotedbl{}
which belongs to g1.g3\\
\emph{dl{[}8{]}} contains \textquotedbl{}my/device/02\textquotedbl{}
which belongs to g1

If the forward option is set to false, the results are:
\begin{lyxcode}
std::vector<std::string>~dl~=~g1->get\_device\_list(false);
\end{lyxcode}
\emph{dl{[}0{]}} contains \textquotedbl{}my/device/01\textquotedbl{}
which belongs to g1\\
\emph{dl{[}1{]}} contains \textquotedbl{}my/device/03\textquotedbl{}
which belongs to g1\\
\emph{dl{[}2{]}} contains \textquotedbl{}my/device/02\textquotedbl{}
which belongs to g1


\subsection{\textquotedbl{}A la\textquotedbl{} DeviceProxy Methods}


\subsubsection{bool Group::ping (bool fwd = true)}

Ping all devices in a group. This method returns true if all devices
in the group are alive, false otherwise.

If \emph{fwd} is set to true (the default), the request is also forwarded
to subgroups. Otherwise, it is only applied to the local set of devices.


\subsubsection{void Group::set\_timeout\_millis(int timeout\_ms)}

Set client side timeout for all devices composing the group in milliseconds.
Any method which takes longer than this time to execute will throw
an exception.

\emph{Exception: none (errors are ignored).}


\subsubsection{GroupCmdReplyList Group::command\_inout (const std::string\& c, bool
fwd = true)}

Executes a Tango command on a group. This method is synchronous and
does not return until replies are obtained or timeouts occurred.

The parameter \emph{c} is the name of the command. 

If \emph{fwd} is set to true (the default), the request is also forwarded
to subgroups. Otherwise, it is only applied to the local set of devices. 

Command results are returned in a GroupCmdReplyList. See Obtaining
command result for details (\ref{sub:Obt-cmd-results}). See also
Case 1 of executing a command (\ref{sub:Case-1}) for an example. 


\subsubsection{GroupCmdReplyList Group::command\_inout (const std::string\& c, const
DeviceData\& d, bool fwd = true)}

Executes a Tango command on each device in the group. This method
is synchronous and does not return until replies are obtained or timeouts
occurred.

The parameter \emph{c} is the name of the command. 

The second parameter \emph{d} is a Tango generic container for command
carrying the command argument. See the Tango::DeviceData documentation.

If \emph{fwd} is set to true (the default), the request is also forwarded
to subgroups. Otherwise, it is only applied to the local set of devices. 

Command results are returned in a GroupCmdReplyList. See Obtaining
command results (\ref{sub:Obt-cmd-results}) for details. See also
Case 2 of executing a command (\ref{sub:Case-2}) for an example. 


\subsubsection{template<typename T> GroupCmdReplyList Group::command\_inout (const
std::string\& c, const std::vector<T>\& d, bool fwd = true)}

Executes a Tango command on each device in the group. This method
is synchronous and does not return until replies are obtained or timeouts
occurred.

This implementation of command\_inout allows passing a specific input
argument to each device in the group. In order to use this form of
command\_inout, the user must have an \textquotedbl{}a priori\textquotedbl{}
and \textquotedbl{}perfect\textquotedbl{} knowledge of the devices
order in the group.

The parameter \emph{c} is the name of the command. 

The std::vector \emph{d} contains a specific argument value for each
device in the group. Since this method is a template, d is able to
contain any Tango command argument type. Its size must equal Group::get\_size(fwd).
Otherwise, an exception is thrown. The order of the argument values
must follows the order of the devices in the group (d{[}0{]} => 1st
device, d{[}1{]} => 2nd device and so on). 

If \emph{fwd} is set to true (the default), the request is also forwarded
to subgroups. Otherwise, it is only applied to the local set of devices.

Command results are returned in a GroupCmdReplyList. See Obtaining
command results (\ref{sub:Obt-cmd-results}) for details. See also
Case 3 of executing a command (\ref{sub:Case-3}) for an example of
this special form of command\_inout.


\subsubsection{long Group::command\_inout\_asynch (const std::string\& c, bool fgt
= false, bool fwd = true, long rsv = -1) }

Executes a Tango command on each device in the group asynchronously.
The method sends the request to all devices and returns immediately.
Pass the returned request id to \emph{Group::command\_inout\_reply()}
to obtain the results. 

The parameter \emph{c} is the name of the command. 

The parameter \emph{fgt} is a fire and forget flag. If set to true,
it means that no reply is expected (i.e. the caller does not care
about it and will not even try to get it). A false default value is
provided. 

If the parameter \emph{fwd} is set to true (the default) request is
forwarded to subgroups. Otherwise, it is only applied to the local
set of devices. 

Finally, \emph{rsv} is reserved for internal purpose and should not
be modify. This parameter may disappear in a near future. 

See Case 1 of Executing a command (\ref{sub:Case-1}) for an example.


\subsubsection{long Group::command\_inout\_asynch (const std::string\& c, const
DeviceData\& d, bool fgt = false, bool fwd = true, long rsv = -1)}

Executes a Tango command on each device in the group asynchronously.
The method sends the request to all devices and returns immediately.
Pass the returned request id to \emph{Group::command\_inout\_reply()}
to obtain the results. 

The parameter \emph{c} is the name of the command. 

The second parameter \emph{d} is a Tango generic container for command
carrying the command argument. See the Tango::DeviceData documentation
for details.

The parameter \emph{fgt} is a fire and forget flag. If set to true,
it means that no reply is expected (i.e. the caller does not care
about it and will not even try to get it). A false default value is
provided. 

If the parameter \emph{fwd} is set to true (the default) request is
forwarded to subgroups. Otherwise, it is only applied to the local
set of devices. 

Finally, \emph{rsv} is reserved for internal purpose and should not
be modify. This parameter may disappear in a near future. 

See Case 2 of Executing a command (\ref{sub:Case-2}) for an example.


\subsubsection{long Group::command\_inout\_asynch (const std::string\& c, const
std::vector<T>\& d, fgt = false, bool fwd = true)}

Executes a Tango command on each device in the group asynchronously.
The method send the request to all devices and return immediately.
Pass the returned request id to Group::command\_inout\_reply to obtain
the results. 

This implementation of command\_inout allows passing a specific input
argument to each device in the group. In order to use this form of
command\_inout\_asynch, the user must have an \textquotedbl{}a priori\textquotedbl{}
and \textquotedbl{}perfect\textquotedbl{} knowledge of the devices
order in the group.

The parameter \emph{c} is the name of the command. 

The std::vector \emph{d} contains a specific argument value for each
device in the group. d is able to contain any Tango command argument
type. Its size must equal Group::get\_size(fwd). Otherwise, an exception
is thrown. The order of the argument values must follows the order
of the devices in the group (d{[}0{]} => 1st device, d{[}1{]} => 2nd
device and so on). 

The parameter \emph{fgt} is a fire and forget flag. If set to true,
it means that no reply is expected (i.e. the caller does not care
about it and will not even try to get it). A false default value is
provided. 

If \emph{fwd} is set to true (the default), the request is also forwarded
to subgroups. Otherwise, it is only applied to the local set of devices.

See Case 3 of Executing a command (\ref{sub:Case-3}) for an example
of this special form of command\_inout.


\subsubsection{GroupCmdReplyList Group::command\_inout\_reply (long req\_id, long
timeout\_ms = 0)}

Returns the results of an asynchronous command. 

The first parameter \emph{req\_id} is a request identifier previously
returned by one of the command\_inout\_asynch methods. 

For each device in the hierarchy, if the command result is not yet
available, command\_inout\_reply wait \emph{timeout\_ms} milliseconds
before throwing an exception. This exception will be part of the global
reply. If \emph{timeout\_ms} is set to 0, command\_inout\_reply waits
\textquotedbl{}indefinitely\textquotedbl{}.

Command results are returned in a GroupCmdReplyList. See Obtaining
command results (\ref{sub:Obt-cmd-results}) for details.


\subsubsection{GroupAttrReplyList Group::read\_attribute (const std::string\& a,
bool fwd = true)}

Reads an attribute on each device in the group. This method is synchronous
and does not return until replies are obtained or timeouts occurred. 

The parameter \emph{a} is the name of the attribute to read. 

If \emph{fwd} is set to true (the default) request is forwarded to
subgroups. Otherwise, it is only applied to the local set of devices. 

Attribute values are returned in a GroupAttrReplyList. See Obtaining
attribute values (\ref{sub:O-attr-values}) for details. See also
Reading an attribute (\ref{sub:Read-attr}) for an example.


\subsubsection{long Group::read\_attribute\_asynch (const std::string\& a, bool
fwd = true, long rsv = -1)}

Reads an attribute on each device in the group asynchronously. The
method sends the request to all devices and returns immediately. Pass
the returned request id to \emph{Group::read\_attribute\_reply()}
to obtain the results. 

The parameter \emph{a} is the name of the attribute to read. 

If \emph{fwd} is set to true (the default) request is forwarded to
subgroups. Otherwise, it is only applied to the local set of devices. 

The last parameter (rsv) is reserved for internal purpose and should
not be modify. It may disappear in a near future. 

See Reading an attribute (\ref{sub:Read-attr}) for an example.


\subsubsection{GroupAttrReplyList Group::read\_attribute\_reply (long req\_id, long
timeout\_ms = 0)}

Returns the results of an asynchronous attribute reading. 

The first parameter \emph{req\_id} is a request identifier previously
returned by read\_attribute\_asynch. 

For each device in the hierarchy, if the attribute value is not yet
available, read\_attribute\_reply wait \emph{timeout\_ms} milliseconds
before throwing an exception. This exception will be part of the global
reply. If \emph{timeout\_ms} is set to 0, read\_attribute\_reply waits
\textquotedbl{}indefinitely\textquotedbl{}.

Replies are returned in a GroupAttrReplyList. See Obtaining attribute
values (\ref{sub:O-attr-values}) for details.


\subsubsection{GroupReplyList Group::write\_attribute (const DeviceAttribute\& d,
bool fwd = true)}

Writes an attribute on each device in the group. This method is synchronous
and does not return until acknowledgements are obtained or timeouts
occurred. 

The first parameter \emph{d} is a Tango generic container for attribute
carrying both the attribute name and the value. See the Tango::DeviceAttribute
documentation for details.

If \emph{fwd} is set to true (the default) request is forwarded to
subgroups. Otherwise, it is only applied to the local set of devices. 

Acknowledgements are returned in a GroupReplyList. See Obtaining acknowledgements
(\ref{sub:O-ack}) for details. See also Case 1 of Writing an attribute
(\ref{sub:Case-1-writing}) for an example.


\subsubsection{GroupReplyList Group::write\_attribute (const std::string\& a, const
std::vector<T>\& d, bool fwd = true)}

Writes an attribute on each device in the group. This method is synchronous
and does not return until replies are obtained or timeouts occurred.

This implementation of write\_attribute allows writing a specific
value to each device in the group. In order to use this form of write\_attribute,
the user must have an \textquotedbl{}a priori\textquotedbl{} and \textquotedbl{}perfect\textquotedbl{}
knowledge of the devices order in the group.

The parameter \emph{a} is the name of the attribute. 

The std::vector \emph{d} contains a specific value for each device
in the group. Since this method is a template, d is able to contain
any Tango attribute type. Its size must equal \emph{Group::get\_size(fwd)}.
Otherwise, an exception is thrown. The order of the attribute values
must follows the order of the devices in the group (d{[}0{]} => 1st
device, d{[}1{]} => 2nd device and so on). 

If \emph{fwd} is set to true (the default) request is forwarded to
subgroups. Otherwise, it is only applied to the local set of devices.

Acknowledgements are returned in a GroupReplyList. See Obtaining acknowledgements
(\ref{sub:O-ack}) for details. See also Case 2 of Writing an attribute
(\ref{sub:Case-2-writing}) for an example.


\subsubsection{long Group::write\_attribute\_asynch (const DeviceAttribute\& d,
bool fwd = true, long rsv = -1)}

Writes an attribute on each device in the group asynchronously. The
method sends the request to all devices and returns immediately. Pass
the returned request id to \emph{Group::write\_attribute\_reply()}
to obtain the acknowledgements. 

The first parameter \emph{d} is a Tango generic container for attribute
carrying both the attribute name and the value. See the Tango::DeviceAttribute
documentation for details.

If \emph{fwd} is set to true (the default) request is forwarded to
subgroups. Otherwise, it is only applied to the local set of devices. 

The last parameter \emph{rsv} is reserved for internal purpose and
should not be modify. It may disappear in a near future.

See Case 1 of Writing an attribute (\ref{sub:Case-1-writing}) for
an example.


\subsubsection{long Group::write\_attribute\_asynch (const std::string\& a, const
std::vector<T>\& d, bool fwd = true)}

Writes an attribute on each device in the group asynchronously. The
method sends the request to all devices and returns immediately. Pass
the returned request id to \emph{Group::write\_attribute\_reply()}
to obtain the acknowledgements.

This implementation of write\_attribute\_asynch allows writing a specific
value to each device in the group. In order to use this form of write\_attribute\_asynch,
the user must have an \textquotedbl{}a priori\textquotedbl{} and \textquotedbl{}perfect\textquotedbl{}
knowledge of the devices order in the group.

The parameter \emph{a} is the name of the attribute. 

The std::vector \emph{d} contains a specific value for each device
in the group. Since this method is a template, d is able to contain
any Tango attribute type. Its size must equal \emph{Group::get\_size(fwd)}.
Otherwise, an exception is thrown. The order of the attribute values
must follows the order of the devices in the group (d{[}0{]} => 1st
device, d{[}1{]} => 2nd device and so on). 

If \emph{fwd} is set to true (the default) request is forwarded to
subgroups. Otherwise, it is only applied to the local set of devices.

See Case2 of Writing an attribute (\ref{sub:Case-2-writing}) for
an example.


\subsubsection{GroupReplyList Group::write\_attribute\_reply (long req\_id, long
timeout\_ms = 0)}

Returns the acknowledgements of an asynchronous attribute writing. 

The first parameter \emph{req\_id} is a request identifier previously
returned by one of the write\_attribute\_asynch implementation. 

For each device in the hierarchy, if the acknowledgement is not yet
available, write\_attribute\_reply wait \emph{timeout\_ms} milliseconds
before throwing an exception. This exception will be part of the global
reply. If \emph{timeout\_ms} is set to 0, write\_attribute\_reply
waits \textquotedbl{}indefinitely\textquotedbl{}.

Acknowledgements are returned in a GroupReplyList. See Obtaining acknowledgements
\ref{sub:O-ack} for details.


\subsubsection{GroupAttrReplyList Group::read\_attributes (const std::vector<std::string>\&
al, bool fwd = true)}

Reads several attributes on each device in the group. This method
is synchronous and does not return until replies are obtained or timeouts
occurred. 

The parameter \emph{al} is a vector containing the name of the attributes
to be read. 

If \emph{fwd} is set to true (the default) request is forwarded to
subgroups. Otherwise, it is only applied to the local set of devices. 

Attribute values are returned in a GroupAttrReplyList. See Obtaining
attribute values (\ref{sub:O-attr-values}) for details. See also
Reading an attribute (\ref{sub:Read-attr}) for an example. The order
of attribute value returned in the GroupAttrReplyList is all attributes
for first element in the group followed by all attributes for the
second group element and so on.


\subsubsection{long Group::read\_attributes\_asynch (const std::vector<std::string>\&
al, bool fwd = true, long rsv = -1)}

Reads several attributes on each device in the group asynchronously.
The method sends the request to all devices and returns immediately.
Pass the returned request id to \emph{Group::read\_attributes\_reply()}
to obtain the results. 

The parameter \emph{al} is a vector containing the name of the attributes
to be read. 

If \emph{fwd} is set to true (the default) request is forwarded to
subgroups. Otherwise, it is only applied to the local set of devices. 

The last parameter (rsv) is reserved for internal purpose and should
not be modify. It may disappear in a near future. 

See Reading an attribute (\ref{sub:Read-attr}) for an example.


\subsubsection{GroupAttrReplyList Group::read\_attributes\_reply (long req\_id,
long timeout\_ms = 0)}

Returns the results of an asynchronous attribute reading. 

The first parameter \emph{req\_id} is a request identifier previously
returned by read\_attributes\_asynch. 

For each device in the hierarchy, if the attribute value is not yet
available, read\_attributes\_reply wait \emph{timeout\_ms} milliseconds
before throwing an exception. This exception will be part of the global
reply. If \emph{timeout\_ms} is set to 0, read\_attributes\_reply
waits \textquotedbl{}indefinitely\textquotedbl{}.

Replies are returned in a GroupAttrReplyList. See Obtaining attribute
values (\ref{sub:O-attr-values}) for details. The order of attribute
value returned in the GroupAttrReplyList is all attributes for first
element in the group followed by all attributes for the second group
element and so on.
\begin{lyxcode}

\end{lyxcode}

\section{\noindent Tango::Database}

\noindent A high level object which contains the link to the database.
It has methods for all database commands e.g. get\_device\_property(),
device\_list(), info(), etc. 


\subsection{\noindent Database::Database()}

\noindent Create a TANGO Database object. The constructor uses the
environment variable ``TANGO\_HOST'' to determine which instance
of the TANGO database to connect to. Example :

\input{line.tex}
\begin{lyxcode}
\noindent using~namespace~Tango;

\noindent Database~{*}db~=~new~Database();
\end{lyxcode}
\input{line.tex}

The Database class also has a copy constructor and one assignement
operator defined.


\subsection{\noindent string Database::get\_info()}

\noindent Query the database for some general info about the tables
in the database. Result is returned as a string. Example :

\input{line.tex}
\begin{lyxcode}
\noindent cout~<\textcompwordmark{}<~db->get\_info()~<\textcompwordmark{}<~endl;
\end{lyxcode}
\input{line.tex}

\noindent will return information like this :

\input{line.tex}
\begin{lyxcode}
\noindent Running~since~2000-11-06~14:10:46

\noindent ~

\noindent Devices~defined~~=~115

\noindent Devices~exported~~=~41

\noindent Device~servers~defined~~=~47

\noindent Device~servers~exported~~=~17

\noindent ~

\noindent Class~properties~defined~~=~5

\noindent Device~properties~defined~~=~130

\noindent Class~attribute~properties~defined~~=~20

\noindent Device~attribute~properties~defined~~=~92
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions: ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{\noindent void Database::add\_device(DbDevInfo\&)}

\noindent Add a device to the database. The device name, server and
class are specified in the DbDevInfo structure. Example :

\input{line.tex}
\begin{lyxcode}
\noindent DbDevInfo~my\_device\_info;

\noindent my\_device\_info.name~=~``my/own/device'';

\noindent my\_device\_info.\_class~=~``MyDevice'';

\noindent my\_device\_info.server~=~``MyServer/test'';

\noindent db->add\_device(my\_device\_info);
\end{lyxcode}
\input{line.tex}

\emph{Exception: ConnectionFailed, CommunicationFailed, DevFailed
from device}


\subsection{\noindent void Database::delete\_device(string)}

\noindent Delete the device of the specified name from the database.
Example

\input{line.tex}
\begin{lyxcode}
\noindent db->delete\_device(``my/own/device'');
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError, DB\_DeviceNotDefined)}


\subsection{\noindent DbDevImportInfo Database::import\_device(string \&)}

\noindent Query the database for the export info of the specified
device. The command returns the information in a DbDevImportInfo structure.
Example :

\input{line.tex}
\begin{lyxcode}
\noindent DbDevImportInfo~my\_device\_import;

\noindent my\_device\_import~=~db->import\_device(``my/own/device'');

\noindent cout~<\textcompwordmark{}<~``~device~''~<\textcompwordmark{}<~my\_device\_import.name;

\noindent cout~<\textcompwordmark{}<~``exported~''~<\textcompwordmark{}<~my\_device\_import.exported;

\noindent cout~<\textcompwordmark{}<~``ior~''~<\textcompwordmark{}<~my\_device\_import.ior;

\noindent cout~<\textcompwordmark{}<~``version~''~<\textcompwordmark{}<~my\_device\_import.version;

\noindent cout~<\textcompwordmark{}<~endl;
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device ( DB\_SQLError, DB\_DeviceNotDefined)}


\subsection{\noindent void Database::export\_device(DbDevExportInfo\&)}

\noindent Update the export info for this device in the database.
Device name, server, class, pid and version are specified in the DbDevExportInfo
structure. Example :

\input{line.tex}
\begin{lyxcode}
\noindent DbDevExportInfo~my\_device\_export;

\noindent my\_device\_export.name~=~``my/own/device'';

\noindent my\_device\_export.ior~=~``the~real~ior'';

\noindent my\_device\_export.host~=~``dumela'';

\noindent my\_device\_export.version~=~``1.0'';

\noindent my\_device\_export.pid~=~get\_pid();

\noindent db->export\_device(my\_device\_export);
\end{lyxcode}
\input{line.tex}

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError, DB\_DeviceNotDefined)}


\subsection{\noindent void Database::unexport\_device(string)}

\noindent Mark the specified device as un-exported in the database.
Example :

\input{line.tex}
\begin{lyxcode}
\noindent db->unexport\_device(``my/own/device'');
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{\noindent void Database::add\_server(string \&, DbDevInfos\&)}

\noindent Add a group of devices to the database. The device names,
server names and classes are specified in the vector of DbDevInfo
structures.

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{\noindent void Database::delete\_server(string \&)}

\noindent Delete the device server and its associated devices from
the database.

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{\noindent void Database::export\_server( DbDevExportInfos \&)}

\noindent Export a group of devices to the database. The device names,
IOR, class, server name, pid etc. are specified in the vector of DbDevExportInfo
structures.

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{\noindent void Database::unexport\_server(string \&)}

\noindent Mark all devices exported for this server as unexported.

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{DbDatum Database::get\_services(string \&servicename,string \&instname)}

Query database for specified services.The instname parameter can be
a wildcard character (\textquotedbl{}{*}\textquotedbl{}).

\input{line.tex}
\begin{lyxcode}
string~servicename(\textquotedbl{}HdbManager\textquotedbl{});

string~instname(\textquotedbl{}ctrm\textquotedbl{});

DbDatum~db\_datum~=~db->get\_services(servicename,instname);

vector<string>~service\_list;

db\_datum~>\textcompwordmark{}>~service\_list;
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{void Database::register\_service(string \&servicename,string \&instname,string
\&devname)}

Register the specified service wihtin the database.

\input{line.tex}
\begin{lyxcode}
string~servicename(\textquotedbl{}HdbManager\textquotedbl{});

string~instname(\textquotedbl{}ctrm\textquotedbl{});

string~devname(\textquotedbl{}sys/hdb/1\textquotedbl{});

db->register\_service(servicename,instname,devname);
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{void Database::unregister\_service(string \&servicename,string \&instname)}

Unregister the specified service from the database.

\input{line.tex}
\begin{lyxcode}
string~servicename(\textquotedbl{}HdbManager\textquotedbl{});

string~instname(\textquotedbl{}ctrm\textquotedbl{});

db->unregister\_service(servicename,instname);
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{DbDatum Database::get\_host\_list()}

Returns the list of all host names registered in the database.

\input{line.tex}
\begin{lyxcode}
DbDatum~db\_datum~=~db->get\_host\_list();

vector<string>~host\_list;

db\_datum~>\textcompwordmark{}>~host\_list;
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{DbDatum Database::get\_host\_list(string \&wildcard)}

Returns the list of all host names registered in the database which
match the specified wildcard (eg: \textquotedbl{}l-c0{*}\textquotedbl{}).

\input{line.tex}
\begin{lyxcode}
string~wildcard(\textquotedbl{}l-c0{*}\textquotedbl{});

DbDatum~db\_datum~=~db->get\_host\_list(wildcard);

vector<string>~host\_list;

db\_datum~>\textcompwordmark{}>~host\_list;
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{DbDatum Database::get\_server\_class\_list(string \&server)}

Query the database for a list of classes instancied by the specified
server. The DServer class exists in all TANGO servers and for this
reason this class is removed from the returned list.

\input{line.tex}
\begin{lyxcode}
string~server(\textquotedbl{}Serial/1\textquotedbl{});

DbDatum~db\_datum~=~db->get\_server\_class\_list(server);

vector<string>~class\_list;

db\_datum~>\textcompwordmark{}>~class\_list;
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{DbDatum Database::get\_server\_name\_list()}

Return the list of all server names registered in the database.

\input{line.tex}
\begin{lyxcode}
DbDatum~db\_datum~=~db->get\_server\_name\_list();

vector<string>~server\_list;

db\_datum~>\textcompwordmark{}>~server\_list;
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{DbDatum Database::get\_instance\_name\_list(string \&servername)}

Return the list of all instance names existing in the database for
the specifed server.

\input{line.tex}
\begin{lyxcode}
string~servername(\textquotedbl{}Serial\textquotedbl{});

DbDatum~db\_datum~=~db->get\_instance\_name\_list(servername);

vector<string>~instance\_list;

db\_datum~>\textcompwordmark{}>~instance\_list;
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{DbDatum Database::get\_server\_list()}

Return the list of all servers registered in the database.

\input{line.tex}
\begin{lyxcode}
DbDatum~db\_datum~=~db->get\_server\_list();

vector<string>~server\_list;

db\_datum~>\textcompwordmark{}>~server\_list;
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{DbDatum Database::get\_server\_list(string \&wildcard)}

Return the list of all servers registered in the database which match
the specified wildcard (eg: \textquotedbl{}Serial/{*}\textquotedbl{}).

\input{line.tex}
\begin{lyxcode}
string~wildcard(\textquotedbl{}Serial/{*}\textquotedbl{});

DbDatum~db\_datum~=~db->get\_server\_list(wildcard);

vector<string>~server\_list;

db\_datum~>\textcompwordmark{}>~server\_list;
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{DbDatum Database::get\_host\_server\_list(string \&hostname)}

Query the database for a list of servers registred on the specified
host.

\input{line.tex}
\begin{lyxcode}
string~host(\textquotedbl{}kidiboo\textquotedbl{});

DbDatum~db\_datum~=~db->get\_host\_server\_list(wildcard);

vector<string>~server\_list;

db\_datum~>\textcompwordmark{}>~server\_list;
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{DbServerInfo Database::get\_server\_info(string \&server)}

Query the database for server information.

\input{line.tex}
\begin{lyxcode}
string~server(\textquotedbl{}Serial/1\textquotedbl{});

DbServerInfo~info~=~db->get\_server\_info(server);
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{void Database::put\_server\_info(DbServerInfo \&info)}

Add/update server information in the database.

\input{line.tex}
\begin{lyxcode}
DbServerInfo~info;

info.name~=~\textquotedbl{}Serial/1\textquotedbl{};~//~Server~(name/instance)

info.host~=~\textquotedbl{}kidiboo\textquotedbl{};~//~Register~on~host~kidiboo

info.mode~=~1;~//~Controlled~by~Astor~flag~(0~or~1)

info.level~=~3;~//~Startup~level~(Used~by~Astor)

db->put\_server\_info(info);
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{void Database::delete\_server\_info(string \&server)}

Delete server information of the specifed server from the database.

\input{line.tex}
\begin{lyxcode}
string~server(\textquotedbl{}Serial/1\textquotedbl{});

db->delete\_server\_info(server);
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{\noindent DbDatum Database::get\_device\_name(string \&, string \&)}

\noindent Query the database for a list of devices served by the specified
server (1st parameter) and of the specified class (2nd parameter).
The method returns a DbDatum type. The device names are stored as
an array of strings. Here is two code example of how to extract the
names from the DbDatum type :

\input{line.tex}
\begin{lyxcode}
\noindent vector<string>~device\_names;

\noindent device\_names~<\textcompwordmark{}<~db\_datum;
\end{lyxcode}
\input{line.tex}

\noindent or :

\input{line.tex}
\begin{lyxcode}
\noindent for~(int~i=0;~i<~db\_datum.size();~i++)

\noindent \{

\noindent device\_name{[}i{]}~=~db\_datum.value\_string{[}i{]};

\noindent \}
\end{lyxcode}
\input{line.tex}

\emph{Exception: ConnectionFailed, CommunicationFailed, DevFailed
from device}


\subsection{\noindent DbDatum Database::get\_device\_exported(string \&)}

\noindent Query the database for a list of exported devices whose
names satisfy the supplied filter ({*} is wildcard for any character(s)).
This method returns a DbDatum type. See the method get\_device\_name()
for an example of how to extract the list of aliases from the DbDatum
type.

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{\noindent DbDatum Database::get\_device\_domain(string \&)}

\noindent Query the database for a list of device domain names which
match the wildcard provided. Wildcard character is {*} and matches
any number of characters. Domain names are case insensitive. This
method returns a DbDatum type. See the method get\_device\_name()
for an example of how to extract the list of aliases from the DbDatum
type.

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{\noindent DbDatum Database::get\_device\_family(string \&)}

\noindent Query the database for a list of device family names which
match the wildcard provided. Wildcard character is {*} and matches
any number of characters. Family names are case insensitive. This
method returns a DbDatum type. See the method get\_device\_name()
for an example of how to extract the list of aliases from the DbDatum
type.

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{\noindent DbDatum Database::get\_device\_member(string \&)}

\noindent Query the database for a list of device member names which
match the wildcard provided. Wildcard characters is {*} and matches
any number of characters. Member names are case insensitive. This
method returns a DbDatum type. See the method get\_device\_name()
for an example of how to extract the list of aliases from the DbDatum
type.

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{DbDatum Database::get\_device\_class\_list(string \&server)}

Query the database for a list of devices and classes served by the
specified server. Return a list with the following structure: \{device
name,class name,device name,class name,...\}

\input{line.tex}
\begin{lyxcode}
string~server(\textquotedbl{}Serial/1\textquotedbl{});

DbDatum~db\_datum~=~db->get\_device\_class\_list(server);

vector<string>~dev\_list;

db\_datum~>\textcompwordmark{}>~dev\_list;
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{string Database::get\_class\_for\_device(string \&devname)}

Return the class of the specified device.

\input{line.tex}
\begin{lyxcode}
string~devname(\textquotedbl{}sr/rf-cavity/1\textquotedbl{});

string~classname~=~db->get\_class\_for\_device(devname);
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{DbDatum Database::get\_class\_inheritance\_for\_device(string \&devname)}

Return the class inheritance scheme of the specified device.

\input{line.tex}
\begin{lyxcode}
string~devname(\textquotedbl{}sr/rf-cavity/1\textquotedbl{});

DbDatum~db\_datum~=~db->get\_class\_inheritance\_for\_device(devname);

vector<string>~class\_list;

db\_datum~>\textcompwordmark{}>~class\_list;
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{DbDatum Database::get\_device\_exported\_for\_class(string \&classname)}

Query database for list of exported devices for the specified class.

\input{line.tex}
\begin{lyxcode}
string~classname(\textquotedbl{}MyClass\textquotedbl{});

DbDatum~db\_datum~=~db->get\_device\_exported\_for\_class(classname);

vector<string>~dev\_list;

db\_datum~>\textcompwordmark{}>~dev\_list;
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{DbDatum Database::get\_object\_list(string \&wildcard)}

Query the database for a list of object (free properties) for which
properties are defined and which match the specified wildcard.

\input{line.tex}
\begin{lyxcode}
string~wildcard(\textquotedbl{}Optic{*}\textquotedbl{});

DbDatum~db\_datum~=~db->get\_object\_list(wildcard);

vector<string>~obj\_list;

db\_datum~>\textcompwordmark{}>~obj\_list;
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{DbDatum Database::get\_object\_property\_list(string \&objectname,string
\&wildcard)}

Query the database for a list of properties defined for the specified
object and which match the specified wildcard.

\input{line.tex}
\begin{lyxcode}
string~objname(\textquotedbl{}OpticID9\textquotedbl{});

string~wildcard(\textquotedbl{}Delta{*}\textquotedbl{});

DbDatum~db\_datum~=~db->get\_object\_property\_list(objname,wildcard);

vector<string>~prop\_list;

db\_datum~>\textcompwordmark{}>~prop\_list;
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{\noindent void Database::get\_property(string, DbData\&)}

\noindent Query the database for a list of object (i.e. non-device)
properties for the specified object. The property names are specified
by the vector of DbDatum structures. The method returns the properties
in the same DbDatum structures. To retrieve the properties use the
extract operator >\textcompwordmark{}>. Here is an example of how
to use the DbData type to specify and extract properties :

\input{line.tex}
\begin{lyxcode}
\noindent DbData~db\_data;

\noindent db\_data.push\_back(DbDatum(``velocity''));

\noindent db\_data.push\_back(DbDatum(``acceleration''));

\noindent db->get\_property(``mymotor'',~db\_data);

\noindent float~velocity,~acceleration;

\noindent db\_data{[}0{]}~>\textcompwordmark{}>~velocity;

\noindent db\_data{[}1{]}~>\textcompwordmark{}>~acceleration;
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{\noindent void Database::put\_property(string, DbData\&)}

\noindent Insert or update a list of properties for the specified
object. The property names and their values are specified by the vector
of DbDatum structures. Use the insert operator >\textcompwordmark{}>
to insert the properties into the DbDatum structures. Here is an example
of how to insert properties into the database using this method :

\input{line.tex}
\begin{lyxcode}
\noindent DbDatum~velocity(``velocity''),~acceleration(``acceleration'');

\noindent DbData~db\_data;

\noindent velocity~<\textcompwordmark{}<~100000.0;

\noindent acceleration~<\textcompwordmark{}<~500000.0;

\noindent db\_data.push\_back(velocity);

\noindent db\_data.push\_back(acceleration);

\noindent db->put\_property(``mymotor'',~db\_data);
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{\noindent void Database::delete\_property(string, DbData\&)}

\noindent Delete a list of properties for the specified object. The
property names are specified by the vector of DbDatum structures.
Here is an example of how to delete properties from the database using
this method :

\input{line.tex}
\begin{lyxcode}
\noindent DbData~db\_data;

\noindent db\_data.push\_back(DbDatum(``velocity''));

\noindent db\_data.push\_back(DbDatum(``acceleration''));

\noindent db->delete\_property(``mymotor'',~db\_data);
\end{lyxcode}
\input{line.tex}

\emph{Exceptions: ConnectionFailed, CommunicationFailed, DevFailed
from device}


\subsection{vector<DbHistory> Database::get\_property\_history(string \&objname,
string \&propname)}

Get the list of the last 10 modifications of the specifed object property.
Note that propname can contain a wildcard character (eg: \textquotedbl{}prop{*}\textquotedbl{}). 

\input{line.tex}
\begin{lyxcode}
vector<DbHistory>~hist;

DbDatum~result;

string~objname(\textquotedbl{}jlptest\textquotedbl{});

string~propname(\textquotedbl{}test\_prop\textquotedbl{});

hist~=~db->get\_property\_history(objname,propname);

//~Print~the~modification~history~of~the~specified~property

for(int~i=0;i<hist.size();i++)~\{



~~cout~<\textcompwordmark{}<~\textquotedbl{}Name:\textquotedbl{}~<\textcompwordmark{}<~hist{[}i{]}.get\_name()~<\textcompwordmark{}<~endl;~

~~cout~<\textcompwordmark{}<~\textquotedbl{}Date:\textquotedbl{}~<\textcompwordmark{}<~hist{[}i{]}.get\_date()~<\textcompwordmark{}<~endl;~

~~if(~hist{[}i{]}.is\_deleted()~)~\{

~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Deleted~!\textquotedbl{}~<\textcompwordmark{}<~endl;

~~\}~else~\{

~~~~hist{[}i{]}.get\_value()~>\textcompwordmark{}>~result;

~~~~for~(int~j=0;~j<result.size();~j++)

~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Value:\textquotedbl{}~<\textcompwordmark{}<~result{[}j{]}~<\textcompwordmark{}<~endl;

~~\}



\}
\end{lyxcode}
\input{line.tex}

Exceptions: ConnectionFailed, CommunicationFailed, DevFailed from
device


\subsection{\noindent void Database::get\_device\_property(string, DbData\&)}

\noindent Query the database for a list of device properties for the
specified object. The property names are specified by the vector of
DbDatum structures. The method returns the properties in the same
DbDatum structures. To retrieve the properties use the extract operator
>\textcompwordmark{}>. Here is an example of how to use the DbData
type to specify and extract properties :

\input{line.tex}
\begin{lyxcode}
\noindent DbData~db\_data;

\noindent db\_data.push\_back(DbDatum(``velocity''));

\noindent db\_data.push\_back(DbDatum(``acceleration''));

\noindent db->get\_device\_property(``id11/motor/1'',~db\_data);

\noindent float~velocity,~acceleration;

\noindent db\_data{[}0{]}~>\textcompwordmark{}>~velocity;

\noindent db\_data{[}1{]}~>\textcompwordmark{}>~acceleration;
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{\noindent void Database::put\_device\_property(string, DbData\&)}

\noindent Insert or update a list of properties for the specified
device. The property names and their values are specified by the vector
of DbDatum structures. Use the insert operator >\textcompwordmark{}>
to insert the properties into the DbDatum structures. Here is an example
of how to insert properties into the database using this method :

\input{line.tex}
\begin{lyxcode}
\noindent DbDatum~velocity(``velocity''),~acceleration(``acceleration'');

\noindent DbData~db\_data;

\noindent velocity~<\textcompwordmark{}<~100000.0;

\noindent acceleration~<\textcompwordmark{}<~500000.0;

\noindent db\_data.push\_back(velocity);

\noindent db\_data.push\_back(acceleration);

\noindent db->put\_device\_property(``id11/motor/1'',~db\_data);
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{\noindent void Database::delete\_device\_property(string, DbData\&)}

\noindent Delete a list of properties for the specified device. The
property names are specified by the vector of DbDatum structures.
Here is an example of how to delete properties from the database using
this method :

\input{line.tex}
\begin{lyxcode}
\noindent DbData~db\_data;

\noindent db\_data.push\_back(DbDatum(``velocity''));

\noindent db\_data.push\_back(DbDatum(``acceleration''));

\noindent db->delete\_device\_property(``id11/motor/1'',~db\_data);
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{vector<DbHistory> Database::get\_device\_property\_history(string
\&devname, string \&propname)}

Get the list of the last 10 modifications of the specifed device property.
Note that propname can contain a wildcard character (eg: \textquotedbl{}prop{*}\textquotedbl{}).
An example of usage of a similar function can be found in the documentation
of the get\_property\_history() function.

Exceptions: ConnectionFailed, CommunicationFailed, DevFailed from
device


\subsection{\noindent void Database::get\_device\_attribute\_property(string,
DbData\&)}

\noindent Query the database for a list of device attribute properties
for the specified object. The attribute names are specified by the
vector of DbDatum structures. The method returns all the properties
for the specified attributes. The attribute names are returned with
the number of properties specified as their value. The first DbDatum
element of the returned DbData vector contains the first attribute
name and the first attribute property number. The following DbDatum
element contains the first attribute property name and property values.
To retrieve the properties use the extract operator >\textcompwordmark{}>.
Here is an example of how to use the DbData type to specify and extract
attribute properties :

\input{line.tex}
\begin{lyxcode}
\noindent DbData~db\_data;

\noindent db\_data.push\_back(DbDatum(\textquotedbl{}velocity\textquotedbl{}));

\noindent db\_data.push\_back(DbDatum(\textquotedbl{}acceleration\textquotedbl{}));

\noindent ~

\noindent db->get\_device\_attribute\_property(\textquotedbl{}id11/motor/1\textquotedbl{},~db\_data);

\noindent ~

float~vel\_max,~vel\_min,~acc\_max,~acc\_min;

\noindent ~

for~(int~i=0;i~<~db\_data.size();)

\noindent \{

~~~~~long~nb\_prop;

~~~~~string~\&att\_name~=~db\_data{[}i{]}.name;

~~~~~db\_data{[}i{]}~>\textcompwordmark{}>~nb\_prop;

~~~~~i++;

~~~~~for~(int~k=0;k~<~nb\_prop;k++)

~~~~~\{

~~~~~~~~~string~\&prop\_name~=~db\_data{[}i{]}.name;

~~~~~~~~~if~(att\_name~==~\textquotedbl{}velocity\textquotedbl{})

~~~~~~~~~\{

~~~~~~~~~~~~~if~(prop\_name~==~\textquotedbl{}min\textquotedbl{})

~~~~~~~~~~~~~~~~~db\_data{[}i{]}~>\textcompwordmark{}>~~vel\_min;

~~~~~~~~~~~~~else~if~(att\_name~==~\textquotedbl{}max\textquotedbl{})

~~~~~~~~~~~~~~~~~db\_data{[}i{]}~>\textcompwordmark{}>~vel\_max;

~~~~~~~~~\}

~~~~~~~~~else

~~~~~~~~~\{

~~~~~~~~~~~~~if~(prop\_name~==~\textquotedbl{}min\textquotedbl{})

~~~~~~~~~~~~~~~~~db\_data{[}i{]}~>\textcompwordmark{}>~acc\_min;

~~~~~~~~~~~~~else

~~~~~~~~~~~~~~~~~db\_data{[}i{]}~>\textcompwordmark{}>~acc\_max;

~~~~~~~~~\}

~~~~~~~~~i++;

~~~~~\}

\}
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{\noindent void Database::put\_device\_attribute\_property(string,
DbData\&)}

\noindent Insert or update a list of attribute properties for the
specified device. The attribute property names and their values are
specified by the vector of DbDatum structures. Use the insert operator
>\textcompwordmark{}> to insert the properties into the DbDatum structures.
Here is an example of how to insert/update properties \emph{min},
\emph{max} for attribute \emph{velocity} and properties \emph{min},
\emph{max} for attribute \emph{acceleration} of device \emph{id11/motor/1}
into the database using this method :

\input{line.tex}
\begin{lyxcode}
\noindent DbDatum~velocity(\textquotedbl{}velocity\textquotedbl{}),~vel\_min(\textquotedbl{}min\textquotedbl{}),~vel\_max(\textquotedbl{}max\textquotedbl{});

\noindent DbDatum~acceleration(\textquotedbl{}acceleration\textquotedbl{}),~acc\_min(\textquotedbl{}min\textquotedbl{}),~acc\_max(\textquotedbl{}max\textquotedbl{});

\noindent DbData~db\_data;

\noindent velocity~<\textcompwordmark{}<~2;

\noindent vel\_min~<\textcompwordmark{}<~0.0;

\noindent vel\_max~<\textcompwordmark{}<~1000000.0;

\noindent db\_data.push\_back(velocity);

\noindent db\_data.push\_back(vel\_min);

\noindent db\_data.push\_back(vel\_max);

\noindent acceleration~<\textcompwordmark{}<~2;

\noindent acc\_min~<\textcompwordmark{}<~0.0;

\noindent acc\_max~<\textcompwordmark{}<~8000000;

\noindent db\_data.push\_back(acceleration);

\noindent db\_data.push\_back(acc\_min);

\noindent db\_data.push\_back(acc\_max);

\noindent db->put\_device\_attribute\_property(``id11/motor/1'',~db\_data);
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{\noindent void Database::delete\_device\_attribute\_property(string,
DbData\&)}

\noindent Delete a list of attribute properties for the specified
device. The attribute names are specified by the vector of DbDatum
structures. Here is an example of how to delete the \emph{unit} property
of the \emph{velocity} attribute of the \emph{id11/motor/1} device
using this method :

\input{line.tex}
\begin{lyxcode}
\noindent DbData~db\_data;

db\_data.push\_back(DbDatum(\textquotedbl{}velocity\textquotedbl{}));

\noindent db\_data.push\_back(DbDatum(\textquotedbl{}unit\textquotedbl{}));

\noindent db->delete\_device\_attribute\_property(\textquotedbl{}id11/motor/1\textquotedbl{},~db\_data);
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{vector<DbHistory> Database::get\_device\_attribute\_property\_history(string
\&devname, string \&attname, string \&propname)}

Get the list of the last 10 modifications of the specifed device attribute
property. Note that propname and attname can contain a wildcard character
(eg: \textquotedbl{}prop{*}\textquotedbl{}). An example of usage of
a similar function can be found in the documentation of the get\_property\_history()
function.

Exceptions: ConnectionFailed, CommunicationFailed, DevFailed from
device


\subsection{DbDatum Database::get\_class\_list(string \&wildcard)}

Query the database for a list of classes which match the specified
wildcard.

\input{line.tex}
\begin{lyxcode}
string~wildcard(\textquotedbl{}Motor{*}\textquotedbl{});

DbDatum~db\_datum~=~db->get\_class\_list(wildcard);

vector<string>~class\_list;

db\_datum~>\textcompwordmark{}>~class\_list;
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{DbDatum Database::get\_class\_property\_list(string \&classname)}

Query the database for a list of properties defined for the specified
class.

\input{line.tex}
\begin{lyxcode}
string~classname(\textquotedbl{}MyClass\textquotedbl{});

DbDatum~db\_datum~=~db->get\_class\_property\_list(classname);

vector<string>~prop\_list;

db\_datum~>\textcompwordmark{}>~prop\_list;
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{\noindent void Database::get\_class\_property(string, DbData\&)}

\noindent Query the database for a list of class properties. The property
names are specified by the vector of DbDatum structures. The method
returns the properties in the same DbDatum structures. To retrieve
the properties use the extract operator >\textcompwordmark{}>. Here
is an example of how to use the DbData type to specify and extract
properties :

\input{line.tex}
\begin{lyxcode}
\noindent DbData~db\_data;

\noindent db\_data.push\_back(DbDatum(\textquotedbl{}velocity\textquotedbl{}));

\noindent db\_data.push\_back(DbDatum(\textquotedbl{}acceleration\textquotedbl{}));

\noindent db->get\_class\_property(\textquotedbl{}StepperMotor\textquotedbl{},~db\_data);

\noindent float~velocity,~acceleration;

\noindent db\_data{[}0{]}~>\textcompwordmark{}>~velocity;

\noindent db\_data{[}1{]}~>\textcompwordmark{}>~acceleration;
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{\noindent void Database::put\_class\_property(string, DbData\&)}

\noindent Insert or update a list of properties for the specified
class. The property names and their values are specified by the vector
of DbDatum structures. Use the insert operator >\textcompwordmark{}>
to insert the properties into the DbDatum structures. Here is an example
of how to insert properties into the database using this method :

\input{line.tex}
\begin{lyxcode}
\noindent DbDatum~velocity(\textquotedbl{}velocity\textquotedbl{}),~acceleration(\textquotedbl{}acceleration\textquotedbl{});

\noindent DbData~db\_data;

\noindent velocity~<\textcompwordmark{}<~100000.0;

\noindent acceleration~<\textcompwordmark{}<~500000.0;

\noindent db\_data.push\_back(velocity);

\noindent db\_data.push\_back(acceleration);

\noindent db->put\_class\_property(\textquotedbl{}StepperMotor\textquotedbl{},~db\_data);
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{\noindent void Database::delete\_class\_property(string, DbData\&)}

\noindent Delete a list of properties for the specified class. The
property names are specified by the vector of DbDatum structures.
Here is an example of how to delete properties from the database using
this method :

\input{line.tex}
\begin{lyxcode}
\noindent DbData~db\_data;

\noindent db\_data.push\_back(DbDatum(\textquotedbl{}velocity\textquotedbl{}));

\noindent db\_data.push\_back(DbDatum(\textquotedbl{}acceleration\textquotedbl{}));

\noindent db->delete\_class\_property(\textquotedbl{}StepperMotor\textquotedbl{},~db\_data);
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{vector<DbHistory> Database::get\_class\_property\_history(string
\&classname, string \&propname)}

Get the list of the last 10 modifications of the specifed class property.
Note that propname can contain a wildcard character (eg: \textquotedbl{}prop{*}\textquotedbl{}).
An example of usage of a similar function can be found in the documentation
of the get\_property\_history() function.

Exceptions: ConnectionFailed, CommunicationFailed, DevFailed from
device


\subsection{DbDatum Database::get\_class\_attribute\_list(string \&classname,string
\&wildcard)}

Query the database for a list of attributes defined for the specified
class which match the specified wildcard.

\input{line.tex}
\begin{lyxcode}
string~classname(\textquotedbl{}MyClass\textquotedbl{});

string~wildcard(\textquotedbl{}{*}\textquotedbl{});

DbDatum~db\_datum~=~db->get\_class\_attribute\_list(classname,wildcard);

vector<string>~att\_list;

db\_datum~>\textcompwordmark{}>~att\_list;
\end{lyxcode}
\input{line.tex}

Exception: ConnectionFailed, CommunicationFailed, DevFailed from device


\subsection{\noindent void Database::get\_class\_attribute\_property(string,
DbData\&)}

\noindent Query the database for a list of class attribute properties
for the specified object. The attribute names are specified by the
vector of DbDatum structures. The method returns all the properties
for the specified attributes. The attribute names are returned with
the number of properties specified as their value. The first DbDatum
element of the returned DbData vector contains the first attribute
name and the first attribute property number. The following DbDatum
element contains the first attribute property name and property values.
To retrieve the properties use the extract operator >\textcompwordmark{}>.
Here is an example of how to use the DbData type to specify and extract
attribute properties :

\input{line.tex}
\begin{lyxcode}
\noindent DbData~db\_data;

\noindent db\_data.push\_back(DbDatum(\textquotedbl{}velocity\textquotedbl{}));

\noindent db\_data.push\_back(DbDatum(\textquotedbl{}acceleration\textquotedbl{}));

\noindent ~

db->get\_class\_attribute\_property(\textquotedbl{}StepperMotor\textquotedbl{},~db\_data);

\noindent ~

\noindent float~vel\_max,~vel\_min,~acc\_max,~acc\_min;

\noindent ~

for~(int~i=0;~i<~db\_data.size();~i++)

\noindent \{

~~~~~long~nb\_prop;

~~~~~string~\&att\_name~=~db\_data{[}i{]}.name;

~~~~~db\_data{[}i{]}~>\textcompwordmark{}>~nb\_prop;

~~~~~i++;

~~~~~for~(int~k=0;k~<~nb\_prop;k++)

~~~~~\{

~~~~~~~~~string~\&prop\_name~=~db\_data{[}i{]}.name;

~~~~~~~~~if~(att\_name~==~\textquotedbl{}velocity\textquotedbl{})

~~~~~~~~~\{

~~~~~~~~~~~~~if~(prop\_name~==~\textquotedbl{}min\textquotedbl{})

~~~~~~~~~~~~~~~~~db\_data{[}i{]}~>\textcompwordmark{}>~~vel\_min;

~~~~~~~~~~~~~else~if~(att\_name~==~\textquotedbl{}max\textquotedbl{})

~~~~~~~~~~~~~~~~~db\_data{[}i{]}~>\textcompwordmark{}>~vel\_max;

~~~~~~~~~\}

~~~~~~~~~else

~~~~~~~~~\{

~~~~~~~~~~~~~if~(prop\_name~==~\textquotedbl{}min\textquotedbl{})

~~~~~~~~~~~~~~~~~db\_data{[}i{]}~>\textcompwordmark{}>~acc\_min;

~~~~~~~~~~~~~else

~~~~~~~~~~~~~~~~~db\_data{[}i{]}~>\textcompwordmark{}>~acc\_max;

~~~~~~~~~\}

~~~~~~~~~i++;

~~~~~\}

\}


\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{\noindent void Database::put\_class\_attribute\_property(string,
DbData\&)}

\noindent Insert or update a list of attribute properties for the
specified class. The attribute property names and their values are
specified by the vector of DbDatum structures. Use the insert operator
>\textcompwordmark{}> to insert the properties into the DbDatum structures.
Here is an example of how to insert/update \emph{min}, \emph{max}
properties for attribute \emph{velocity} and \emph{min}, \emph{max}
properties for attribute \emph{acceleration} properties belonging
to class \emph{StepperMotor} into the database using this method :

\input{line.tex}
\begin{lyxcode}
\noindent DbDatum~velocity(\textquotedbl{}velocity\textquotedbl{}),~vel\_min(\textquotedbl{}min\textquotedbl{}),~vel\_max(\textquotedbl{}max\textquotedbl{});

\noindent DbDatum~acceleration(\textquotedbl{}acceleration\textquotedbl{}),~acc\_min(\textquotedbl{}min\textquotedbl{}),~acc\_max(\textquotedbl{}max\textquotedbl{});

\noindent DbData~db\_data;

\noindent velocity~<\textcompwordmark{}<~2;

\noindent vel\_min~<\textcompwordmark{}<~0.0;

\noindent vel\_max~<\textcompwordmark{}<~1000000.0;

\noindent db\_data.push\_back(velocity);

\noindent db\_data.push\_back(vel\_min);

\noindent db\_data.push\_back(vel\_max);

\noindent acceleration~<\textcompwordmark{}<~2;

\noindent acc\_min~<\textcompwordmark{}<~0.0;

\noindent acc\_max~<\textcompwordmark{}<~8000000;

\noindent db\_data.push\_back(acceleration);

\noindent db\_data.push\_back(acc\_min);

\noindent db\_data.push\_back(acc\_max);

\noindent db->put\_class\_attribute\_property(\textquotedbl{}StepperMotor\textquotedbl{},~db\_data);
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{\noindent void Database::delete\_class\_attribute\_property(string,
DbData\&)}

\noindent Delete a list of attribute properties for the specified
class. The attribute names are specified by the vector of DbDatum
structures. All properties belonging to the listed attributes are
deleted. Here is an example of how to delete the \emph{unit} property
of the \emph{velocity} attribute of the \emph{StepperMotor} class
from the database using this method :

\input{line.tex}
\begin{lyxcode}
\noindent DbData~db\_data;

\noindent db\_data.push\_back(DbDatum(\textquotedbl{}velocity\textquotedbl{}));

\noindent db\_data.push\_back(DbDatum(\textquotedbl{}unit\textquotedbl{}));

\noindent db->delete\_class\_attribute\_property(\textquotedbl{}StepperMotor\textquotedbl{},~db\_data);
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{vector<DbHistory> Database::get\_class\_attribute\_property\_history(string
\&devname, string \&attname, string \&propname)}

Get the list of the last 10 modifications of the specifed class attribute
property. Note that propname and attname can contain a wildcard character
(eg: \textquotedbl{}prop{*}\textquotedbl{}). An example of usage of
a similar function can be found in the documentation of the get\_property\_history()
function.

Exceptions: ConnectionFailed, CommunicationFailed, DevFailed from
device


\subsection{void Database::get\_alias(string dev\_name, string \&dev\_alias)}

Get the device alias name from its name. The device name is specified
by \emph{dev\_name} and the device alias name is returned in \emph{dev\_alias}.
If there is no alias defined for the device, a DevFailed exception
is thrown.

\emph{Exceptions: ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_AliasNotDefined)}


\subsection{void Database::get\_device\_alias(string dev\_alias, string \&dev\_name)}

\noindent Get the device name from an alias. The device alias is specified
by \emph{dev\_alias} and the device name is returned in \emph{dev\_name}.
If there is no device with the given alias, a DevFailed exception
is thrown.

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_DeviceNotDefined)}


\subsection{void Database::get\_attribute\_alias(string attr\_alias, string \&attr\_name)}

\noindent Get the full attribute name from an alias. The attribute
alias is specified by \emph{attr\_alias} and the full attribute name
is returned in \emph{attr\_name}. If there is no attribute with the
given alias, a DevFailed exception is thrown.

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{void Database::put\_attribute\_alias(string \&att\_name, string \&alias\_name)}

Set an alias for an attribute name. The attribute alias is specified
by alias\_name and the attribute name is specifed by att\_name. If
the given alias already exists, a DevFailed exception is thrown.

Exceptions: ConnectionFailed, CommunicationFailed, DevFailed from
device (DB\_SQLError)


\subsection{void Database::delete\_attribute\_alias(string \&alias\_name)}

Remove the alias associated to an attribute name.

Exceptions: ConnectionFailed, CommunicationFailed, DevFailed from
device (DB\_SQLError)


\subsection{DbDatum Database::get\_device\_alias\_list(string \&filter)}

\noindent Get device alias list. The parameter \emph{alias} is a string
to filter the alias list returned. Wildcard ({*}) is supported. For
instance, if the string alias passed as the method parameter is initialised
with only the {*} character, all the defined device alias will be
returned. The DbDatum returned by this method is initialised with
an array of strings and must be extracted into a vector<string>. If
there is no alias with the given filter, the returned array will have
a 0 size.

\input{line.tex}
\begin{lyxcode}
\noindent DbData~db\_data;

string~filter(\textquotedbl{}{*}\textquotedbl{});

\noindent 

\noindent db\_data~=~db->get\_device\_alias\_list(filter);

vector<string>~al\_list;

db\_data~>\textcompwordmark{}>~al\_list;

cout~<\textcompwordmark{}<~al\_list.size()~<\textcompwordmark{}<~\textquotedbl{}~device~alias~defined~in~db\textquotedbl{}~<\textcompwordmark{}<~endl;

for~(int~i=0;i~<~al\_list.size();i++)

~~~~cout~<\textcompwordmark{}<~\textquotedbl{}alias~=~\textquotedbl{}~<\textcompwordmark{}<~al\_list{[}i{]}~<\textcompwordmark{}<~endl;
\end{lyxcode}
\input{line.tex}

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{DbDatum Database::get\_attribute\_alias\_list(string \&filter)}

\noindent Get attribute alias list. The parameter \emph{alias} is
a string to filter the alias list returned. Wildcard ({*}) is supported.
For instance, if the string alias passed as the method parameter is
initialised with only the {*} character, all the defined attribute
alias will be returned. The DbDatum returned by this method is initialised
with an array of strings and must be extracted into a vector<string>.
If there is no alias with the given filter, the returned array will
have a 0 size.

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{void Database::put\_device\_alias(string \&dev\_name,string \&alias\_name)}

\noindent Create a device alias. Alias name has to be uniq within
a Tango control system and you will receive an exception if the alias
is already defined.

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\subsection{void Database::delete\_device\_alias(string \&alias\_name)}

\noindent Delete a device alias.

\noindent \emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed,
DevFailed from device (DB\_SQLError)}


\section{\noindent Tango::DbDevice}

\noindent A database object for a device which can be used to query
or modify properties, import and export information for a device.
This class provides an easy to use interface for device objects in
the database. It uses the methods of the Database class therefore
the reader is referred to these for the exact calling syntax and examples.
The following methods are defined for the DbDevice class :


\subsection{\noindent DbDevice::DbDevice(string \&)}

\noindent A constructor for a DbDevice object for a device in the
TANGO database specified by the TANGO\_HOST environment variable. 


\subsection{\noindent DbDevice::DbDevice(string \&, Database {*})}

\noindent A constructor for a DbDevice object for the device in the
specified database. This method reuses the Database supplied by the
programmer.


\subsection{\noindent DbDevImportInfo DbDevice::import\_device()}

\noindent Query the database for the import info of this device. Returns
a DbDevImportInfo structure.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\subsection{\noindent void DbDevice::export\_device(DbDevExportInfo\&)}

\noindent Update the export info for this device in the database.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\subsection{\noindent void DbDevice::add\_device(DbDevInfo\&)}

\noindent Add/Update this device to the database.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\subsection{\noindent void DbDevice::delete\_device()}

\noindent Delete this device from the database.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\subsection{\noindent void DbDevice::get\_property(DbData\&)}

\noindent Query the database for the list of properties of this device.
See Database::get\_device\_property() for an example of how to specify
and retrieve the properties.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\subsection{\noindent void DbDevice::put\_property(DbData\&)}

\noindent Update the list of properties for this device in the database.
See Database::put\_device\_property() for an example of how to specify
the properties.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\subsection{\noindent void DbDevice::delete\_property(DbData\&)}

\noindent Delete the list of specified properties for this device
in the database. See Database::delete\_property() for an example of
how to specify the properties.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\subsection{\noindent void DbDevice::get\_attribute\_property(DbData\&)}

\noindent Query the database for the list of attribute properties
of this device. See Database::get\_device\_attribute\_property() for
an example of how to specify and retrieve the properties.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\subsection{\noindent void DbDevice::put\_attribute\_property(DbData\&)}

\noindent Update the list of attribute properties for this device
in the database. See Database::put\_device\_attribute\_property()
for an example of how to specify the properties.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\subsection{\noindent void DbDevice::delete\_attribute\_property(DbData\&)}

\noindent Delete all properties for the list of specified attributes
for this device in the database. See Database::delete\_device\_attribute\_property()
for an example of how to specify the properties.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\section{\noindent Tango::DbClass}

\noindent A database object for a class which can be used to query
or modify class properties.


\subsection{\noindent DbClass::DbClass(string)}

\noindent A constructor for a DbClass object for a class in the TANGO
database specified by the TANGO\_HOST environment variable. 


\subsection{\noindent DbClass::DbClass(string, Database {*})}

\noindent A constructor for a DbClass object for the class in the
specified database. This method reuses the Database supplied by the
programmer.


\subsection{\noindent void DbClass::get\_property(DbData\&)}

\noindent Query the database for the list of properties of this class.
See Database::get\_class\_property() for an example of how to specify
and retrieve the properties.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\subsection{\noindent void DbClass::put\_property(DbData\&)}

\noindent Update the list of properties for this class in the database.
See Database::put\_class\_property() for an example of how to specify
the properties.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\subsection{\noindent void DbClass::delete\_property(DbData\&)}

\noindent Delete the list of specified properties for this class in
the database. See Database::delete\_property() for an example of how
to specify the properties.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\subsection{\noindent void DbClass::get\_attribute\_property(DbData\&)}

\noindent Query the database for the list of attribute properties
of this class. See Database::get\_class\_attribute\_property() for
an example of how to specify and retrieve the properties.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\subsection{\noindent void DbClass::put\_attribute\_property(DbData\&)}

\noindent Update the list of attribute properties for this class in
the database. See Database::put\_class\_attribute\_property() for
an example of how to specify the properties.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\subsection{\noindent void DbClass::delete\_attribute\_property(DbData\&)}

\noindent Delete all properties for the list of specified attributes
for this class in the database. See Database::delete\_class\_attribute\_property()
for an example of how to specify the properties.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\section{Tango::DbServer}

\noindent A database object for a device server which can be used
to query or modify server database information.


\subsection{\noindent DbServer::DbServer(string)}

\noindent A constructor for a DbServer object for a server in the
TANGO database specified by the TANGO\_HOST environment variable.


\subsection{\noindent DbServer::DbServer(string, Database {*})}

\noindent A constructor for a DbServer object for the server in the
specified database. This method reuses the Database supplied by the
programmer.


\subsection{\noindent void DbServer::add\_server(DbDevInfos \&)}

Add a group of devices to the database. The device names, server names
and classes are specified in the vector of DbDevInfo structures.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\subsection{void DbServer::delete\_server()}

Delete the device server and its associated devices from the database.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\subsection{void DbServer::export\_server(DbDevExportInfos \&)}

Export a group of device to the database. The device names, IOR, class,
server name, pid etc. are specified in the vector of DbDevExportInfo
structures.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\subsection{void DbServer::unexport\_server()}

Mark all the devices exported by the server as un exported.

\emph{Exceptions}: \emph{ConnectionFailed, CommunicationFailed, DevFailed
from device (DB\_SQLError)}


\section{\noindent Tango::DbDatum}

\noindent A single database value which has a name, type, address
and value and methods for inserting and extracting C++ native types.
This is the fundamental type for specifying database properties. Every
property has a name and has one or more values associated with it.
The values can be inserted and extracted using the operators <\textcompwordmark{}<
and >\textcompwordmark{}> respectively. A status flag indicates if
there is data in the DbDatum object or not. An additional flag allows
the user to activate exceptions. 


\subsection{\noindent Operators}

\noindent The insert and extract operators are specified for the following
C++ types :
\begin{enumerate}
\item \noindent boolean
\item unsigned char
\item \noindent short
\item \noindent unsigned short
\item \noindent DevLong
\item \noindent DevULong
\item DevLong64
\item DevULong64
\item \noindent float
\item \noindent double
\item \noindent string
\item \noindent char{*} (insert only)
\item \noindent const char {*}
\item \noindent vector<string>
\item \noindent vector<short>
\item \noindent vector<unsigned short>
\item \noindent vector<DevLong>
\item vector<DevULong>
\item vector<DevLong64>
\item vector<DevULong64>
\item \noindent vector<float>
\item \noindent vector<double>
\end{enumerate}
\noindent Here is an example of creating, inserting and extracting
some DbDatum types :

\input{line.tex}
\begin{lyxcode}
\noindent DbDatum~my\_short(\textquotedbl{}my\_short\textquotedbl{}),~my\_long(``my\_long''),~my\_string(\textquotedbl{}my\_string\textquotedbl{});

\noindent DbDatum~my\_float\_vector(\textquotedbl{}my\_float\_vector\textquotedbl{}),~my\_double\_vector(\textquotedbl{}my\_double\_vector\textquotedbl{});

\noindent string~a\_string;

\noindent short~a\_short;

\noindent DevLong~a\_long;

\noindent vector<float>~a\_float\_vector;

\noindent vector<double>~a\_double\_vector;

\noindent my\_short~<\textcompwordmark{}<~100;~//~insert~a~short

\noindent my\_short~>\textcompwordmark{}>~a\_short;~//~extract~a~short

\noindent my\_long~<\textcompwordmark{}<~1000;~//~insert~a~DevLong

\noindent my\_long~>\textcompwordmark{}>~a\_long;~//~extract~a~long

\noindent my\_string~<\textcompwordmark{}<~string(\textquotedbl{}estas~lista~a~bailar~el~tango~?\textquotedbl{});~//~insert~a~string

\noindent my\_string~>\textcompwordmark{}>~a\_string;~//~extract~a~string

\noindent my\_float\_vector~<\textcompwordmark{}<~a\_float\_vector~//~insert~a~vector~of~floats

\noindent my\_float\_vector~>\textcompwordmark{}>~a\_float\_vector;~//~extract~a~vector~of~floats

\noindent my\_double\_vector~<\textcompwordmark{}<~a\_double\_vector;~//~insert~a~vector~of~doubles

\noindent my\_double\_vector~>\textcompwordmark{}>~a\_double\_vector;~//~extract~a~vector~of~doubles
\end{lyxcode}
\input{line.tex}

\emph{Exception: WrongData if requested}


\subsection{\noindent bool DbDatum::is\_empty()}

\noindent is\_empty() is a boolean method which trues true or false
depending on whether the DbDatum object contains data or not. It can
be used to test whether a property is defined in the database or not
e.g.

\input{line.tex}
\begin{lyxcode}
\noindent sl\_props.push\_back(parity\_prop);

\noindent dbase->get\_device\_property(device\_name,~sl\_props);

\noindent if~(!~parity\_prop.is\_empty())~

\noindent \{

\noindent ~~~~parity\_prop~>\textcompwordmark{}>~parity;

\noindent \}

\noindent else

\noindent \{

\noindent ~~~~cout~<\textcompwordmark{}<~device\_name~<\textcompwordmark{}<~\textquotedbl{}~has~no~parity~defined~in~database~!\textquotedbl{}~<\textcompwordmark{}<~endl;

\noindent \}
\end{lyxcode}
\input{line.tex}

\emph{Exception: WrongData if requested}


\subsection{\noindent void DbDatum::exceptions(bitset<DbDatum::numFlags>)}

\noindent Is a method which allows the user to switch on/off exception
throwing for trying to extract data from an empty DbDatum object.
The default is to not throw exception. The following flags are supported
:
\begin{enumerate}
\item \noindent \textbf{isempty\_flag} - throw a WrongData exception (reason
= API\_EmptyDbDatum) if user tries to extract data from an empty DbDatum
object
\item \textbf{wrongtype\_flag} - throw a WrongData exception (reason = API\_IncompatibleArgumentType)
if user tries to extract data with a type different than the type
used for insertion
\end{enumerate}

\subsection{bitset<DbDatum::numFlags> exceptions()}

Returns the whole exception flags.


\subsection{void DbDatum::reset\_exceptions(DbDatum::except\_flags fl)}

Resets one exception flag


\subsection{void DbDatum::set\_exceptions(DbDatum::except\_flags fl)}

Sets one exception flag

The following is an example of how to use these exceptions related
methods

\input{line.tex}
\begin{lyxcode}
\noindent ~~~~~1~~DbDatum~da;

~~~~~2~~

~~~~~3~~bitset<DbDatum::numFlags>~bs~=~da.exceptions();

~~~~~4~~cout~<\textcompwordmark{}<~\textquotedbl{}bs~=~\textquotedbl{}~<\textcompwordmark{}<~bs~<\textcompwordmark{}<~endl;

~~~~~5~~~~~~~~~~~~~~~~~~

~~~~~6~~da.set\_exceptions(DbDatum::wrongtype\_flag);

~~~~~7~~bs~=~da.exceptions();

~~~~~8~~~~~~~~~~~~~~~~~~

~~~~~9~~cout~<\textcompwordmark{}<~\textquotedbl{}bs~=~\textquotedbl{}~<\textcompwordmark{}<~bs~<\textcompwordmark{}<~endl;
\end{lyxcode}
\input{line.tex}


\section{\noindent Tango::DbData}

\noindent A vector of Tango::DbDatum structures. DbData is used to
send or return one or more database properties or information. It
is the standard input and output type for all methods which query
and/or update properties in the database.


\section{Exception\label{sec:Exception}}

All the exception thrown by this API are Tango::DevFailed exception.
This exception is a variable length array of Tango::DevError type.
The Tango::DevError type is a four fields structure. These fields
are :
\begin{enumerate}
\item A string describing the error type. This string replaces an error
code and allows a more easy management of include files. This field
is called \textbf{reason}
\item A string describing in plain text the reason of the error. This field
is called \textbf{desc}
\item A string giving the name of the method which thrown the exception.
This field is named \textbf{origin}
\item The error severity. This is an enumeration with three values which
are WARN, ERR or PANIC. Its name is \textbf{severity}
\end{enumerate}
This is a variable length array in order to transmit to the client
what is the primary error reason. The sequence element 0 describes
the primary error. An exception class hierarchy has been implemented
within the API to ease API programmers task. All the exception classes
inherits from the Tango::DevFailed class. Except for the \emph{NamedDevFaildeList}
exception class, they don't add any new fields to the exception, they
just allow easy \textquotedbl{}catching\textquotedbl{}. Exception
classes thrown only by the API layer are :
\begin{itemize}
\item ConnectionFailed\index{ConnectionFailed} 
\item CommunicationFailed\index{CommunicationFailed}
\item WrongNameSyntax\index{WrongNameSyntax}
\item NonDbDevice\index{NonDbDevice}
\item WrongData\index{WrongData}
\item NonSupportedFeature\index{NonSupportedFeature}
\item AsynCall\index{AsynCall}
\item AsynReplyNotArrived\index{AsynReplyNotArrived}
\item EventSystemFailed\index{EventSystemFailed}
\item NamedDevFailedList\index{NamedDevFailedList}
\item DeviceUnlocked\index{DeviceUnlocked}
\end{itemize}
On top of these classes, exception thrown by the device (Tango::DevFailed
exception) are directly passed to the client.


\subsection{The ConnectionFailed exception}

This exception is thrown when a problem occurs during the connection
establishment between the application and the device. The API is stateless.
This means that DeviceProxy constructors filter most of the exception
except for cases described in the following table.

\vspace{0.3cm}


\begin{center}
\begin{longtable}{|c|c|c|c|c|}
\hline 
Method name & device type & error type & Level & reason\tabularnewline
\hline 
\hline 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{} & TANGO\_HOST not set & 0 & API\_TangoHostNotSet\tabularnewline
\cline{3-5} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{with} & \multicolumn{1}{c|}{Device not defined in db} & 0 & DB\_DeviceNotDefined\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{ database} & \multicolumn{1}{c|}{or} & 1 & API\_CommandFailed\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{DeviceProxy} & \multicolumn{1}{c|}{} & Alias not defined in db & 2 & API\_DeviceNotDefined\tabularnewline
\cline{2-5} 
\multicolumn{1}{|c|}{constructor} & \multicolumn{1}{c|}{with database} & \multicolumn{1}{c|}{Database server} & 0 & API\_CorbaException\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{specified in dev name} & not running & 1 & API\_CantConnectToDatabase\tabularnewline
\cline{2-5} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{without} & \multicolumn{1}{c|}{Server running but device} & 0 & API\_CorbaException\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{} & database & not defined in server & 1 & API\_DeviceNotExported\tabularnewline
\hline 
\multicolumn{1}{|c|}{} &  & TANGO\_HOST not set & 0 & API\_TangoHostNotSet\tabularnewline
\cline{3-5} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{} &  & \multicolumn{1}{c|}{0} & DB\_DeviceNotDefined\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{} &  & Device not defined in db & \multicolumn{1}{c|}{1} & \multicolumn{1}{c|}{API\_CommandFailed}\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{AttributeProxy} & \multicolumn{1}{c|}{with} &  & 2 & API\_DeviceNotDefined\tabularnewline
\cline{3-5} 
\multicolumn{1}{|c|}{constructor} & \multicolumn{1}{c|}{database} & \multicolumn{1}{c|}{} & 0 & DB\_SQLError\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{Alias not defined in db} & 1 & API\_CommandFailed\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{} &  &  & 2 & API\_AliasNotDefined\tabularnewline
\cline{2-5} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{with database} & \multicolumn{1}{c|}{Database server} & 0 & API\_CorbaException\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{} & specified in dev name & not running & 1 & API\_CantConnectToDatabase\tabularnewline
\hline 
\multicolumn{1}{|c|}{DeviceProxy} & \multicolumn{1}{c|}{without} & \multicolumn{1}{c|}{Server not} & 0 & API\_CorbaException\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{or} & database & running & 1 & API\_ServerNotRunning\tabularnewline
\cline{2-5} 
\multicolumn{1}{|c|}{AttributeProxy} & \multicolumn{1}{c|}{} & Server not running & 0 & API\_DeviceNotExported\tabularnewline
\cline{3-5} 
\multicolumn{1}{|c|}{method call} & \multicolumn{1}{c|}{with} & \multicolumn{1}{c|}{Dead } & 0 & API\_CorbaException\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{(except} & \multicolumn{1}{c|}{database} & server & 1 & API\_CantConnectToDevice\tabularnewline
\cline{3-5} 
\multicolumn{1}{|c|}{cmd\_inout} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{Dead database server} & 0 & API\_CorbaException\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{read\_attribute)} &  & when reconnection needed & 1 & API\_CantConnectToDatabase\tabularnewline
\hline 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{without} & \multicolumn{1}{c|}{Server} & 0 & API\_CorbaException\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{DeviceProxy} & \multicolumn{1}{c|}{database} & \multicolumn{1}{c|}{not} & 1 & API\_ServerNotRunning\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{cmd\_inout } &  & running & 2 & API\_CommandFailed\tabularnewline
\cline{2-5} 
\multicolumn{1}{|c|}{and} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{Server } & 0 & API\_DeviceNotExported\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{read\_attribute} & \multicolumn{1}{c|}{} & not running & 1 & API\_CommandFailed\tabularnewline
\cline{3-5} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} & 0 & API\_CorbaException\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{or} & \multicolumn{1}{c|}{with} & \multicolumn{1}{c|}{Dead} & 1 & API\_CantConnectToDevice\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{AttributeProxy} & \multicolumn{1}{c|}{database} & \multicolumn{1}{c|}{server} & \multicolumn{1}{c|}{2} & \multicolumn{1}{c|}{API\_CommandFailed}\tabularnewline
\multicolumn{1}{|c|}{read} & \multicolumn{1}{c|}{} &  &  & or API\_AttributeFailed\tabularnewline
\cline{3-5} 
\multicolumn{1}{|c|}{and} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{Dead database} & 0 & API\_CorbaException\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{write} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{server when reconnection} & 1 & API\_CantConnectToDatabase\tabularnewline
\cline{4-5} 
\multicolumn{1}{|c|}{} &  & needed & 2 & API\_CommandFailed\tabularnewline
\hline 
\end{longtable}
\par\end{center}

\vspace{0.3cm}


The desc DevError structure field allows a user to get more precise
information. These informations are :
\begin{description}
\item [{DB\_DeviceNotDefined}] The name of the device not defined in the
database
\item [{API\_CommandFailed}] The device and command name
\item [{API\_CantConnectToDevice}] The device name
\item [{API\_CorbaException}] The name of the CORBA exception, its reason,
its locality, its completed flag and its minor code
\item [{API\_CantConnectToDatabase}] The database server host and its port
number
\item [{API\_DeviceNotExported}] The device name
\end{description}

\subsection{The CommunicationFailed exception}

This exception is thrown when a communication problem is detected
during the communication between the client application and the device
server. It is a two levels Tango::DevError structure. In case of time-out,
the DevError structures fields are:

\vspace{0.3cm}


\begin{center}
\begin{longtable}{|c|c|c|c|}
\hline 
Level & Reason & Desc & Severity\tabularnewline
\hline 
\hline 
0 & API\_CorbaException & CORBA exception fields translated into a string & ERR\tabularnewline
\hline 
1 & API\_DeviceTimedOut & String with time-out value and device name & ERR\tabularnewline
\hline 
\end{longtable} 
\par\end{center}

\vspace{0.3cm}


For all other communication errors, the DevError structures fields
are:

\vspace{0.3cm}


\begin{center}
\begin{longtable}{|c|c|m{60mm}|c|}
\hline 
Level & Reason & \multicolumn{1}{c|}{Desc} & Severity\tabularnewline
\hline 
\hline 
0 & API\_CorbaException & CORBA exception fields translated into a string & ERR\tabularnewline
\hline 
1 & API\_CommunicationFailed & String with device, method, command/attribute name & ERR\tabularnewline
\hline 
\end{longtable}
\par\end{center}

\vspace{0.3cm}



\subsection{The WrongNameSyntax exception}

This exception has only one level of Tango::DevError structure. The
possible value for the reason field are :
\begin{description}
\item [{API\_UnsupportedProtocol}] This error occurs when trying to build
a DeviceProxy or an AttributeProxy instance for a device with an unsupported
protocol. Refer to the appendix on device naming syntax to get the
list of supported database modifier
\item [{API\_UnsupportedDBaseModifier}] This error occurs when trying to
build a DeviceProxy or an AttributeProxy instance for a device/attribute
with a database modifier unsupported. Refer to the appendix on device
naming syntax to get the list of supported database modifier
\item [{API\_WrongDeviceNameSyntax}] This error occurs for all the other
error in device name syntax. It is thrown by the DeviceProxy class
constructor.
\item [{API\_WrongAttributeNameSyntax}] This error occurs for all the other
error in attribute name syntax. It is thrown by the AttributeProxy
class constructor.
\item [{API\_WrongWildcardUsage}] This error occurs if there is a bad usage
of the wildcard character
\end{description}

\subsection{The NonDbDevice exception}

This exception has only one level of Tango::DevError structure. The
reason field is set to API\_NonDatabaseDevice. This exception is thrown
by the API when using the DeviceProxy or AttributeProxy class database
access for non-database device.


\subsection{The WrongData exception}

This exception has only one level of Tango::DevError structure. The
possible value for the reason field are :
\begin{description}
\item [{API\_EmptyDbDatum}] This error occurs when trying to extract data
from an empty DbDatum object
\item [{API\_IncompatibleArgumentType}] This error occurs when trying to
extract data with a type different than the type used to send the
data
\item [{API\_EmptyDeviceAttribute}] This error occurs when trying to extract
data from an empty DeviceAttribute object
\item [{API\_IncompatibleAttrArgumentType}] This error occurs when trying
to extract attribute data with a type different than the type used
to send the data
\item [{API\_EmptyDeviceData}] This error occurs when trying to extract
data from an empty DeviceData object
\item [{API\_IncompatibleCmdArgumentType}] This error occurs when trying
to extract command data with a type different than the type used to
send the data
\end{description}

\subsection{The NonSupportedFeature exception}

This exception is thrown by the API layer when a request to a feature
implemented in Tango device interface release n is requested for a
device implementing Tango device interface n-x. There is one possible
value for the reason field which is API\_UnsupportedFeature.


\subsection{The AsynCall exception}

This exception is thrown by the API layer when a the asynchronous
model id badly used. This exception has only one level of Tango::DevError
structure. The possible value for the reason field are :
\begin{description}
\item [{API\_BadAsynPollId}] This error occurs when using an asynchronous
request identifier which is not valid any more.
\item [{API\_BadAsyn}] This error occurs when trying to fire callback when
no callback has been previously registered
\item [{API\_BadAsynReqType}] This error occurs when trying to get result
of an asynchronous request with an asynchronous request identifier
returned by a non-coherent asynchronous request (For instance, using
the asynchronous request identifier returned by a \emph{command\_inout\_asynch()}
method with a \emph{read\_attribute\_reply()} attribute).
\end{description}

\subsection{The AsynReplyNotArrived exception}

This exception is thrown by the API layer when:
\begin{itemize}
\item a request to get asynchronous reply is made and the reply is not yet
arrived
\item a blocking wait with timeout for asynchronous reply is made and the
timeout expired.
\end{itemize}
There is one possible value for the reason field which is API\_AsynReplyNotArrived.


\subsection{The EventSystemFailed exception}

This exception is thrown by the API layer when subscribing or unsubscribing
from an event failed. This exception has only one level of Tango::DevError
structure. The possible value for the reason field are :
\begin{description}
\item [{API\_NotificationServiceFailed}] This error occurs when the \emph{subscribe\_event()}
method failed trying to access the CORBA notification service
\item [{API\_EventNotFound}] This error occurs when you are using an incorrect
event\_id in the \emph{unsubscribe\_event()} method
\item [{API\_InvalidArgs}] This error occurs when NULL pointers are passed
to the subscribe or unsubscribe event methods
\item [{API\_MethodArgument}] This error occurs when trying to subscribe
to an event which has already been subsribed to
\item [{API\_DSFailedRegisteringEvent}] This error means that the device
server to which the device belongs to failed when it tries to register
the event. Most likely, it means that there is no event property defined
\item [{API\_EventNotFound}] Occurs when using a wrong event identifier
in the \emph{unsubscribe\_event} method
\end{description}

\subsection{The NamedDevFailedList\index{NamedDevFailedList} exception\label{sub:The-NamedDevFailedList-exception}}

This exception is only thrown by the \emph{DeviceProxy::write\_attributes()\index{write-attributes}}
method. In this case, it is necessary to have a new class of exception
to transfer the error stack for several attribute(s) which failed
during the writing. Therefore, this exception class contains for each
attributes which failed :
\begin{itemize}
\item The name of the attribute
\item Its index in the vector passed as argumen tof the write\_attributes()
method
\item The error stack as described in \ref{sec:Exception}
\end{itemize}

\subsubsection{long NamedDevFailedList::get\_faulty\_attr\_nb()\index{get-faulty-attr-nb}}

Returns the number of attributes which failed during the write\_attribute
call.


\subsubsection{vector<NamedDevFailed> NamedDevErrorList::err\_list}

Public data member of the NamedDevFailedList. There is one element
in this vector for each attribute which failed during its writing.


\subsubsection{string NamedDevFailed::name\index{NamedDevFailed}}

Public data member of the NamedDevFailed class. It contains the name
of the attribute which failed.


\subsubsection{long NamedDevFailed::idx\_in\_call}

Public data member of the NamedDevFailed class. It contains the index
in the write\_attributes method parameter vector of the attribute
which failed.


\subsubsection{DevErrorList NamedDevFailed::err\_stack}

Public data member of the NamedDevFailed class. This is the error
stack.

The following piece of code is an example of how to use this class
exception

\input{line.tex}
\begin{lyxcode}
\noindent catch~(Tango::NamedDevFailed~\&e)

\{

~~~long~nb\_faulty~=~e.get\_faulty\_attr\_nb();

~~~for~(long~i~=~0;i~<~nb\_faulty;i++)

~~~\{

~~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Attribute~\textquotedbl{}~<\textcompwordmark{}<~e.err\_list{[}i{]}.name~<\textcompwordmark{}<~\textquotedbl{}~failed!\textquotedbl{}~<\textcompwordmark{}<~endl;

~~~~~~~for~(long~j~=~0;j~<~e.err\_list{[}i{]}.err\_stack.length();j++)

~~~~~~~\{

~~~~~~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Reason~{[}\textquotedbl{}~<\textcompwordmark{}<~j~<\textcompwordmark{}<~\textquotedbl{}{]}~=~\textquotedbl{}~<\textcompwordmark{}<~e.err\_list{[}i{]}.err\_stack{[}j{]}.reason;

~~~~~~~~~~~cout~<\textcompwordmark{}<~\textquotedbl{}Desc~{[}\textquotedbl{}~<\textcompwordmark{}<~j~<\textcompwordmark{}<~\textquotedbl{}{]}~=~\textquotedbl{}~<\textcompwordmark{}<~e.err\_list{[}i{]}.err\_stack{[}j{]}.desc;

~~~~~~~\}

~~~\}

\}
\end{lyxcode}
\input{line.tex}

This exception inherits from Tango::DevFailed. It is possible to catch
it with a \textquotedbl{}catch DevFailed\textquotedbl{} catch block.
In this case, like any other DevFailed exception, there is only one
error stack. This stack is initialised with the name of all the attributes
which failed in its \textquotedbl{}reason\textquotedbl{} field.


\subsection{The DeviceUnlocked\index{DeviceUnlocked} exception}

This exception is thrown by the API layer when a device locked by
the process has been unlocked by an admin client. This exception has
two levels of Tango::DevError structure. There is only possible value
for the reason field which is
\begin{description}
\item [{API\_DeviceUnlocked}] The device has been unlocked by another client
(administration client)
\end{description}
The first level is the message reported by the Tango kernel from the
server side. The second layer is added by the client API layer with
informations on which API call generates the exception and device
name.


\section{Reconnection and exception\label{sec:Reconnection-and-exception}}

The Tango API automatically manages re-connection between client and
server in case of communication error during a network access between
a client and a server. The transparency reconnection mode allows a
user to be (or not be) informed that automatic reconnection took place.
If the transparency reconnection mode is not set, when a communication
error occurs, an exception is returned to the caller and the connection
is internally marked as bad. On the next try to contact the device,
the API will try to re-build the network connection. If the transparency
reconnection mode is set, the API will try to re-build the network
connection has soon as the communication error occurs and the caller
is not informed. Several cases are possible. They are summarized in
the following table:

\vspace{0.3cm}


\begin{center}
\begin{longtable}{|c|m{45mm}|c|m{35mm}|m{35mm}|}
\hline 
Case & Server state & call nb & exception (transparency false) & exception (transparency true)\tabularnewline
\hline 
\hline 
\multicolumn{1}{|c|}{} & Server killed before call n & n & CommunicationFailed & ConnectionFailed\tabularnewline
\cline{2-5} 
\multicolumn{1}{|c|}{Server killed} & down & n+1 & ConnectionFailed(2 levels) & idem\tabularnewline
\cline{2-5} 
\multicolumn{1}{|c|}{and re-started} & down & n + 2 & idem & idem\tabularnewline
\cline{2-5} 
\multicolumn{1}{|c|}{} & Running & n + x & No exception & No exception\tabularnewline
\hline 
\hline 
 & Server died before call n & n & CommunicationFailed & ConnectionFailed\tabularnewline
\cline{2-5} 
\multicolumn{1}{|c|}{Server died} & died & n + 1 & ConnectionFailed (3 levels) & idem\tabularnewline
\cline{2-5} 
\multicolumn{1}{|c|}{and re-started} & died & n + 2 & idem & idem\tabularnewline
\cline{2-5} 
\multicolumn{1}{|c|}{} & Running & n + x & No exception & No exception\tabularnewline
\hline 
\hline 
\multicolumn{1}{|c|}{Server killed} & Server killed and re-started before call n & n & CommunicationFailed & No exception\tabularnewline
\cline{2-5} 
\multicolumn{1}{|c|}{and re-started} & Running & n+x & No exception & No exception\tabularnewline
\hline 
\hline 
\multicolumn{1}{|c|}{Server died} & Server died and re-started before call n & n & CommunicationFailed & No exception\tabularnewline
\cline{2-5} 
\multicolumn{1}{|c|}{and re-started} & Running & n + x & No exception & No exception\tabularnewline
\hline 
\end{longtable}
\par\end{center}

\vspace{0.3cm}


Please note that the timeout case is managed differently because it
will not enter the re-connection system. The transparency reconnection
mode is set by default to true for Tango version 5.5!
\end{document}
