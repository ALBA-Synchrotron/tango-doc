#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage{a4wide}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding latin1
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 5
\tocdepth 4
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
The TANGO C++ Application Programmer Interface
\begin_inset CommandInset label
LatexCommand label
name "cha:The-TANGO-C++"

\end_inset


\end_layout

\begin_layout Section
Tango::DeviceProxy()
\end_layout

\begin_layout Standard
The high level object which provides the client with an easy-to-use interface
 to TANGO devices.
 DeviceProxy is a handle to the real Device (hence the name Proxy) and is
 not the real Device (of course).
 DeviceProxy provides interfaces to all TANGO Device interfaces.
 The DeviceProxy manages timeouts, stateless connections (new DeviceProxy()
 nearly always works), and reconnection if the device server is restarted.
\end_layout

\begin_layout Subsection
Constructors
\end_layout

\begin_layout Subsubsection
DeviceProxy::DeviceProxy(string &name, CORBA::ORB *orb=NULL)
\end_layout

\begin_layout Standard
Create a DeviceProxy to a device of the specified name.
 The TANGO_HOST environment variable is used to determine which TANGO database
 to connect to.
 The client can specify an ORB as argument if she wants to.
 The constructor will connect to the TANGO database, query for the client's
 network address and build a connection to the device.
 If the device is defined in the TANGO database but the device server is
 not running DeviceProxy will try to build a connection every time the client
 tries to access the device.
 If the device is not defined an exception is thrown.
 Example :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
DeviceProxy *my_device = new DeviceProxy(
\begin_inset Quotes eld
\end_inset

my/own/device
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
See appendix on device naming for all details about Tango device naming
 syntax.
 If an alias
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
alias
\end_layout

\end_inset

 name is defined for the device, this alias name can be used to create the
 DeviceProxy instance.
\end_layout

\begin_layout Standard

\emph on
Exception: WrongNameSyntax, ConnectionFailed
\end_layout

\begin_layout Subsubsection
DeviceProxy::DeviceProxy(const char *name, CORBA::ORB *orb = NULL)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsection
Miscellaneous methods
\end_layout

\begin_layout Subsubsection
DeviceInfo DeviceProxy::info()
\end_layout

\begin_layout Standard
A method which returns information on the device in a DeviceInfo structure.
 Example :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
cout << " device info : " << endl 
\end_layout

\begin_layout Verbatim
DeviceInfo dev_info = my_device->info() << endl;
\end_layout

\begin_layout Verbatim
cout << " dev_class " << dev_info.dev_class;
\end_layout

\begin_layout Verbatim
cout << " server_id " << dev_info.server_id;
\end_layout

\begin_layout Verbatim
cout << " server_host " << dev_info.server_host;
\end_layout

\begin_layout Verbatim
cout << " server_version " << dev_info.server_version;
\end_layout

\begin_layout Verbatim
cout << " doc_url " << dev_info.doc_url;
\end_layout

\begin_layout Verbatim
cout << " device_type " << dev_info.dev_type;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
All DeviceInfo fields are strings except for the server_version server_version
 which is a long integer.
\end_layout

\begin_layout Standard

\emph on
Exception: Connection Failed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
DevState DeviceProxy::state()
\end_layout

\begin_layout Standard
A method which return the state of the device as a Tango::DevState type.
 Example :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
dev_state = my_device->state() << endl;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed
\end_layout

\begin_layout Subsubsection
string DeviceProxy::status()
\end_layout

\begin_layout Standard
A method which return the status of the device as a string.
 Example :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
cout << "device status " << my_device->status() << endl;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed
\end_layout

\begin_layout Subsubsection
int DeviceProxy::ping()
\end_layout

\begin_layout Standard
A method which sends a ping to the device and returns the time elapsed as
 microseconds.
 Example :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
cout << " device ping took " << my_device->ping() << " microseconds" <<
 endl;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed
\end_layout

\begin_layout Subsubsection
void DeviceProxy::set_timeout_millis(int timeout)
\end_layout

\begin_layout Standard
Set client side timeout for device in milliseconds.
 Any method which takes longer than this time to execute will throw an exception.
\end_layout

\begin_layout Standard

\emph on
Exception: none
\end_layout

\begin_layout Subsubsection
int DeviceProxy::get_timeout_millis()
\end_layout

\begin_layout Standard
Get the client side timeout in milliseconds.
\end_layout

\begin_layout Standard

\emph on
Exception: none
\end_layout

\begin_layout Subsubsection
int DeviceProxy::get_idl_version()
\end_layout

\begin_layout Standard
Get the version of the Tango Device IDL interface implemented by the device
\end_layout

\begin_layout Standard

\emph on
Exception: none
\end_layout

\begin_layout Subsubsection
void DeviceProxy::set_source(DevSource source)
\end_layout

\begin_layout Standard
Set the data source (device, polling buffer, polling buffer than device)
 for command_inout and read_attribute methods.
 The DevSource is an enumerated type which can be one of {DEV, CACHE, CACHE_DEV}.
 The default value is CACHE_DEV.
 See chapter on Advanced Feature for all details regarding polling.
\end_layout

\begin_layout Standard

\emph on
Exception: none
\end_layout

\begin_layout Subsubsection
DevSource DeviceProxy::get_source()
\end_layout

\begin_layout Standard
Get the device data source used by command_inout or read_attribute methods.
 The DevSource is an enumerated type which can be one of {DEV, CACHE, CACHE_DEV}.
 See chapter on Advanced Feature for all details regarding polling.
\end_layout

\begin_layout Standard

\emph on
Exception: none
\end_layout

\begin_layout Subsubsection
vector<string> *DeviceProxy::black_box(int n)
\end_layout

\begin_layout Standard
Get the last n commands executed on the device server and return a pointer
 to a vector of strings containing the date, time, command, and from which
 client computer the command was executed.
 This method allocates memory for the vector of strings returned to the
 caller.
 It is the caller responsibility to delete this memory.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
string DeviceProxy::name()
\end_layout

\begin_layout Standard
Return the device name (from the device itself)
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed
\end_layout

\begin_layout Subsubsection
string DeviceProxy::adm_name()
\end_layout

\begin_layout Standard
Returns the name of the corresponding administrator device.
 This is useful if you need to send an administration command to the device
 server e.g.
 restart it.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed
\end_layout

\begin_layout Subsubsection
string DeviceProxy::dev_name()
\end_layout

\begin_layout Standard
Return the device name as it is stored locally
\end_layout

\begin_layout Subsubsection
string DeviceProxy::description()
\end_layout

\begin_layout Standard
Returns the device description as a string.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Subsubsection
DbDevImportInfo DeviceProxy::import_info()
\end_layout

\begin_layout Standard
Query the device for import info from the database.
 This method returns a DbDevImprtInfo type.
 The DbDevImportInfo type is a struct defined as follows :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
class DbDevImportInfo { 
\end_layout

\begin_layout Verbatim
public : 
\end_layout

\begin_layout Verbatim
    string name; 
\end_layout

\begin_layout Verbatim
    long exported; 
\end_layout

\begin_layout Verbatim
    string ior; 
\end_layout

\begin_layout Verbatim
    string version; }; 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: NonDbDevice
\end_layout

\begin_layout Subsubsection
void DeviceProxy::set_transparency_reconnection(bool flag)
\end_layout

\begin_layout Standard
If flag is true, no exception will be thrown in case of network communication
 error between client and server.
 The API will try to re-build the network connection between client and
 server as soon as an error is detected.
 See 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Reconnection-and-exception"

\end_inset

 more more details on reconnection and exception
\end_layout

\begin_layout Subsubsection
bool DeviceProxy::get_transparency_reconnection()
\end_layout

\begin_layout Standard
Returns the transparency reconnection flag.
\end_layout

\begin_layout Subsubsection
string DeviceProxy::alias()
\end_layout

\begin_layout Standard
Returns the device alias name if one is defined otherwise, throws a DevFailed
 exception with the reason field set to Db_AliasNotDefined.
\end_layout

\begin_layout Subsubsection
AccessControlType DeviceProxy::get_access_right()
\end_layout

\begin_layout Standard
Returns the device access right.
 AccessControlType is one enumeration with 2 values which are ACCESS_READ
 and ACCESS_WRITE.
 In case the Tango Access Control systemis not used, ACCESS_WRITE is returned.
\end_layout

\begin_layout Subsection
Synchronous command oriented methods
\end_layout

\begin_layout Subsubsection
CommandInfo DeviceProxy::command_query(string command)
\end_layout

\begin_layout Standard
Query the device for information about a single command.
 This command returns a single CommandInfo type.
 The CommandInfo type is a struct described in command_list_query().
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
CommandInfoList *DeviceProxy::command_list_query()
\end_layout

\begin_layout Standard
Query the device for info on all commands.
 This method returns a vector of CommandInfo types.
 This method allocates memory for the vector of CommandInfo returned to
 the caller.
 It is the caller responsibility to delete this memory.
 The CommandInfo type is a struct defined as follows :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
typedef _CommandInfo
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
    string           cmd_name;      /* command name as ascii string */
\end_layout

\begin_layout Verbatim
    long             cmd_tag;       /* command as binary value (for TACO)
 */
\end_layout

\begin_layout Verbatim
    long             in_type;       /* in type as binary value */
\end_layout

\begin_layout Verbatim
    long             out_type;      /* out type as binary value */
\end_layout

\begin_layout Verbatim
    string           in_type_desc;  /* description of in type (optional)
 */
\end_layout

\begin_layout Verbatim
    string           out_type_desc; /* description of out type (optional)
 */
\end_layout

\begin_layout Verbatim
    Tango::DispLevel disp_level;    /* Command display level */
\end_layout

\begin_layout Verbatim
} CommandInfo;
\end_layout

\begin_layout Verbatim
typedef CommandInfoList vector<CommandInfo>;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
DeviceData DeviceProxy::command_inout(string)
\end_layout

\begin_layout Standard
Execute a command on a device which takes no input arguments (void).
 The result is returned in a DeviceData object (cf.
 below how to insert and extract data from DeviceData).
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked, DevFailed
 from device
\end_layout

\begin_layout Subsubsection
DeviceData DeviceProxy::command_inout(const char *)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsubsection
DeviceData Deviceproxy::command_inout(string, DeviceData &)
\end_layout

\begin_layout Standard
Execute a command on a device.
 Input arguments are passed in a DeviceData object, output is returned as
 a DeviceData object (see below on how to insert and extract data from DeviceDat
a).
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked, DevFailed
 from device
\end_layout

\begin_layout Subsubsection
DeviceData DeviceProxy::command_inout(const char *, DeviceData &)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsubsection
vector<DeviceDataHistory> *command_history(string &, int)
\end_layout

\begin_layout Standard
Retrieve command history from the command polling buffer.
 The first argument is the command name.
 The second argument is the wanted history depth.
 This method returns a vector of DeviceDataHistory types.
 This method allocates memory for the vector of DeviceDataHistory returned
 to the caller.
 It is the caller responsibility to delete this memory.
 Class DeviceDataHistory is detailed on chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "DataHistory"

\end_inset

.
 See chapter on Advanced Feature for all details regarding polling.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DeviceProxy dev = new DeviceProxy("..."); 
\end_layout

\begin_layout Verbatim
vector<DeviceDataHistory> *hist;
\end_layout

\begin_layout Verbatim
hist = dev->command_history("Status",5);
\end_layout

\begin_layout Verbatim
\noindent
for (int i = 0;i < 5;i++) 
\end_layout

\begin_layout Verbatim
\noindent
{
\end_layout

\begin_layout Verbatim
\noindent

\end_layout

\begin_layout Verbatim
    bool fail = (*hist)[i].failed();
\end_layout

\begin_layout Verbatim
    if (fail == false)
\end_layout

\begin_layout Verbatim
    {
\end_layout

\begin_layout Verbatim
        string str;
\end_layout

\begin_layout Verbatim
        (*hist)[i] >> str;
\end_layout

\begin_layout Verbatim
        cout << "Status = " << str << endl;
\end_layout

\begin_layout Verbatim
    }
\end_layout

\begin_layout Verbatim
    else
\end_layout

\begin_layout Verbatim
    {
\end_layout

\begin_layout Verbatim
        cout << "Command failed !" << endl;
\end_layout

\begin_layout Verbatim
        cout << "Error level 0 desc = " << ((*hist)[i].errors())[0].desc <<
 endl;
\end_layout

\begin_layout Verbatim
    }
\end_layout

\begin_layout Verbatim
    cout << "Date = " << (*hist)[i].date().tv_sec << endl;
\end_layout

\begin_layout Verbatim
\noindent
}
\end_layout

\begin_layout Verbatim
delete hist;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
NonSupportedFeature, ConnectionFailed, CommunicationFailed, DevFailed from
 device
\end_layout

\begin_layout Subsubsection
DeviceDataHistoryList *command_history(const char *, int)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsection
Synchronous attribute related methods
\end_layout

\begin_layout Subsubsection
Compatibility between Tango release 4 and release 5 regarding attribute
 properties
\end_layout

\begin_layout Standard
Between Tango V4 and Tango V5, attribute configuration has been modified
 to incorporate alarm and event related parameters.
 This explains why it exists two structure types for attribute configuration
 parameters.
 All Tango V4 parameters are defined in a structure called 
\series bold
AttributeInfo
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
AttributeInfo
\end_layout

\end_inset


\series default
 and a new structure called 
\series bold
AttributeInfoEx
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
AttributeInfoEx
\end_layout

\end_inset

 has been defined for all Tango V5 parameters.
 Nevertheless, AttributeInfoEx inherits from AttributeInfo and it is always
 possible to call the Tango V5 
\emph on
DeviceProxy::attribute_query()
\emph default
 method and to store its result in one AttributeInfo structure thus allowing
 compatibility
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
compatibility
\end_layout

\end_inset

 for client written for Tango V4 but linked with Tango V5.
 It is also possible for a client written and linked with Tango V5 to call
 Tango V5 
\emph on
DeviceProxy::attribute_query()
\emph default
 method to all kind of Tango devices.
 For device using Tango V4, the alarm and event related parameters will
 be retrieved from the database instead of from the device.
\end_layout

\begin_layout Subsubsection
AttributeInfoEx DeviceProxy::attribute_query(string attribute)
\end_layout

\begin_layout Standard
Query the device for information about a single attribute.
 This command returns a single AttributeInfoEx type which inherits from
 the AttributeInfo type.
 The AttributeInfoEx and AttributeInfo types are structures described in
 get_attribute_config() and get_attribute_config_ex().
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
AttributeInfoList * DeviceProxy::attribute_list_query()
\end_layout

\begin_layout Standard
Query the device for info on all attributes.
 This method returns a vector of AttributeInfo types.
 The AttributeInfo type is a structure described in get_attribute_config().
 This method allocates memory for the vector of AttributeInfo structures
 returned to the caller.
 It is the caller responsibility to delete this memory.
\end_layout

\begin_layout Subsubsection
AttributeInfoListEx * DeviceProxy::attribute_list_query_ex()
\end_layout

\begin_layout Standard
Query the device for info on all attributes.
 This method returns a vector of AttributeInfoEx types.
 The AttributeInfoEx type is a structure described in get_attribute_config_ex().
 This method allocates memory for the vector of AttributeInfoEx structures
 returned to the caller.
 It is the caller responsibility to delete this memory.
\end_layout

\begin_layout Subsubsection
vector<string> *DeviceProxy::get_attribute_list()
\end_layout

\begin_layout Standard
Return the names of all attributes implemented for this device as a vector
 of strings.
 This method allocates memory for the vector of strings returned to the
 caller.
 It is the caller responsibility to delete this memory.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
AttributeInfoList *DeviceProxy::get_attribute_config(vector<string>&)
\end_layout

\begin_layout Standard
Return the attribute configuration for the list of specified attributes.
 To get all the attributes pass a vector containing the string AllAttr (defined
 in tango_const.h).
 This method allocates memory for the vector of AttributeInfo returned to
 the caller.
 It is the caller responsibility to delete this memory.
 AttributeInfo is a struct defined as follows :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
typedef struct _AttributeInfo
\end_layout

\begin_layout Verbatim
{ 
\end_layout

\begin_layout Verbatim
   string             name; 
\end_layout

\begin_layout Verbatim
   AttrWriteType      writable; 
\end_layout

\begin_layout Verbatim
   AttrDataFormat     data_format; 
\end_layout

\begin_layout Verbatim
   int                data_type; 
\end_layout

\begin_layout Verbatim
   int                max_dim_x; 
\end_layout

\begin_layout Verbatim
   int                max_dim_y; 
\end_layout

\begin_layout Verbatim
   string             description; 
\end_layout

\begin_layout Verbatim
   string             label; 
\end_layout

\begin_layout Verbatim
   string             unit; 
\end_layout

\begin_layout Verbatim
   string             standard_unit; 
\end_layout

\begin_layout Verbatim
   string             display_unit; 
\end_layout

\begin_layout Verbatim
   string             format; 
\end_layout

\begin_layout Verbatim
   string             min_value; 
\end_layout

\begin_layout Verbatim
   string             max_value; 
\end_layout

\begin_layout Verbatim
   string             min_alarm; 
\end_layout

\begin_layout Verbatim
   string             max_alarm; 
\end_layout

\begin_layout Verbatim
   string             writable_attr_name; 
\end_layout

\begin_layout Verbatim
   vector<string>     extensions; 
\end_layout

\begin_layout Verbatim
   Tango::DispLevel   disp_level;
\end_layout

\begin_layout Verbatim
} AttributeInfo; 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
AttributeInfoListEx *DeviceProxy::get_attribute_config_ex(vector<string>&)
\end_layout

\begin_layout Standard
Return the extended attribute configuration for the list of specified attributes.
 To get all the attributes pass a vector containing the string AllAttr (defined
 in tango_const.h).
 This method allocates memory for the vector of AttributeInfoEx returned
 to the caller.
 It is the caller responsibility to delete this memory.
 AttributeInfoEx is a structure defined as follows :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
struct AttributeInfoEx: public AttributeInfo
\end_layout

\begin_layout Verbatim
{ 
\end_layout

\begin_layout Verbatim
   AttributeAlarmInfo alarms; 
\end_layout

\begin_layout Verbatim
   AttributeEventInfo events;
\end_layout

\begin_layout Verbatim
   vector<string>     sys_extensions; 
\end_layout

\begin_layout Verbatim
};
\end_layout

\begin_layout Verbatim
\noindent
 
\end_layout

\begin_layout Verbatim
struct AttributeAlarmInfo
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
   string           min_alarm;
\end_layout

\begin_layout Verbatim
   string           max_alarm;
\end_layout

\begin_layout Verbatim
   string           min_warning;
\end_layout

\begin_layout Verbatim
   string           max_warning;
\end_layout

\begin_layout Verbatim
   string           delta_t;
\end_layout

\begin_layout Verbatim
   string           delta_val;
\end_layout

\begin_layout Verbatim
   vector<string>   extensions;
\end_layout

\begin_layout Verbatim
};
\end_layout

\begin_layout Verbatim
\noindent
 
\end_layout

\begin_layout Verbatim
struct AttributeEventInfo
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
   ChangeEventInfo     ch_event;
\end_layout

\begin_layout Verbatim
   PeriodicEventInfo   per_event;
\end_layout

\begin_layout Verbatim
   ArchiveEventInfo    arch_event;
\end_layout

\begin_layout Verbatim
};
\end_layout

\begin_layout Verbatim
\noindent
 
\end_layout

\begin_layout Verbatim
struct ChangeEventInfo
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
   string           rel_change;
\end_layout

\begin_layout Verbatim
   string           abs_change;
\end_layout

\begin_layout Verbatim
   vector<string>   extensions;
\end_layout

\begin_layout Verbatim
};
\end_layout

\begin_layout Verbatim
\noindent
 
\end_layout

\begin_layout Verbatim
struct PeriodicEventInfo
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
   string           period;
\end_layout

\begin_layout Verbatim
   vector<string>   extensions;
\end_layout

\begin_layout Verbatim
};
\end_layout

\begin_layout Verbatim
\noindent
 
\end_layout

\begin_layout Verbatim
struct ArchiveEventInfo
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
   string           archive_rel_change;
\end_layout

\begin_layout Verbatim
   string           archive_abs_change;
\end_layout

\begin_layout Verbatim
   string           archive_period;
\end_layout

\begin_layout Verbatim
   vector<string>   extensions;
\end_layout

\begin_layout Verbatim
};
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
AttributeInfoEx DeviceProxy::get_attribute_config(string&)
\end_layout

\begin_layout Standard
Return the attribute configuration for a single attributes.
 The AttributeInfoEx is a structure defined above.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
void DeviceProxy::set_attribute_config(AttributeInfoList &)
\end_layout

\begin_layout Standard
Change the attribute configuration for the specified attributes.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked, DevFailed
 from device
\end_layout

\begin_layout Subsubsection
void DeviceProxy::set_attribute_config(AttributeInfoListEx &)
\end_layout

\begin_layout Standard
Change the attribute configuration for the specified attributes.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked, DevFailed
 from device
\end_layout

\begin_layout Subsubsection
vector<DeviceAttribute> *DeviceProxy::read_attributes(vector<string>&)
\end_layout

\begin_layout Standard
Read the list of specified attributes.
 To extract the value you have to use the operator of the class DeviceAttribute
 which corresponds to the data type of the attribute.
 NOTE: There is no automatic type conversion from the attribute native type
 to user type e.g.
 if an attribute returns a short you cannot extract it as a double, you
 have to extract it as a short.
 By default, if the server reports error for one of the attribute in the
 list, this error will be passed to the user using exception when he (she)
 will try to extract the data form the corresponding See sub-chapter on
 DeviceAttribute to learn how to change this default behaviour.
 DeviceAttribute object.
 This method allocates memory for the vector of DeviceAttribute objects
 returned to the caller.
 This is the caller responsibility to delete this memory.
 Example :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
vector<DeviceAttribute> *devattr;
\end_layout

\begin_layout Verbatim
vector<string> attr_names;
\end_layout

\begin_layout Verbatim
 
\end_layout

\begin_layout Verbatim
attr_names.push_back("attribute_1");
\end_layout

\begin_layout Verbatim
attr_names.push_back("attribute_2");
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
devattr = device->read_attributes(attr_names);
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
short short_attr_1;
\end_layout

\begin_layout Verbatim
long long_attr_2;
\end_layout

\begin_layout Verbatim
(*devattr)[0] >> short_attr_1;
\end_layout

\begin_layout Verbatim
(*devattr)[1] >> long_attr_2;
\end_layout

\begin_layout Verbatim
cout << "my_attribute value " << short_attr;
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
delete devattr;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed
\end_layout

\begin_layout Subsubsection
DeviceAttribute DeviceProxy::read_attribute(string&)
\end_layout

\begin_layout Standard
Read a single attribute.
 To extract the value you have to use the operator of the class DeviceAttribute
 which corresponds to the data type of the attribute.
 NOTE: There is no automatic type conversion from the attribute native type
 to user type e.g.
 if an attribute returns a short you cannot extract it as a double (this
 will return 0) you have to extract it as a short.
 See example above.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed
\end_layout

\begin_layout Subsubsection
DeviceAttribute DeviceProxy::read_attribute(const char *)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsubsection
void DeviceProxy::write_attributes(vector<DeviceAttribute>&)
\end_layout

\begin_layout Standard
Write the specified attributes.
 To insert the values to write you have to use the operator of the DeviceAttribu
te class which corresponds to the data type of the attribute.
 NOTE: There is no automatic type conversion from the user type to the attribute
 native type e.g.
 if an attribute expects a short you cannot insert it as a double (this
 will throw an exception) you have to insert it as a short.
 Note that this is the only API call which could throw a NamedDevFailedList
 exception.
 See 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:The-NamedDevFailedList-exception"

\end_inset

 to get all the details on this exception.
 Example :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
vector<DeviceAttribute> attr_in;
\end_layout

\begin_layout Verbatim
string att1_name("First_attr");
\end_layout

\begin_layout Verbatim
string att2_name("Second_attr");
\end_layout

\begin_layout Verbatim
short short_attr;
\end_layout

\begin_layout Verbatim
double double_attr; attr_in.push_back(DeviceAttribute(att1_name,short_attr));
\end_layout

\begin_layout Verbatim
attr_in.push_back(DeviceAttribute(att2_name,double_attr));
\end_layout

\begin_layout Verbatim
device->write_attributes(attr_in);
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked, DevFailed
 or NamedDevFailedList
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
NamedDevFailedList
\end_layout

\end_inset

 from device
\end_layout

\begin_layout Subsubsection
void DeviceProxy::write_attribute(DeviceAttribute&)
\end_layout

\begin_layout Standard
Write a single attribute.
 To insert the value to write you have to use the operator of the class
 DeviceAttribute which corresponds to the data type of the attribute.
 NOTE: There is no automatic type conversion from the user type to the attribute
 native type e.g.
 if an attribute expects a short you cannot insert it as a double (this
 will throw an exception) you have to insert it as a short.
 See example above.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked, DevFailed
 from device
\end_layout

\begin_layout Subsubsection
DeviceAttribute DeviceProxy::write_read_attribute(DeviceAttribute&)
\end_layout

\begin_layout Standard
Write then read a single attribute in a single network call.
 By default (serialisation by device), the execution of this call in the
 server can't be interrupted by other clients.
 To insert/extract the value to write/read you have to use the operator
 of the class DeviceAttribute which corresponds to the data type of the
 attribute.
 NOTE: There is no automatic type conversion from the user type to the attribute
 native type e.g.
 if an attribute expects a short you cannot insert it as a double (this
 will throw an exception) you have to insert it as a short.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked, DevFailed
 from device
\end_layout

\begin_layout Subsubsection
vector<DeviceAttributeHistory> *DeviceProxy::attribute_history(string &,
 int)
\end_layout

\begin_layout Standard
Retrieve attribute history from the attribute polling buffer.
 The first argument is the attribute name.
 The second argument is the wanted history depth.
 This method returns a vector of DeviceAttributeHistory types.
 This method allocates memory for the vector of DeviceAttributeHistory returned
 to the caller.
 It is the caller responsibility to delete this memory.
 Class DeviceAttributeHistory is detailed on chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "AttributeHistory"

\end_inset

See also chapter on Advanced Feature for all details regarding polling.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DeviceProxy dev = new DeviceProxy("..."); 
\end_layout

\begin_layout Verbatim
vector<DeviceAttributeHistory> *hist;
\end_layout

\begin_layout Verbatim
hist = dev->attribute_history("Current",5);
\end_layout

\begin_layout Verbatim
\noindent
for (int i = 0;i < 5;i++) 
\end_layout

\begin_layout Verbatim
\noindent
{
\end_layout

\begin_layout Verbatim
\noindent

\end_layout

\begin_layout Verbatim
    bool fail = (*hist)[i].has_failed();
\end_layout

\begin_layout Verbatim
    if (fail == false)
\end_layout

\begin_layout Verbatim
    {
\end_layout

\begin_layout Verbatim
        cout << "Attribute name = " << (*hist)[i].get_name() << endl;
\end_layout

\begin_layout Verbatim
        cout << "Attribute quality factor = " << (*hist)[i].get_quality()
 << endl;
\end_layout

\begin_layout Verbatim
        long value;
\end_layout

\begin_layout Verbatim
        (*hist)[i] >> value;
\end_layout

\begin_layout Verbatim
        cout << "Current = " << value << endl;
\end_layout

\begin_layout Verbatim
    }
\end_layout

\begin_layout Verbatim
    else
\end_layout

\begin_layout Verbatim
    {
\end_layout

\begin_layout Verbatim
        cout << "Attribute failed !" << endl;
\end_layout

\begin_layout Verbatim
        cout << "Error level 0 desc = " << ((*hist)[i].get_err_stack())[0].desc
 << endl;
\end_layout

\begin_layout Verbatim
    }
\end_layout

\begin_layout Verbatim
    cout << "Date = " << (*hist)[i].get_date().tv_sec << endl;
\end_layout

\begin_layout Verbatim
\noindent
}
\end_layout

\begin_layout Verbatim
delete hist;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
NonSupportedFeature, ConnectionFailed, CommunicationFailed, DevFailed from
 device
\end_layout

\begin_layout Subsubsection
vector<DeviceAttributeHistory> *DeviceProxy::attribute_history(const char
 *, int)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsection
Asynchronous command oriented methods
\end_layout

\begin_layout Subsubsection
long DeviceProxy::command_inout_asynch(string &name, bool forget)
\end_layout

\begin_layout Standard
Execute asynchronously (polling model) a command on a device which takes
 no input argument.
 The last argument is a 
\emph on
fire and forget
\emph default
 flag.
 If this flag is set to true, this means that the client does not care at
 all about the server answer and will even not try to get it.
 A false default value is provided.
 Please, note that device re-connection will not take place (in case it
 is needed) if the fire and forget mode is used.
 Therefore, an application using only fire and forget requests is not able
 to automatically re-connnect to device.
 This call returns an 
\emph on
asynchronous call identifier
\emph default
 which is needed to get the command result.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed
\end_layout

\begin_layout Subsubsection
long DeviceProxy::command_inout_asynch(const char *name, bool forget)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsubsection
long DeviceProxy::command_inout_asynch(string &name, DeviceData &argin,
 bool forget)
\end_layout

\begin_layout Standard
Execute asynchronously (polling model) a command on a device.
 Input arguments are passed in a DeviceData object (see following chapters
 on how to insert data into DeviceData object).
 The last argument is a 
\emph on
fire and forget
\emph default
 flag.
 If this flag is set to true, this means that the client does not care at
 all about the server answer and will even not try to get it.
 A false default value is provided.
 Please, note that device re-connection will not take place (in case it
 is needed) if the fire and forget mode is used.
 Therefore, an application using only fire and forget requests is not able
 to automatically re-connnect to device.
 This call returns an 
\emph on
asynchronous call identifier
\emph default
 which is needed to get the command result.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed
\end_layout

\begin_layout Subsubsection
long DeviceProxy::command_inout_asynch(const char *name, Devicedata &argin,
 bool forget)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsubsection
DeviceData DeviceProxy::command_inout_reply(long id)
\end_layout

\begin_layout Standard
Check if the answer of an asynchronous command_inout is arrived (polling
 model).
 id is the asynchronous call identifier.
 If the reply is arrived and if it is a valid reply, it is returned to the
 caller in a DeviceData object.
 If the reply is an exception, it is re-thrown by this call.
 An exception is also thrown in case of the reply is not yet arrived.
 Example :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
        Tango::DeviceProxy dev("...");
\end_layout

\begin_layout Verbatim
        long asyn_id;
\end_layout

\begin_layout Verbatim
        asyn_id = dev.command_inout_asynch("MyCmd");
\end_layout

\begin_layout Verbatim
        ...
\end_layout

\begin_layout Verbatim
        ...
\end_layout

\begin_layout Verbatim
        ...
\end_layout

\begin_layout Verbatim
        Tango::DeviceData arg;
\end_layout

\begin_layout Verbatim
        try
\end_layout

\begin_layout Verbatim
        {
\end_layout

\begin_layout Verbatim
                arg = dev.command_inout_reply(asyn_id);
\end_layout

\begin_layout Verbatim
        }
\end_layout

\begin_layout Verbatim
        catch(Tango::AsynReplyNotArrived)
\end_layout

\begin_layout Verbatim
        {
\end_layout

\begin_layout Verbatim
                cerr << "Command not arrived !" << endl;
\end_layout

\begin_layout Verbatim
        }
\end_layout

\begin_layout Verbatim
        catch (Tango::DevFailed &e)
\end_layout

\begin_layout Verbatim
        {
\end_layout

\begin_layout Verbatim
                Tango::Except::print_exception(e);
\end_layout

\begin_layout Verbatim
        } 
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: AsynCall, AsynReplyNotArrived, CommunicationFailed, DevFailed
 from device
\end_layout

\begin_layout Subsubsection
DeviceData DeviceProxy::command_inout_reply(long id, long timeout)
\end_layout

\begin_layout Standard
Check if the answer of an asynchronous command_inout is arrived (polling
 model).
 id is the asynchronous call identifier.
 If the reply is arrived and if it is a valid reply, it is returned to the
 caller in a DeviceData object.
 If the reply is an exception, it is re-thrown by this call.
 If the reply is not yet arrived, the call will wait (blocking the process)
 for the time specified in timeout.
 If after timeout milliseconds, the reply is still not there, an exception
 is thrown.
 If timeout is set to 0, the call waits until the reply arrived.
\end_layout

\begin_layout Standard

\emph on
Exception: AsynCall, AsynReplyNotArrived, CommunicationFailed, DevFailed
 from device
\end_layout

\begin_layout Subsubsection
void DeviceProxy::command_inout_asynch(string &name, CallBack &cb)
\end_layout

\begin_layout Standard
Execute asynchronously (callback model) a command on a device which takes
 no input argument.
 The last argument is a reference to a callback object.
 This callback object should be an instance of a user class inheriting from
 the 
\emph on
Tango::CallBack
\emph default
 class with the 
\emph on
cmd_ended()
\emph default
 method overloaded.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed
\end_layout

\begin_layout Subsubsection
void DeviceProxy::command_inout_asynch(const char *name, CallBack &cb)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsubsection
void DeviceProxy::command_inout_asynch(string &name, DeviceData &argin,
 CallBack &cb)
\end_layout

\begin_layout Standard
Execute asynchronously (callback model) a command on a device.
 Input arguments are passed in a DeviceData object (see following chapters
 on how to insert data into DeviceData object).
 The last argument is a reference to a callback object.
 This callback object should be an instance of a user class inheriting from
 the 
\emph on
Tango::CallBack
\emph default
 class with the 
\emph on
cmd_ended()
\emph default
 method overloaded.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed
\end_layout

\begin_layout Subsubsection
void DeviceProxy::command_inout_asynch(const char *name, DeviceData &argin,
 Callback &cb)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Subsection
Asynchronous attribute related methods
\end_layout

\begin_layout Subsubsection
long DeviceProxy::read_attribute_asynch(string &name)
\end_layout

\begin_layout Standard
Read asynchronously (polling model) a single attribute.
 This call returns an 
\emph on
asynchronous call identifier
\emph default
 which is needed to get the attribute value.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed
\end_layout

\begin_layout Subsubsection
long DeviceProxy::read_attribute_asynch(const char *name)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsubsection
long DeviceProxy::read_attributes_asynch(vector<string> &names)
\end_layout

\begin_layout Standard
Read asynchronously (polling model) the list of specified attributes.
 This call returns an 
\emph on
asynchronous call identifier
\emph default
 which is needed to get attributes value.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed
\end_layout

\begin_layout Subsubsection
DeviceAttribute *DeviceProxy::read_attribute_reply(long id)
\end_layout

\begin_layout Standard
Check if the answer of an asynchronous read_attribute is arrived (polling
 model).
 id is the asynchronous call identifier.
 If the reply is arrived and if it is a valid reply, it is returned to the
 caller in a DeviceAttribute object.
 If the reply is an exception, it is re-thrown by this call.
 An exception is also thrown in case of the reply is not yet arrived.
 To extract attribute value, you have to use the operator of the class DeviceAtt
ribute which corresponds to the data type of the attribute.
 NOTE: There is no automatic type conversion from the attribute native type
 to user type e.g.
 if an attribute returns a short you cannot extract it as a double, you
 have to extract it as a short.
 Memory has been allocated for the DeviceAttribute object returned to the
 caller.
 This is the caller responsibility to delete this memory.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
AsynCall, AsynReplyNotArrived, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
DeviceAttribute *DeviceProxy::read_attribute_reply(long id, long timeout)
\end_layout

\begin_layout Standard
Check if the answer of an asynchronous read_attribute is arrived (polling
 model).
 id is the asynchronous call identifier.
 If the reply is arrived and if it is a valid reply, it is returned to the
 caller in a DeviceAttribute object.
 If the reply is an exception, it is re-thrown by this call.
 If the reply is not yet arrived, the call will wait (blocking the process)
 for the time specified in timeout.
 If after timeout milliseconds, the reply is still not there, an exception
 is thrown.
 If timeout is set to 0, the call waits until the reply arrived.
 To extract attribute value, you have to use the operator of the class DeviceAtt
ribute which corresponds to the data type of the attribute.
 NOTE: There is no automatic type conversion from the attribute native type
 to user type e.g.
 if an attribute returns a short you cannot extract it as a double, you
 have to extract it as a short.
 Memory has been allocated for the DeviceAttribute object returned to the
 caller.
 This is the caller responsibility to delete this memory.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
AsynCall, AsynReplyNotArrived, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
vector<DeviceAttribute> *DeviceProxy::read_attributes_reply(long id)
\end_layout

\begin_layout Standard
Check if the answer of an asynchronous read_attributes is arrived (polling
 model).
 id is the asynchronous call identifier.
 If the reply is arrived and if it is a valid reply, it is returned to the
 caller in a vector<DeviceAttribute>.
 If the reply is an exception, it is re-thrown by this call.
 An exception is also thrown in case of the reply is not yet arrived.
 To extract attribute value, you have to use the operator of the class DeviceAtt
ribute which corresponds to the data type of the attribute.
 NOTE: There is no automatic type conversion from the attribute native type
 to user type e.g.
 if an attribute returns a short you cannot extract it as a double, you
 have to extract it as a short.
 Memory has been allocated for the vector<DeviceAttribute> object returned
 to the caller.
 This is the caller responsibility to delete this memory.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
AsynCall, AsynReplyNotArrived, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
vector<DeviceAttribute> *DeviceProxy::read_attributes_reply(long id, long
 timeout)
\end_layout

\begin_layout Standard
Check if the answer of an asynchronous read_attributes is arrived (polling
 model).
 id is the asynchronous call identifier.
 If the reply is arrived and if it is a valid reply, it is returned to the
 caller in a vector<DeviceAttribute>.
 If the reply is an exception, it is re-thrown by this call.
 If the reply is not yet arrived, the call will wait (blocking the process)
 for the time specified in timeout.
 If after timeout milliseconds, the reply is still not there, an exception
 is thrown.
 If timeout is set to 0, the call waits until the reply arrived.
 To extract attribute value, you have to use the operator of the class DeviceAtt
ribute which corresponds to the data type of the attribute.
 NOTE: There is no automatic type conversion from the attribute native type
 to user type e.g.
 if an attribute returns a short you cannot extract it as a double, you
 have to extract it as a short.
 Memory has been allocated for the vector<DeviceAttribute> object returned
 to the caller.
 This is the caller responsibility to delete this memory.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
AsynCall, AsynReplyNotArrived, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
long DeviceProxy::write_attribute_asynch(DeviceAttribute &argin)
\end_layout

\begin_layout Standard
Write asynchronously (polling model) a single attribute.
 To insert the value to write you have to use the operator of the class
 DeviceAttribute which corresponds to the data type of the attribute.
 NOTE: There is no automatic type conversion from the user type to the attribute
 native type e.g.
 if an attribute expects a short you cannot insert it as a double (this
 will throw an exception) you have to insert it as a short.
 This call returns an 
\emph on
asynchronous call identifier
\emph default
 which is needed to get the server reply.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
ConnectionFailed
\end_layout

\begin_layout Subsubsection
long DeviceProxy::write_attributes_asynch(vector<DeviceAttribute> &argin)
\end_layout

\begin_layout Standard
Write asynchronously (polling model) the specified attributes.
 To insert the value to write you have to use the operator of the class
 DeviceAttribute which corresponds to the data type of the attribute.
 NOTE: There is no automatic type conversion from the user type to the attribute
 native type e.g.
 if an attribute expects a short you cannot insert it as a double (this
 will throw an exception) you have to insert it as a short.
 This call returns an 
\emph on
asynchronous call identifier
\emph default
 which is needed to get the server reply.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
ConnectionFailed
\end_layout

\begin_layout Subsubsection
void DeviceProxy::write_attribute_reply(long id)
\end_layout

\begin_layout Standard
Check if the answer of an asynchronous write_attribute is arrived (polling
 model).
 id is the asynchronous call identifier.
 If the reply is arrived and if it is a valid reply, the call returned.
 If the reply is an exception, it is re-thrown by this call.
 An exception is also thrown in case of the reply is not yet arrived.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
AsynCall, AsynReplyNotArrived, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
void DeviceProxy::write_attribute_reply(long id, long timeout)
\end_layout

\begin_layout Standard
Check if the answer of an asynchronous write_attribute is arrived (polling
 model).
 id is the asynchronous call identifier.
 If the reply is arrived and if it is a valid reply, the call returned.
 If the reply is an exception, it is re-thrown by this call.
 If the reply is not yet arrived, the call will wait (blocking the process)
 for the time specified in timeout.
 If after timeout milliseconds, the reply is still not there, an exception
 is thrown.
 If timeout is set to 0, the call waits until the reply arrived.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
AsynCall, AsynReplyNotArrived, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
void DeviceProxy::write_attributes_reply(long id)
\end_layout

\begin_layout Standard
Check if the answer of an asynchronous write_attributes is arrived (polling
 model).
 id is the asynchronous call identifier.
 If the reply is arrived and if it is a valid reply, the call returned.
 If the reply is an exception, it is re-thrown by this call.
 An exception is also thrown in case of the reply is not yet arrived.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
AsynCall, AsynReplyNotArrived, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
void DeviceProxy::write_attributes_reply(long id, long timeout)
\end_layout

\begin_layout Standard
Check if the answer of an asynchronous write_attributes is arrived (polling
 model).
 id is the asynchronous call identifier.
 If the reply is arrived and if it is a valid reply, the call returned.
 If the reply is an exception, it is re-thrown by this call.
 If the reply is not yet arrived, the call will wait (blocking the process)
 for the time specified in timeout.
 If after timeout milliseconds, the reply is still not there, an exception
 is thrown.
 If timeout is set to 0, the call waits until the reply arrived.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
AsynCall, AsynReplyNotArrived, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
void DeviceProxy::read_attribute_asynch(string &name, CallBack &cb)
\end_layout

\begin_layout Standard
Read asynchronously (callback model) a single attribute.
 The last argument is a reference to a callback object.
 This callback object should be an instance of a user class inheriting from
 the 
\emph on
Tango::CallBack
\emph default
 class with the 
\emph on
attr_read()
\emph default
 method overloaded.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
ConnectionFailed
\end_layout

\begin_layout Subsubsection
void DeviceProxy::read_attribute_asynch(const char *name, CallBack &cb)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsubsection
void DeviceProxy::read_attributes_asynch(vector<string> &names, CallBack
 &cb)
\end_layout

\begin_layout Standard
Read asynchronously (callback model) an attribute list.
 The last argument is a reference to a callback object.
 This callback object should be an instance of a user class inheriting from
 the 
\emph on
Tango::CallBack
\emph default
 class with the 
\emph on
attr_read()
\emph default
 method overloaded.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
ConnectionFailed
\end_layout

\begin_layout Subsubsection
void DeviceProxy::write_attribute_asynch(DeviceAttribute &argin, CallBack
 &cb)
\end_layout

\begin_layout Standard
Write asynchronously (callback model) a single attribute.
 The last argument is a reference to a callback object.
 This callback object should be an instance of a user class inheriting from
 the 
\emph on
Tango::CallBack
\emph default
 class with the 
\emph on
attr_written()
\emph default
 method overloaded.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
ConnectionFailed
\end_layout

\begin_layout Subsubsection
void DeviceProxy::write_attributes_asynch(vector<DeviceAttribute> &argin,
 CallBack &cb)
\end_layout

\begin_layout Standard
Write asynchronously (callback model) an attribute list.
 The last argument is a reference to a callback object.
 This callback object should be an instance of a user class inheriting from
 the 
\emph on
Tango::CallBack
\emph default
 class with the 
\emph on
attr_written()
\emph default
 method overloaded.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
ConnectionFailed
\end_layout

\begin_layout Subsection
Miscellaneous asynchronous related methods
\end_layout

\begin_layout Subsubsection
long DeviceProxy::pending_asynch_call(asyn_req_type req)
\end_layout

\begin_layout Standard
Return number of device asynchronous pending requests.
 The input parameter is an enumeration with three values which are:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
POLLING : Returns only device polling model asynchronous request number
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
CALLBACK : Returns only device callback model asynchronous request number
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
ALL_ASYNCH : Returns device asynchronous request number
\end_layout

\begin_layout Standard

\emph on
Exception: None
\end_layout

\begin_layout Subsubsection
void DeviceProxy::get_asynch_replies()
\end_layout

\begin_layout Standard
Fire callback methods for device asynchronous requests with already arrived
 replied.
 Returns immediately if there is no replies already arrived or if there
 is no asynchronous request for the device.
 Example :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
class MyCallBack: Tango::CallBack
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
public:
\end_layout

\begin_layout Verbatim
   MyCallback(double d):data(d) {};
\end_layout

\begin_layout Verbatim
   virtual void cmd_ended(Tango::CmdDoneEvent *);
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Verbatim
private:
\end_layout

\begin_layout Verbatim
   double data;
\end_layout

\begin_layout Verbatim
};
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Verbatim
void MyCallBack::cmd_ended(Tango CmdDoneEvent *cmd)
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
   if (cmd->err == true)
\end_layout

\begin_layout Verbatim
      Tango::Except::print_error_stack(cmd->errors);
\end_layout

\begin_layout Verbatim
   else
\end_layout

\begin_layout Verbatim
   {
\end_layout

\begin_layout Verbatim
      short cmd_result;
\end_layout

\begin_layout Verbatim
      cmd->argout >> cmd_result;
\end_layout

\begin_layout Verbatim
      cout << "Command result = " << cmd_result << endl;
\end_layout

\begin_layout Verbatim
      cout << "Callback personal data = " << data << endl;
\end_layout

\begin_layout Verbatim
   }
\end_layout

\begin_layout Verbatim
}
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Verbatim
int main(int argc, char *argv[])
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
   ....
\end_layout

\begin_layout Verbatim
   ....
 
\end_layout

\begin_layout Verbatim
   Tango::DeviceProxy dev("...");
\end_layout

\begin_layout Verbatim
   double my_data = ...;
\end_layout

\begin_layout Verbatim
   MyCallBack cb(my_data);
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Verbatim
   dev.command_inout_asynch("MyCmd",cb);
\end_layout

\begin_layout Verbatim
   ...
\end_layout

\begin_layout Verbatim
   ...
\end_layout

\begin_layout Verbatim
   ...
\end_layout

\begin_layout Verbatim
   dev.get_asynch_replies();
\end_layout

\begin_layout Verbatim
   ...
\end_layout

\begin_layout Verbatim
   ...
\end_layout

\begin_layout Verbatim
}
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: None, all errors are reported using the err and errors fields
 of the parameter passed to the callback method.
 See chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Asynchronous-callback-related"

\end_inset

 for details.
\end_layout

\begin_layout Subsubsection
void DeviceProxy::get_asynch_replies(long timeout)
\end_layout

\begin_layout Standard
Fire callback methods for device asynchronous requests (command and attributes)
 with already arrived replied.
 Wait and block the caller for timeout milliseconds if they are some device
 asynchronous requests which are not yet arrived.
 Returns immediately if there is no asynchronous request for the device.
 If timeout is set to 0, the call waits until all the asynchronous requests
 sent to the device has received a reply.
\end_layout

\begin_layout Standard

\emph on
Exception: AsynReplyNotArrived.
 All other errors are reported using the err and errors fields of the object
 passed to the callback methods.
 See chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Asynchronous-callback-related"

\end_inset

 for details.
\end_layout

\begin_layout Subsubsection
void DeviceProxy::cancel_asynch_request(long id)
\end_layout

\begin_layout Standard
Cancel a pending asynchronous request.
 id is the asynchronous call identifier.
 This is a call local to the client.
 It simply allows the caller not to get the answer of the asynchronous request.
 It does not interrupt the call execution on the remote device.
\end_layout

\begin_layout Standard

\emph on
Exception: AsynCall
\end_layout

\begin_layout Subsubsection
void DeviceProxy::cancel_all_polling_asynch_request()
\end_layout

\begin_layout Standard
Cancel all pending polling asynchronous requests.
 This is a call local to the client.
 It simply allows the caller not to get the answers of the asynchronous
 requests.
 It does not interrupt the call execution on the remote devices.
\end_layout

\begin_layout Subsection
Polling related methods
\end_layout

\begin_layout Subsubsection
bool DeviceProxy::is_command_polled(string &cmd_name)
\end_layout

\begin_layout Standard
Returns true if the command "cmd_name" is polled.
 Otherwise, returns false.
\end_layout

\begin_layout Subsubsection
bool DeviceProxy::is_command_polled(const char *cmd_name)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsubsection
bool DeviceProxy::is_attribute_polled(string &attr_name)
\end_layout

\begin_layout Standard
Returns true if the attribute "attr_name" is polled.
 Otherwise, returns false.
\end_layout

\begin_layout Subsubsection
bool Deviceproxy::is_attribute_polled(const char *attr_name)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsubsection
int DeviceProxy::get_command_poll_period(string &cmd_name)
\end_layout

\begin_layout Standard
Returns the command "cmd_name" polling period in mS.
 If the command is not polled, it returns 0.
\end_layout

\begin_layout Subsubsection
int DeviceProxy::get_command_poll_period(const char *cmd_name)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsubsection
int DeviceProxy::get_attribute_poll_period(string &attr_name)
\end_layout

\begin_layout Standard
Returns the attribute "attr_name" polling period in mS.
 If the attribute is not polled, it returns 0.
\end_layout

\begin_layout Subsubsection
int Deviceproxy::get_attribute_poll_period(const char *attr_name)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsubsection
vector<string> *DeviceProxy::polling_status()
\end_layout

\begin_layout Standard
Returns the device polling status.
 There is one string for each polled command/attribute.
 Each string is multi-line string with :
\end_layout

\begin_layout Itemize
The attribute/command name
\end_layout

\begin_layout Itemize
The attribute/command polling period (in mS)
\end_layout

\begin_layout Itemize
The attribute/command polling ring buffer depth
\end_layout

\begin_layout Itemize
The time needed for the last command/attribute execution (in mS)
\end_layout

\begin_layout Itemize
The time since data in the ring buffer has not been updated
\end_layout

\begin_layout Itemize
The delta time between the last records in the ring buffer
\end_layout

\begin_layout Itemize
The exception parameters in case of the last command/attribute execution
 failed
\end_layout

\begin_layout Standard
This method allocates memory for the vector of string(s) returned to the
 caller.
 It is the caller responsibility to delete this memory.
\end_layout

\begin_layout Subsubsection
void DeviceProxy::poll_command(string &cmd_name,int period)
\end_layout

\begin_layout Standard
Add the command "cmd_name" to the list of polled command.
 The polling period is specified by "period" (in mS).
 If the command is already polled, this method will update the polling period
 according to "period".
\end_layout

\begin_layout Subsubsection
void DeviceProxy::poll_command(const char *cmd_name, int period)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsubsection
void DeviceProxy::poll_attribute(string &attr_name, int period)
\end_layout

\begin_layout Standard
Add the attribute "attr_name" to the list of polled attributes.
 The polling period is specified by "period" (in mS).
 If the attribute is already polled, this method will update the polling
 period according to "period".
\end_layout

\begin_layout Subsubsection
void DeviceProxy::poll_attribute(const char *attr_name, int period)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsubsection
void DeviceProxy::stop_poll_command(string &cmd_name)
\end_layout

\begin_layout Standard
Remove command "cmd_name" from the list of polled command.
\end_layout

\begin_layout Subsubsection
void DeviceProxy::stop_poll_command(const char *cmd_name)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsubsection
void DeviceProxy::stop_poll_attribute(string &attr_name)
\end_layout

\begin_layout Standard
Remove attribute "attr_name" from the list of polled attributes.
\end_layout

\begin_layout Subsubsection
void DeviceProxy::stop_poll_attribute(const char *attr_name)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsection
Event related methods
\end_layout

\begin_layout Subsubsection
int DeviceProxy::subscribe_event(const string &attribute, EventType event,
 CallBack *cb)
\end_layout

\begin_layout Standard
The client call to subscribe for event reception in the 
\series bold
push model
\series default
.
 The client implements a callback method which is triggered when the event
 is received.
 Filtering is done based on the event type.
 For example when reading the state and the reason specified is "change"
 the event will be fired only when the state changes.
 Events consist of an attribute name and the event reason.
 A standard set of reasons are implemented by the system, additional device
 specific reasons can be implemented by device servers programmers.
\end_layout

\begin_layout Standard
The 
\emph on
attribute
\emph default
 parameter is the device attribute name which will be sent as an event e.g.
 
\begin_inset Quotes eld
\end_inset

current
\begin_inset Quotes erd
\end_inset

, 
\emph on
event
\emph default
 parameter is the event reason and must be on the enumerated values:
\end_layout

\begin_layout Itemize
Tango::CHANGE_EVENT
\end_layout

\begin_layout Itemize
Tango::PERIODIC_EVENT
\end_layout

\begin_layout Itemize
Tango::ARCHIVE_EVENT
\end_layout

\begin_layout Itemize
Tango::ATTR_CONF_EVENT
\end_layout

\begin_layout Itemize
Tango::DATA_READY_EVENT
\end_layout

\begin_layout Itemize
Tango::USER_EVENT
\end_layout

\begin_layout Standard

\emph on
cb
\emph default
 is a pointer to a class inheriting from the Tango CallBack class and implementi
ng a 
\emph on
push_event()
\emph default
 method.
\end_layout

\begin_layout Standard
The 
\emph on
subscribe_event()
\emph default
 call returns an event id which has to be specified when unsubscribing from
 this event.
 Please, note that the 
\emph on
cb
\emph default
 parameter is a pointer.
 The lifetime of the pointed to object must at least be equal to the time
 when events are requested because only the pointer is stored into the event
 machinery.
 The same thing is true for the DeviceProxy instance on which the 
\emph on
subscribe_event()
\emph default
 method is called.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
EventSystemFailed
\end_layout

\begin_layout Standard
Note: For releases prior to Tango 8, a similar call with a forth argument
 (const vector<string> &filters) was available.
 This extra argument gave the user a way to define extra event filtering.
 For compatibility reason, this call still exist but the extra filtering
 features is not implemented.
\end_layout

\begin_layout Subsubsection
int DeviceProxy::subscribe_event(const string &attribute, EventType event,
 CallBack *cb, bool stateless)
\end_layout

\begin_layout Standard
This subscribe event method has the same functionality as described in the
 last section.
 It adds an additional flag called 
\emph on
stateless.

\emph default
 When the 
\emph on
stateless
\emph default
 flag is set to 
\emph on
false
\emph default
, an exception will be thrown when the event subscription encounters a problem.
 
\end_layout

\begin_layout Standard
With the 
\emph on
stateless
\emph default
 flag set to 
\emph on
true
\emph default
, the event subscription will always succeed, even if the corresponding
 device server is not running.
 The keep alive thread will try every 10 seconds to subscribe for the specified
 event.
 At every subscription retry, a callback is executed which contains the
 corresponding exception.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
EventSystemFailed
\end_layout

\begin_layout Standard
Note: For releases prior to Tango 8, a similar call with a fifth argument
 (const vector<string> &filters) was available.
 This extra argument gave the user a way to define extra event filtering
 and it was the forth argument in the argument list.
 For compatibility reason, this call still exist but the extra filtering
 features is not implemented.
\end_layout

\begin_layout Subsubsection
int DeviceProxy::subscribe_event(const string &attribute, EventType event,
 int event_queue_size, bool stateless)
\end_layout

\begin_layout Standard
The client call to subscribe for event reception in the 
\series bold
pull model
\series default
.
 Instead of a callback method the client has to specify the size of the
 event reception buffer.
\end_layout

\begin_layout Standard
The event reception buffer is implemented as a round robin buffer.
 This way the client can set-up different ways to receive events.
\end_layout

\begin_layout Itemize
Event reception buffer size = 1 : The client is interested only in the value
 of the last event received.
 All other events that have been received since the last reading are discarded.
\end_layout

\begin_layout Itemize
Event reception buffer size > 1 : The client has chosen to keep an event
 history of a given size.
 When more events arrive since the last reading, older events will be discarded.
\end_layout

\begin_layout Itemize
Event reception buffer size = ALL_EVENTS : The client buffers all received
 events.
 The buffer size is unlimited and only restricted by the available memory
 for the client.
\end_layout

\begin_layout Standard
All other parameters are similar to the descriptions given in the last two
 sections.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
EventSystemFailed
\end_layout

\begin_layout Standard
Note: For releases prior to Tango 8, a similar call with a fifth argument
 (const vector<string> &filters) was available.
 This extra argument gave the user a way to define extra event filtering
 and it was the forth argument in the argument list.
 For compatibility reason, this call still exist but the extra filtering
 features is not implemented.
\end_layout

\begin_layout Subsubsection
void DeviceProxy::unsubscribe_event(int event_id)
\end_layout

\begin_layout Standard
Unsubscribe a client from receiving the event specified by 
\emph on
event_id
\emph default
.
 
\emph on
event_id
\emph default
 is the event identifier returned by the 
\emph on
DeviceProxy::subscribe_event()
\emph default
 method.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
EventSystemFailed
\end_layout

\begin_layout Subsubsection
void DeviceProxy::get_events(int event_id, CallBack *cb)
\end_layout

\begin_layout Standard
The method extracts all waiting events from the event reception buffer and
 executes the callback method 
\emph on
cb
\emph default
 for every event.
 During event subscription the client must have chosen the 
\series bold
pull model
\series default
 for this event.
 
\emph on
event_id
\emph default
 is the event identifier returned by the 
\emph on
DeviceProxy::subscribe_event()
\emph default
 method.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
EventSystemFailed
\end_layout

\begin_layout Subsubsection
void DeviceProxy::get_events(int event_id, EventDataList &event_list)
\end_layout

\begin_layout Standard
The method extracts all waiting events from the event reception buffer.
 The returned 
\emph on
event_list
\emph default
 is a vector of EventData pointers.
 The EventData object contains the event information as for the callback
 methods.
 
\end_layout

\begin_layout Standard
During event subscription the client must have chosen the 
\series bold
pull model
\series default
 for this event.
 
\emph on
event_id
\emph default
 is the event identifier returned by the 
\emph on
DeviceProxy::subscribe_event()
\emph default
 method.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
EventSystemFailed
\end_layout

\begin_layout Subsubsection
void DeviceProxy::get_events(int event_id, AttrConfEventDataList &event_list)
\end_layout

\begin_layout Standard
The method extracts all waiting attribute configuration events from the
 event reception buffer.
 The returned 
\emph on
event_list
\emph default
 is a vector of AttrConfEventData pointers.
 The AttrConfEventData object contains the event information as for the
 callback methods.
 
\end_layout

\begin_layout Standard
During event subscription the client must have chosen the 
\series bold
pull model
\series default
 for this event.
 
\emph on
event_id
\emph default
 is the event identifier returned by the 
\emph on
DeviceProxy::subscribe_event()
\emph default
 method.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
EventSystemFailed
\end_layout

\begin_layout Subsubsection
void DeviceProxy::get_events(int event_id, DataReadyEventDataList &event_list)
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
DataReadyEventDataList
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The method extracts all waiting attribute configuration events from the
 event reception buffer.
 The returned 
\emph on
event_list
\emph default
 is a vector of DataReadyEventData
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
DataReadyEventData
\end_layout

\end_inset

 pointers.
 The DataReadyEventData object contains the event information as for the
 callback methods.
 
\end_layout

\begin_layout Standard
During event subscription the client must have chosen the 
\series bold
pull model
\series default
 for this event.
 
\emph on
event_id
\emph default
 is the event identifier returned by the 
\emph on
DeviceProxy::subscribe_event()
\emph default
 method.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
EventSystemFailed
\end_layout

\begin_layout Subsubsection
int DeviceProxy::event_queue_size(int event_id)
\end_layout

\begin_layout Standard
Returns the number of stored events in the event reception buffer.
 After every call to 
\emph on
DeviceProxy:get_events()
\emph default
, the event queue size is 0.
\end_layout

\begin_layout Standard
During event subscription the client must have chosen the 
\series bold
pull model
\series default
 for this event.
 
\emph on
event_id
\emph default
 is the event identifier returned by the 
\emph on
DeviceProxy::subscribe_event()
\emph default
 method.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
EventSystemFailed
\end_layout

\begin_layout Subsubsection
TimeVal DeviceProxy::get_last_event_date(int event_id)
\end_layout

\begin_layout Standard
Returns the arrival time of the last event stored in the event reception
 buffer.
 After every call to 
\emph on
DeviceProxy:get_events()
\emph default
, the event reception buffer is empty.
 In this case an exception will be returned.
\end_layout

\begin_layout Standard
During event subscription the client must have chosen the 
\series bold
pull model
\series default
 for this event.
 
\emph on
event_id
\emph default
 is the event identifier returned by the 
\emph on
DeviceProxy::subscribe_event()
\emph default
 method.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
EventSystemFailed
\end_layout

\begin_layout Subsubsection
bool DeviceProxy::is_event_queue_empty(int event_id)
\end_layout

\begin_layout Standard
Returns true when the event reception buffer is empty.
\end_layout

\begin_layout Standard
During event subscription the client must have chosen the 
\series bold
pull model
\series default
 for this event.
 
\emph on
event_id
\emph default
 is the event identifier returned by the 
\emph on
DeviceProxy::subscribe_event()
\emph default
 method.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
EventSystemFailed
\end_layout

\begin_layout Subsection
Property related methods
\end_layout

\begin_layout Subsubsection
void DeviceProxy::get_property (string&, DbData&)
\end_layout

\begin_layout Standard
Get a single property for a device.
 The property to get is specified as a string.
 Refer to DbDevice::get_property() and DbData sections below for details
 on the DbData type.
\end_layout

\begin_layout Standard

\emph on
Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
 (with database), DevFailed from database device
\end_layout

\begin_layout Subsubsection
void DeviceProxy::get_property (vector<string>&, DbData&)
\end_layout

\begin_layout Standard
Get a list of properties for a device.
 The properties to get are specified as a vector of strings.
 Refer to DbDevice::get_property() and DbData sections below for details
 on the DbData type.
\end_layout

\begin_layout Standard

\emph on
Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
 (with database), DevFailed from database device
\end_layout

\begin_layout Subsubsection
void DeviceProxy::get_property(DbData&)
\end_layout

\begin_layout Standard
Get property(ies) for a device.
 Properties to get are specified using the DbData type.
 Refer to DbDevice::get_property() and DbData sections below for details.
\end_layout

\begin_layout Standard

\emph on
Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
 (with database), DevFailed from database device
\end_layout

\begin_layout Subsubsection
void DeviceProxy::put_property(DbData&)
\end_layout

\begin_layout Standard
Put property(ies) for a device.
 Properties to put are specified using the DbData type.
 Refer to DbDevice::put_property() and DbData sections below for details.
\end_layout

\begin_layout Standard

\emph on
Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
 (with database), DevFailed from database device
\end_layout

\begin_layout Subsubsection
void DeviceProxy::delete_property (string&)
\end_layout

\begin_layout Standard
Delete a single property for a device.
 The property to delete is specified as a string.
\end_layout

\begin_layout Standard

\emph on
Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
 (with database), DevFailed from database device
\end_layout

\begin_layout Subsubsection
void DeviceProxy::delete_property (vector<string>&)
\end_layout

\begin_layout Standard
Delete a list of properties for a device.
 The properties to delete are specified as a vector of strings.
\end_layout

\begin_layout Standard

\emph on
Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
 (with database), DevFailed from database device
\end_layout

\begin_layout Subsubsection
void DeviceProxy::delete_property(DbData&)
\end_layout

\begin_layout Standard
Delete property(ies) for a device.
 Properties to delete are specified using the DbData type.
 Refer to DbDevice::get_property() and DbData sections below for details.
\end_layout

\begin_layout Standard

\emph on
Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
 (with database), DevFailed from database device
\end_layout

\begin_layout Subsubsection
void DeviceProxy::get_property_list(const string &filter,vector<string>
 &prop_list)
\end_layout

\begin_layout Standard
Get the list of property names for the device.
 The parameter 
\emph on
filter
\emph default
 allows the user to filter the returned name list.
 The wildcard character is '*'.
 Only one wildcard character is allowed in the filter parameter.
 The name list is returned in the vector of strings passed as the method
 second argument.
 
\end_layout

\begin_layout Standard

\emph on
Exception: NonDbDevice, WrongNameSyntax, ConnectionFailed (with database),
 CommunicationFailed (with database), DevFailed from database device
\end_layout

\begin_layout Subsection
Logging related methods 
\end_layout

\begin_layout Subsubsection
void DeviceProxy::add_logging_target(const string &target_type_target_name)
\end_layout

\begin_layout Standard
Adds a new logging target to the device.
 The target_type_target_name input parameter must follow the format: target_type
::target_name.
 Supported target types are: 
\emph on
console
\emph default
, 
\emph on
file
\emph default
 and 
\emph on
device
\emph default
.
 For a device target, the target_name part of the target_type_target_name
 parameter must contain the name of a log consumer device (as defined in
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Tango-log-consumer"

\end_inset

).
 For a file target, target_name is the full path to the file to log to.
 If omitted, the device's name is used to build the file name (which is
 something like domain_family_member.log).
 Finally, the target_name part of the target_type_target_name input parameter
 is ignored in case of a console target and can be omitted.
\end_layout

\begin_layout Standard

\emph on
Exception: DevFailed from device
\end_layout

\begin_layout Subsubsection
void DeviceProxy::add_logging_target (const char *target_type_target_name)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsubsection
void DeviceProxy::remove_logging_target(const string &target_type_target_name)
\end_layout

\begin_layout Standard
Removes a logging target from the device's target list.
 The target_type_target_name input parameter must follow the format: target_type
::target_name.
 Supported target types are: 
\emph on
console
\emph default
, 
\emph on
file
\emph default
 and 
\emph on
device
\emph default
.
 For a device target, the target_name part of the target_type_target_name
 parameter must contain the name of a log consumer device (as defined in
 ).
 For a file target, target_name is the full path to the file to remove.
 If omitted, the default log file is removed.
 Finally, the target_name part of the target_type_target_name input parameter
 is ignored in case of a console target and can be omitted.
\end_layout

\begin_layout Standard
If target_name is set to "*", all targets of the specified target_type are
 removed.
 
\end_layout

\begin_layout Subsubsection
void DeviceProxy::remove_logging_target (const char *target_type_target_name)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsubsection
vector<string> DeviceProxy::get_logging_target ()
\end_layout

\begin_layout Standard
Returns a vector of string containing the current device's logging targets.
 Each vector element has the following format: target_type::target_name.
 An empty vector is returned is the device has no logging targets.
\end_layout

\begin_layout Subsubsection
int DeviceProxy::get_logging_level ()
\end_layout

\begin_layout Standard
Returns the current device's logging level (0=OFF, 1=FATAL, 2=ERROR, 3=WARNING,
 4=INFO, 5=DEBUG).
\end_layout

\begin_layout Subsubsection
void DeviceProxy::set_logging_level (int level)
\end_layout

\begin_layout Standard
Changes the device's logging level.
 (0=OFF, 1=FATAL, 2=ERROR, 3=WARNING, 4=INFO, 5=DEBUG).
\end_layout

\begin_layout Subsection
Locking
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Locking
\end_layout

\end_inset

 related methods
\end_layout

\begin_layout Subsubsection
void DeviceProxy::lock
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
lock
\end_layout

\end_inset

(int lock_validity = 10)
\end_layout

\begin_layout Standard
Lock a device.
 The lock_validity is the time (in seconds) the lock is kept valid after
 the previous lock call.
 A default value of 10 seconds is provided and should be fine in most cases.
 In case it is necessary to change the lock validity, it's not possible
 to ask for a validity less than a minimum value set to 2 seconds.
 The library provided an automatic system to periodically re lock the device
 until an unlock call.
 No code is needed to start/stop this automatic re-locking system.
 The locking system is re-entrant.
 It is then allowed to call this method on a device already locked by the
 same process.
 The locking system has the following features:
\end_layout

\begin_layout Itemize
It is impossible to lock the database device or any device server process
 admin device
\end_layout

\begin_layout Itemize
Destroying a locked DeviceProxy unlocks the device
\end_layout

\begin_layout Itemize
Restarting a locked device keeps the lock
\end_layout

\begin_layout Itemize
It is impossible to restart a device locked by someone else
\end_layout

\begin_layout Itemize
Restarting a server breaks the lock
\end_layout

\begin_layout Standard
A locked device is protected against the following calls when executed by
 another client:
\end_layout

\begin_layout Itemize

\emph on
command_inout
\emph default
 call except for device state and status requested via command and for the
 set of commands defined as allowed following the definition of allowed
 command in the Tango control access schema.
\end_layout

\begin_layout Itemize

\emph on
write_attribute
\emph default
 call
\end_layout

\begin_layout Itemize

\emph on
write_read_attribute
\emph default
 call
\end_layout

\begin_layout Itemize

\emph on
set_attribute_config
\emph default
 call
\end_layout

\begin_layout Subsubsection
void DeviceProxy::unlock
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
unlock
\end_layout

\end_inset

(bool force = false)
\end_layout

\begin_layout Standard
Unlock a device.
 If used, the method argument provides a back door on the locking system.
 If this argument is set to true, the device will be unlocked even if the
 caller is not the locker.
 This feature is provided for administration purpopse and should be used
 very carefully.
 If this feature is used, the locker will receive a 
\emph on
DeviceUnlocked
\emph default
 during the next call which is normally protected by the locking Tango system.
\end_layout

\begin_layout Subsubsection
string DeviceProxy::locking_status
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
locking-status
\end_layout

\end_inset

()
\end_layout

\begin_layout Standard
This method returns a plain string describing the device locking status.
 This string can be:
\end_layout

\begin_layout Itemize
"Device <device name> is not locked" in case the device is not locked
\end_layout

\begin_layout Itemize
"Device <device name> is locked by CPP or Python client with PID <pid> from
 host <host name>" in case the device is locked by a CPP client
\end_layout

\begin_layout Itemize
"Device <device name> is locked by JAVA client class <main class> from host
 <host name>" in case the device is locked by a JAVA client
\end_layout

\begin_layout Subsubsection
bool DeviceProxy::is_locked
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
is-locked
\end_layout

\end_inset

()
\end_layout

\begin_layout Standard
Returns true if the device is locked.
 Otherwise, returns false.
\end_layout

\begin_layout Subsubsection
bool DeviceProxy::is_locked_by_me
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
is-locked-by-me
\end_layout

\end_inset

()
\end_layout

\begin_layout Standard
Returns true if the device is locked by the caller.
 Otherwise, returns false (device not locked or locked by someone else)
\end_layout

\begin_layout Subsubsection
bool DeviceProxy::get_locker
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
get-locker
\end_layout

\end_inset

(LockerInfo &li)
\end_layout

\begin_layout Standard
If the device is locked, this method returns true an set some locker process
 informations in the structure passed as argument.
 If the device is not locked, the method returns false.
 The LockerInfo structure definition is
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
typedef union
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
   pid_t           LockerPid;
\end_layout

\begin_layout Verbatim
   unsigned long   UUID[4];
\end_layout

\begin_layout Verbatim
}LockerId;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Verbatim
enum LockerLanguage
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
   CPP,
\end_layout

\begin_layout Verbatim
   JAVA
\end_layout

\begin_layout Verbatim
};
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Verbatim
struct LockerInfo
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
   LockerLanguage  ll;
\end_layout

\begin_layout Verbatim
   LockerId        li;
\end_layout

\begin_layout Verbatim
   string          locker_host;
\end_layout

\begin_layout Verbatim
   string          locker_class;
\end_layout

\begin_layout Verbatim
};
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
The structure 
\emph on
ll
\emph default
 field is set to either CPP or JAVA depending on the locker process language.
 In case of CPP client, the 
\emph on
li
\emph default
 union is set to the locker process pid (
\emph on
LockerPid
\emph default
 field).
 In case of Java client, it is set to the Java client UUID (Universal Uniq
 IDentifier) in the 
\emph on
UUID
\emph default
 field.
 The 
\emph on
locker_host
\emph default
 field is initialised with the host name where the locker process is running
 (or its IP adress as a string if it is not possiblr to get the name associated
 with this address).
 The 
\emph on
locker_class
\emph default
 field is set to the Java virtual machine main class name when the locker
 client process is written in Java.
 For CPP client, it is set to the string "Not defined".
\end_layout

\begin_layout Section
\noindent
Tango::DeviceData
\end_layout

\begin_layout Standard
\noindent
This is the fundamental type for sending and receiving data from device
 commands.
 The values can be inserted and extracted using the operators << and >>
 respectively and insert() for mixed data types.
 A status flag indicates if there is data in the DbDatum object or not.
 An additional flag allows the user to activate exceptions.
 
\end_layout

\begin_layout Subsection
\noindent
Constructors, assignement operators and C++11
\end_layout

\begin_layout Standard
This class has a default constructor (
\emph on
DeviceData()
\emph default
), a copy constructor (
\emph on
DeviceData(const DeviceData &)
\emph default
) and one assignement operator (
\emph on
DeviceData & operator=(const DeviceData &)
\emph default
).
 Nevertheless, the assignement operator and the copy constructor does not
 really copy the data included in the instance.
 For efficiency reasons, they rather move the data from one instance to
 another.
 Starting with Tango 8 and if Tango is compiled with gcc release 4.3 or above
 (or Windows VC 10 and above), some move semantics from C++11
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
C++11
\end_layout

\end_inset

 has been added.
 This means that:
\end_layout

\begin_layout Itemize
A move constructor (
\emph on
DeviceData(DeviceData &&)
\emph default
) has been added.
\end_layout

\begin_layout Itemize
A move assignement operator (
\emph on
DeviceData & operator=(DeviceData &&)
\emph default
) has been added.
\end_layout

\begin_layout Itemize
The classical copy constructor and assignement operator really copy the
 data.
\end_layout

\begin_layout Subsection
\noindent
Operators
\end_layout

\begin_layout Standard
\noindent
The insert and extract operators are specified for the following C++ types
 :
\end_layout

\begin_layout Enumerate
\noindent
bool
\end_layout

\begin_layout Enumerate
\noindent
short
\end_layout

\begin_layout Enumerate
\noindent
unsigned short
\end_layout

\begin_layout Enumerate
\noindent
DevLong
\end_layout

\begin_layout Enumerate
\noindent
DevULong
\end_layout

\begin_layout Enumerate
\noindent
DevLong64
\end_layout

\begin_layout Enumerate
DevULong64
\end_layout

\begin_layout Enumerate
\noindent
float
\end_layout

\begin_layout Enumerate
\noindent
double
\end_layout

\begin_layout Enumerate
\noindent
string
\end_layout

\begin_layout Enumerate
\noindent
char* (insert only)
\end_layout

\begin_layout Enumerate
\noindent
const char *
\end_layout

\begin_layout Enumerate
\noindent
vector<unsigned char>
\end_layout

\begin_layout Enumerate
\noindent
vector<string>
\end_layout

\begin_layout Enumerate
\noindent
vector<short>
\end_layout

\begin_layout Enumerate
\noindent
vector<unsigned short>
\end_layout

\begin_layout Enumerate
\noindent
vector<DevLong>
\end_layout

\begin_layout Enumerate
\noindent
vector<DevULong>
\end_layout

\begin_layout Enumerate
vector<DevLong64>
\end_layout

\begin_layout Enumerate
vector<DevULong64>
\end_layout

\begin_layout Enumerate
\noindent
vector<float>
\end_layout

\begin_layout Enumerate
\noindent
vector<double>
\end_layout

\begin_layout Standard
Operators exist for inserting and extracting the native TANGO CORBA sequence
 types.
 These can be useful for programmers who want to use the TANGO api internally
 in their device servers and do not want to convert from CORBA to C++ types.
 Insert and extract operators exist for the following types :
\end_layout

\begin_layout Enumerate
DevVarUCharArray * (const DevVarUCharArray * for extraction)
\end_layout

\begin_layout Enumerate
DevVarShortArray * (const DevVarShortArray * for extraction)
\end_layout

\begin_layout Enumerate
DevVarUShortArray * (const DevVarUShortArray * for extraction)
\end_layout

\begin_layout Enumerate
DevVarLongArray * (const DevVarLongArray * for extraction)
\end_layout

\begin_layout Enumerate
DevVarULongArray * (const DevVarULongArray * for extraction)
\end_layout

\begin_layout Enumerate
DevVarLong64Array * (const DevVarLong64Array * for extraction)
\end_layout

\begin_layout Enumerate
DevVarULong64Array * (const DevVarULong64Array * for extraction)
\end_layout

\begin_layout Enumerate
DevVarFloatArray * (const DevVarFloatArray * for extraction)
\end_layout

\begin_layout Enumerate
DevVarDoubleArray * (const DevVarDoubleArray * for extraction)
\end_layout

\begin_layout Enumerate
DevVarStringArray * (const DevVarStringArray * for extraction)
\end_layout

\begin_layout Enumerate
DevVarLongStringArray * (const DevVarLongStringArray * for extraction)
\end_layout

\begin_layout Enumerate
DevVarDoubleStringArray * (const DevVarDoubleStringArray * for extraction)
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\series bold
Note :
\begin_inset Newline newline
\end_inset

Insertion by pointers takes full ownership of the pointed to memory.
 The insertion copy the data in the DeviceData object and delete the pointed
 to memory.
 Therefore, the memory is not more usable after the insertion.
 Also note that when using extraction by pointers, the pointed to memory
 is inside the DeviceData object and its lifetime is the same than the DeviceDat
a object lifetime.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Operators also exist for inserting TANGO CORBA sequence type by reference.
 The insertion copy the data into the DeviceData object.
 Insert operator exist for the following types :
\end_layout

\begin_layout Enumerate
DevVarUCharArray &
\end_layout

\begin_layout Enumerate
DevVarShortArray &
\end_layout

\begin_layout Enumerate
DevVarUShortArray &
\end_layout

\begin_layout Enumerate
DevVarLongArray &
\end_layout

\begin_layout Enumerate
DevVarULongArray &
\end_layout

\begin_layout Enumerate
DevVarLong64Array &
\end_layout

\begin_layout Enumerate
DevVarULong64Array &
\end_layout

\begin_layout Enumerate
DevVarFloatArray &
\end_layout

\begin_layout Enumerate
DevVarDoubleArray &
\end_layout

\begin_layout Enumerate
DevVarStringArray &
\end_layout

\begin_layout Enumerate
DevVarLongStringArray &
\end_layout

\begin_layout Enumerate
DevVarDoubleStringArray &
\end_layout

\begin_layout Standard
Additional methods exist for inserting a mixture of strings and long (Tango::Dev
VarLongStringArray) and string and doubles (Tango::DevVarDoubleStringArray).
 These are :
\end_layout

\begin_layout Enumerate
insert(vector<long>&, vector<string>&)
\end_layout

\begin_layout Enumerate
insert(vector<double>&, vector<string>&)
\end_layout

\begin_layout Enumerate
extract(vector<long>&, vector<string>&)
\end_layout

\begin_layout Enumerate
extract(vector<double>&, vector<string>&)
\end_layout

\begin_layout Standard
\noindent
All the extraction methods returns a boolean set to false if the extraction
 has failed (empty DeviceData, wrong data type...)
\end_layout

\begin_layout Standard
\noindent
Special care has been taken to avoid memory copy between the network layer
 and the user application.
 Nevertheless, C++ vector types are not the CORBA native type and one copy
 is unavoidable when using vectors.
 Using the native TANGO CORBA sequence types avoid any copy.
 When using these TANGO CORBA sequence types, insertion into the DeviceData
 object consumes the memory pointed to by the pointer.
 After the insertion, it is not necessary to delete the memory.
 It will be done by the destruction of the DeviceData object.
 For extraction, the pointer used for the extraction points into memory
 inside the DeviceData object and you should not delete it
\end_layout

\begin_layout Standard
\noindent
Here is an example of creating, inserting and extracting some data type
 from/into DeviceData object :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DeviceData my_short, my_long, my_string;
\end_layout

\begin_layout Verbatim
\noindent
DeviceData my_float_vector, my_double_vector;
\end_layout

\begin_layout Verbatim
\noindent
string a_string;
\end_layout

\begin_layout Verbatim
\noindent
short a_short;
\end_layout

\begin_layout Verbatim
\noindent
DevLong a_long;
\end_layout

\begin_layout Verbatim
\noindent
vector<float> a_float_vector;
\end_layout

\begin_layout Verbatim
\noindent
vector<double> a_double_vector;
\end_layout

\begin_layout Verbatim
\noindent
my_short << 100; // insert a short
\end_layout

\begin_layout Verbatim
\noindent
my_short >> a_short; // extract a short
\end_layout

\begin_layout Verbatim
\noindent
my_long << 1000; // insert a long
\end_layout

\begin_layout Verbatim
\noindent
my_long >> a_long; // extract a long
\end_layout

\begin_layout Verbatim
\noindent
my_string << string(
\begin_inset Quotes eld
\end_inset

estas lista a bailar el tango ?
\begin_inset Quotes erd
\end_inset

); // insert a string
\end_layout

\begin_layout Verbatim
\noindent
my_string >> a_string; // extract a string
\end_layout

\begin_layout Verbatim
\noindent
my_float_vector << a_float_vector // insert a vector of floats
\end_layout

\begin_layout Verbatim
\noindent
my_float_vector >> a_float_vector; // extract a vector of floats
\end_layout

\begin_layout Verbatim
\noindent
my_double_vector << a_double_vector; // insert a vector of doubles
\end_layout

\begin_layout Verbatim
\noindent
my_double_vector >> a_double_vector; // extract a vector of doubles
\begin_inset Newline newline
\end_inset

//
\end_layout

\begin_layout Verbatim
// Example of memory management with TANGO sequence types without memory
 leaks
\end_layout

\begin_layout Verbatim
//
\end_layout

\begin_layout Verbatim
for (int i = 0;i < 10;i++)
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
    DeviceData din,dout;
\end_layout

\begin_layout Verbatim
    DevVarLongArray *in = new DevVarLongArray();
\end_layout

\begin_layout Verbatim
    in->length(2);
\end_layout

\begin_layout Verbatim
    (*in)[0] = 2;
\end_layout

\begin_layout Verbatim
    (*in)[1] = 4;
\end_layout

\begin_layout Verbatim
    din << in;
\end_layout

\begin_layout Verbatim
    try
\end_layout

\begin_layout Verbatim
    {
\end_layout

\begin_layout Verbatim
        dout = device->command_inout(
\begin_inset Quotes eld
\end_inset

Cmd
\begin_inset Quotes erd
\end_inset

,din);
\end_layout

\begin_layout Verbatim
    }
\end_layout

\begin_layout Verbatim
    catch(DevFailed &e)
\end_layout

\begin_layout Verbatim
    {
\end_layout

\begin_layout Verbatim
       ....
\end_layout

\begin_layout Verbatim
    }
\end_layout

\begin_layout Verbatim
    const DevVarLongArray *out;
\end_layout

\begin_layout Verbatim
    dout >> out;
\end_layout

\begin_layout Verbatim
    cout << 
\begin_inset Quotes eld
\end_inset

Received value = 
\begin_inset Quotes eld
\end_inset

 << (*out)[0];
\end_layout

\begin_layout Verbatim
}
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exception: WrongData if requested
\end_layout

\begin_layout Subsection
\noindent
bool DeviceData::is_empty()
\end_layout

\begin_layout Standard
\noindent
is_empty() is a boolean method which returns true or false depending on
 whether the DeviceData object contains data or not.
 It can be used to test whether the DeviceData has been initialized or not
 e.g.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
string string_read;
\end_layout

\begin_layout Verbatim
\noindent
DeviceData sl_read = my_device->command_inout(
\begin_inset Quotes eld
\end_inset

ReadLine
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Verbatim
\noindent
if (! sl_read.is_empty()) 
\end_layout

\begin_layout Verbatim
\noindent
{
\end_layout

\begin_layout Verbatim
\noindent
    sl_read >> string_read;
\end_layout

\begin_layout Verbatim
\noindent
}
\end_layout

\begin_layout Verbatim
\noindent
else
\end_layout

\begin_layout Verbatim
\noindent
{
\end_layout

\begin_layout Verbatim
\noindent
    cout << 
\begin_inset Quotes eld
\end_inset

 no data read from serial line !
\begin_inset Quotes erd
\end_inset

 << endl;
\end_layout

\begin_layout Verbatim
\noindent
}
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: WrongData if requested
\end_layout

\begin_layout Subsection
int DeviceData::get_type()
\end_layout

\begin_layout Standard
\noindent
This method returns the Tango data type of the data inside the DeviceData
 object
\end_layout

\begin_layout Subsection
\noindent
void DeviceData::exceptions(bitset<DeviceData::numFlags> )
\end_layout

\begin_layout Standard
\noindent
Is a method which allows the user to switch on/off exception throwing when
 trying to extract data from an empty DeviceData object or using a wrong
 data type.
 The default is to not throw exception.
 The following flags are supported :
\end_layout

\begin_layout Enumerate
\noindent

\series bold
isempty_flag
\series default
 - throw a WrongData exception (reason = API_EmptyDeviceData) if user tries
 to extract data from an empty DeviceData object
\end_layout

\begin_layout Enumerate

\series bold
wrongtype_flag
\series default
 - throw a WrongData exception (reason = API_IncompatibleCmdArgumentType)
 if user tries to extract data with a type different than the type used
 for insertion
\end_layout

\begin_layout Subsection
bitset<DeviceData::numFlags> exceptions()
\end_layout

\begin_layout Standard
Returns the whole exception flags.
\end_layout

\begin_layout Subsection
void DeviceData::reset_exceptions(DeviceData::except_flags fl)
\end_layout

\begin_layout Standard
Resets one exception flag
\end_layout

\begin_layout Subsection
void DeviceData::set_exceptions(DeviceData::except_flags fl)
\end_layout

\begin_layout Standard
Sets one exception flag
\end_layout

\begin_layout Standard
The following is an example of how to use these exceptions related methods
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
     1          DeviceData da;
\end_layout

\begin_layout Verbatim
     2  
\end_layout

\begin_layout Verbatim
     3          bitset<DeviceData::numFlags> bs = da.exceptions();
\end_layout

\begin_layout Verbatim
     4          cout << "bs = " << bs << endl;
\end_layout

\begin_layout Verbatim
     5                  
\end_layout

\begin_layout Verbatim
     6          da.set_exceptions(DeviceData::wrongtype_flag);
\end_layout

\begin_layout Verbatim
     7          bs = da.exceptions();
\end_layout

\begin_layout Verbatim
     8                  
\end_layout

\begin_layout Verbatim
     9          cout << "bs = " << bs << endl;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Subsection
ostream &operator<<(ostream &, DeviceData &)
\end_layout

\begin_layout Standard
Is an utility function to easily print the contents of a DeviceData object.
 This function knows all types which could be inserted in a DeviceData object
 and print them accordingly.
 A special string is printed if the DeviceData object is empty
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DeviceProxy *dev = new DeviceProxy(
\begin_inset Quotes eld
\end_inset

...
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Verbatim
DeviceData out;
\end_layout

\begin_layout Verbatim
out = dev->command_inout(
\begin_inset Quotes eld
\end_inset

MyCommand
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
cout << 
\begin_inset Quotes eld
\end_inset

Command returned: 
\begin_inset Quotes erd
\end_inset

 << out << endl;
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Section
Tango::DeviceDataHistory
\begin_inset CommandInset label
LatexCommand label
name "DataHistory"

\end_inset


\end_layout

\begin_layout Standard
This is the fundamental type for receiving data from device command polling
 buffers.
 This class inherits from the Tango::DeviceData class.
 One instance of this class is created for each command result history.
 Within this class, you find the command result data or the exception parameters
, a flag indicating if the command has failed when it was invoked by the
 device server polling thread and the date when the command was executed.
 For history calls, it is not possible to returns command error as exception.
 See chapter on Advanced Features for all details regarding device polling.
 On top of the methods inherited from the DeviceData class, it offers the
 following methods
\end_layout

\begin_layout Subsection
bool DeviceDataHistory::has_failed()
\end_layout

\begin_layout Standard
Returns true if the corresponding command has failed when it was executed
 by the device server polling thread.
 Otherwise returns false (amazing!)
\end_layout

\begin_layout Standard

\emph on
Exception: none
\end_layout

\begin_layout Subsection
TimeVal &DeviceDataHistory::get_date()
\end_layout

\begin_layout Standard
Returns the date when the device server polling thread has executed the
 command.
\end_layout

\begin_layout Standard

\emph on
Exception: none
\end_layout

\begin_layout Subsection
const DevErrorList &DeviceDataHistory::get_err_stack()
\end_layout

\begin_layout Standard
Return the error stack recorded by the device server polling thread in case
 of the command failed when it was invoked.
\end_layout

\begin_layout Standard

\emph on
Exception: none
\end_layout

\begin_layout Subsection
ostream &operator<<(ostream &, DeviceDataHistory &)
\end_layout

\begin_layout Standard
Is an utility function to easily print the contents of a DeviceDataHistory
 object.
 This function knows all types which could be inserted in a DeviceDataHistory
 object and print them accordingly.
 It also prints date and error stack in case the command returned an error.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DeviceProxy *dev = new DeviceProxy(
\begin_inset Quotes eld
\end_inset

...
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Verbatim
int hist_depth = 4;
\end_layout

\begin_layout Verbatim
vector<DeviceDataHistory> *hist;
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
hist = dev->command_history(
\begin_inset Quotes eld
\end_inset

MyCommand
\begin_inset Quotes erd
\end_inset

,hist_depth);
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
for (int i = 0;i < hist_depth;i++)
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
    cout << (*hist)[i] << endl;
\end_layout

\begin_layout Verbatim
}
\end_layout

\begin_layout Verbatim
delete hist;
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Section
\noindent
Tango::DeviceAttribute
\end_layout

\begin_layout Standard
\noindent
This is the fundamental type for sending and receiving data to and from
 device attributes.
 The values can be inserted and extracted using the operators << and >>
 respectively and insert() for mixed data types.
 There are two ways to check if the extraction operator succeed :
\end_layout

\begin_layout Enumerate
By testing the extractor operators return value.
 All the extractors operator returns a boolean value set to false in case
 of problem.
\end_layout

\begin_layout Enumerate
By asking the DeviceAttribute object to throw exception in case of problem.
 By default, DeviceAttribute throws exception :
\end_layout

\begin_deeper
\begin_layout Enumerate
when the user try to extract data and the server reported an error when
 the attribute was read.
\end_layout

\begin_layout Enumerate
When the user try to extract data from an empty DeviceAttribute
\end_layout

\end_deeper
\begin_layout Subsection
Constructors, assignement operators
\end_layout

\begin_layout Standard
Many constructors have been written for this class.
 The following constructors exist :
\end_layout

\begin_layout Enumerate
The C++ basic constructors
\end_layout

\begin_deeper
\begin_layout Enumerate
DeviceAttribute();
\end_layout

\begin_layout Enumerate
DeviceAttribute(const DeviceAttribute&)
\series bold
;
\end_layout

\end_deeper
\begin_layout Enumerate
Constructors for scalar type with name as C++ string or "const char *"
\end_layout

\begin_deeper
\begin_layout Enumerate
DeviceAttribute(string &, bool);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, short)
\series bold
;
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, DevLong);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, DevLong64);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, float);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, double);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, unsigned char);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, unsigned short);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, DevULong);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, DevULong64);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, string &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, DevState);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, DevEncoded &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, bool);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, short)
\series bold
;
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, DevLong);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, DevLong64);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, float)
\series bold
;
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, double);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, unsigned char)
\series bold
;
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, unsigned short);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, DevULong);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, DevULong64);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, string &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, DevState);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *,DevEncoded &);
\end_layout

\end_deeper
\begin_layout Enumerate
Constructors for C++ vector types (for spectrum attribute) with name as
 C++ string or "const char *"
\end_layout

\begin_deeper
\begin_layout Enumerate
DeviceAttribute(string &, vector<bool> &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector
\series bold
<
\series default
short
\series bold
>
\series default
 &)
\series bold
;
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<DevLong> &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<DevLong64> &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<float> &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<double> &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<unsigned char> &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<unsigned short> &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<DevULong> &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<DevULong64> &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<string> & );
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<DevState> &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<bool> &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<short> &)
\series bold
;
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<DevLong> &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<DevLong64> &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<float> &)
\series bold
;
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<double> &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<unsigned char> &)
\series bold
;
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<unsigned short> &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<DevULong> &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<DevULong64> &);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<string> & );
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<DevState> &);
\end_layout

\end_deeper
\begin_layout Enumerate
Constructors for C++ vector types (for image attribute) with name as C++
 string or "const char *".
 These constructors have two more parameters allowing the user to define
 the x and y image dimensions.
\end_layout

\begin_deeper
\begin_layout Enumerate
DeviceAttribute(string &, vector<bool> &, int, int);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<short> &, int, int
\series bold
)
\series default
;
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<DevLong> &, int, int);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<DevLong64> &, int, int);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<float> &, int, int);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<double> &, int, int);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<unsigned char> &, int, int);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<unsigned short> &, int, int);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<DevULong> &, int, int);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<DevULong64> &, int, int);
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<string> &, int, int );
\end_layout

\begin_layout Enumerate
DeviceAttribute(string &, vector<DevState> &, int, int);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<bool> &, int, int);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<short> &, int, int)
\series bold
;
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<DevLong> &, int, int);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<DevLong64> &, int, int);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<float> &, int, int)
\series bold
;
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<double> &, int, int);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<unsigned char> &, int, int)
\series bold
;
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<unsigned short> &, int, int);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<DevULong> &, int, int);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<DevULong64> &, int, int);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<string> & , int, int);
\end_layout

\begin_layout Enumerate
DeviceAttribute(const char *, vector<DevState) &, int, int);
\end_layout

\end_deeper
\begin_layout Standard
Note that the assignement operator and the copy constructor does not really
 copy the data included in the instance.
 For efficiency reasons, they rather move the data from one instance to
 another.
 Starting with Tango 8 and if Tango is compiled with gcc release 4.3 or above
 (or Windows VC 10 and above), some move semantics from C++11
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
C++11
\end_layout

\end_inset

 has been added.
 This means that:
\end_layout

\begin_layout Itemize
A move constructor (
\emph on
DeviceAttribute(DeviceAttribute &&)
\emph default
) has been added.
\end_layout

\begin_layout Itemize
A move assignement operator (
\emph on
DeviceAttribute & operator=(DeviceAttribute &&)
\emph default
) has been added.
\end_layout

\begin_layout Itemize
The classical copy constructor and assignement operator really copy the
 data.
\end_layout

\begin_layout Subsection
\noindent
Data Extraction and Insertion : Operators and Methods
\end_layout

\begin_layout Standard
\noindent
Special care has been taken to avoid memory copy between the network layer
 and the user application.
 Nevertheless, C++ vector types are not the CORBA native type and one copy
 is unavoidable when using vectors.
 Using the native TANGO CORBA sequence types in most cases avoid any copy
 but needs some more care about memory usage.
 
\end_layout

\begin_layout Itemize
\noindent

\series bold
For insertion into DeviceAttribute instance from TANGO CORBA sequence pointers,
 the DeviceAttribute object takes ownership of the pointed to memory.
 This means that the pointed to memory will be freed when the DeviceAttribute
 object is destroyed or when another data is inserted into it.
\end_layout

\begin_layout Itemize

\series bold
The insertion into DeviceAttribute instance from TANGO CORBA sequence reference
 copy the data into the DeviceAttribute object.
\end_layout

\begin_layout Itemize
\noindent

\series bold
For extraction into TANGO CORBA sequence types, the extraction method consumes
 the memory allocated to store the data and it is the caller responsibility
 to delete this memory.
\end_layout

\begin_layout Standard
\noindent
As it has been done for constructors, a lot of insertors operator for classical
 C++ data types have been defined :
\end_layout

\begin_layout Enumerate
\noindent
Insert operators for the following scalar C++ types :
\end_layout

\begin_deeper
\begin_layout Enumerate
\noindent
bool
\end_layout

\begin_layout Enumerate
\noindent
short
\end_layout

\begin_layout Enumerate
\noindent
DevLong
\end_layout

\begin_layout Enumerate
DevLong64
\end_layout

\begin_layout Enumerate
\noindent
float
\end_layout

\begin_layout Enumerate
\noindent
double
\end_layout

\begin_layout Enumerate
\noindent
unsigned char
\end_layout

\begin_layout Enumerate
\noindent
unsigned short
\end_layout

\begin_layout Enumerate
DevULong
\end_layout

\begin_layout Enumerate
DevULong64
\end_layout

\begin_layout Enumerate
\noindent
string
\end_layout

\begin_layout Enumerate
DevState
\end_layout

\begin_layout Enumerate
DevEncoded
\end_layout

\begin_layout Enumerate
DevString
\end_layout

\begin_layout Enumerate
const char *
\end_layout

\end_deeper
\begin_layout Enumerate
Insert operators for the following C++ vector types for spectrum attributes
 :
\end_layout

\begin_deeper
\begin_layout Enumerate
\noindent
vector<bool>
\end_layout

\begin_layout Enumerate
\noindent
vector<short>
\end_layout

\begin_layout Enumerate
\noindent
vector<DevLong>
\end_layout

\begin_layout Enumerate
vector<DevLong64>
\end_layout

\begin_layout Enumerate
\noindent
vector<float>
\end_layout

\begin_layout Enumerate
\noindent
vector<double>
\end_layout

\begin_layout Enumerate
\noindent
vector<unsigned char>
\end_layout

\begin_layout Enumerate
\noindent
vector<unsigned short>
\end_layout

\begin_layout Enumerate
vector<DevULong>
\end_layout

\begin_layout Enumerate
vector<DevULong64>
\end_layout

\begin_layout Enumerate
\noindent
vector<string>
\end_layout

\begin_layout Enumerate
vector<DevState>
\end_layout

\end_deeper
\begin_layout Enumerate
Insert methods for the DevEncoded
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
DevEncoded
\end_layout

\end_inset

 data type
\end_layout

\begin_deeper
\begin_layout Enumerate
insert(char *&, unsigned char *&, unsigned int)
\begin_inset Newline newline
\end_inset

The last argument is the size of the buffer passed to the method as its
 second argument
\end_layout

\begin_layout Enumerate
insert(string &, vector<unsigned char &>)
\end_layout

\end_deeper
\begin_layout Enumerate
Insert methods for the following C++ vector types for image attributes allowing
 the specification of the x and y image dimensions :
\end_layout

\begin_deeper
\begin_layout Enumerate
\noindent
insert(vector<bool> &,int, int)
\end_layout

\begin_layout Enumerate
\noindent
insert(vector<short> &,int, int)
\end_layout

\begin_layout Enumerate
\noindent
insert(vector<DevLong> &,int, int)
\end_layout

\begin_layout Enumerate
\noindent
insert(vector<DevLong64> &,int, int)
\end_layout

\begin_layout Enumerate
\noindent
insert(vector<float> &,int, int)
\end_layout

\begin_layout Enumerate
\noindent
insert(vector<double> &,int, int)
\end_layout

\begin_layout Enumerate
\noindent
insert(vector<unsigned char> &,int, int)
\end_layout

\begin_layout Enumerate
\noindent
insert(vector<unsigned short> &,int, int)
\end_layout

\begin_layout Enumerate
\noindent
insert(vector<DevULong> &,int, int)
\end_layout

\begin_layout Enumerate
\noindent
insert(vector<DevULong64> &,int, int)
\end_layout

\begin_layout Enumerate
\noindent
insert(vector<string> &,int, int)
\end_layout

\begin_layout Enumerate
insert(vector<DevState> &,int, int)
\end_layout

\end_deeper
\begin_layout Standard
Extractor operators are specified for the following C++ basic types
\end_layout

\begin_layout Enumerate
Extract operators for the following scalar C++ types :
\end_layout

\begin_deeper
\begin_layout Enumerate
\noindent
bool
\end_layout

\begin_layout Enumerate
\noindent
short
\end_layout

\begin_layout Enumerate
\noindent
DevLong
\end_layout

\begin_layout Enumerate
DevLong64
\end_layout

\begin_layout Enumerate
\noindent
float
\end_layout

\begin_layout Enumerate
\noindent
double
\end_layout

\begin_layout Enumerate
\noindent
unsigned char
\end_layout

\begin_layout Enumerate
\noindent
unsigned short
\end_layout

\begin_layout Enumerate
\noindent
DevULong
\end_layout

\begin_layout Enumerate
DevULong64
\end_layout

\begin_layout Enumerate
\noindent
string
\end_layout

\begin_layout Enumerate
Tango::DevState
\end_layout

\begin_layout Enumerate
Tango::DevEncoded
\end_layout

\end_deeper
\begin_layout Enumerate
Extract operators for the following C++ vector types for spectrum and image
 attributes :
\end_layout

\begin_deeper
\begin_layout Enumerate
\noindent
vector<bool>
\end_layout

\begin_layout Enumerate
\noindent
vector<short>
\end_layout

\begin_layout Enumerate
\noindent
vector<DevLong>
\end_layout

\begin_layout Enumerate
vector<DevLong64>
\end_layout

\begin_layout Enumerate
\noindent
vector<float>
\end_layout

\begin_layout Enumerate
\noindent
vector<double>
\end_layout

\begin_layout Enumerate
\noindent
vector<unsigned char>
\end_layout

\begin_layout Enumerate
\noindent
vector<unsigned short>
\end_layout

\begin_layout Enumerate
\noindent
vector<DevULong>
\end_layout

\begin_layout Enumerate
vector<DevULong64>
\end_layout

\begin_layout Enumerate
\noindent
vector<string>
\end_layout

\begin_layout Enumerate
vector<DevState>
\end_layout

\end_deeper
\begin_layout Enumerate
Extract methods to extract only the read value of an attribute into a C++
 vector.
 The dimension of the read value can be read by using the methods get_dim_x()
 and get_dim_y() or get_r_dimension().
 The methods use the same return values as the extraction operators with
 exceptions triggered by the exception flags:
\end_layout

\begin_deeper
\begin_layout Enumerate
bool DeviceAttribute::extract_read (vector<bool>&);
\end_layout

\begin_layout Enumerate
\noindent
bool DeviceAttribute::extract_read (vector<short>&);
\end_layout

\begin_layout Enumerate
\noindent
bool DeviceAttribute::extract_read (vector<DevLong>&);
\end_layout

\begin_layout Enumerate
bool DeviceAttribute::extract_read (vector<DevLong64>&);
\end_layout

\begin_layout Enumerate
\noindent
bool DeviceAttribute::extract_read (vector<float>&);
\end_layout

\begin_layout Enumerate
bool DeviceAttribute::extract_read (vector<double>&);
\end_layout

\begin_layout Enumerate
\noindent
bool DeviceAttribute::extract_read (vector<unsigned char>&);
\end_layout

\begin_layout Enumerate
\noindent
bool DeviceAttribute::extract_read (vector<unsigned short>&);
\end_layout

\begin_layout Enumerate
\noindent
bool DeviceAttribute::extract_read (vector<DevULong>&);
\end_layout

\begin_layout Enumerate
bool DeviceAttribute::extract_read (vector<DevULong64>&);
\end_layout

\begin_layout Enumerate
\noindent
bool DeviceAttribute::extract_read (vector<string>&);
\end_layout

\begin_layout Enumerate
bool DeviceAttribute::extract_read (vector<DevState>&);
\end_layout

\begin_layout Enumerate
bool DeviceAttribute::extract_read(string &, vector<unsigned char> &);
\end_layout

\end_deeper
\begin_layout Enumerate
Extract methods to extract only the set value of an attribute into a C++
 vector.
 The dimension of the set value can be read by using the methods get_written_dim
_x() and get_written_dim_y() or get_w_dimension().
 The methods use the same return values as the extraction operators with
 exceptions triggered by the exception flags:
\end_layout

\begin_deeper
\begin_layout Enumerate
bool DeviceAttribute::extract_set (vector<bool>&);
\end_layout

\begin_layout Enumerate
\noindent
bool DeviceAttribute::extract_set (vector<short>&);
\end_layout

\begin_layout Enumerate
\noindent
bool DeviceAttribute::extract_set (vector<DevLong>&);
\end_layout

\begin_layout Enumerate
bool DeviceAttribute::extract_set (vector<DevLong64>&);
\end_layout

\begin_layout Enumerate
\noindent
bool DeviceAttribute::extract_set (vector<float>&);
\end_layout

\begin_layout Enumerate
bool DeviceAttribute::extract_set (vector<double>&);
\end_layout

\begin_layout Enumerate
\noindent
bool DeviceAttribute::extract_set (vector<unsigned char>&);
\end_layout

\begin_layout Enumerate
\noindent
bool DeviceAttribute::extract_set (vector<unsigned short>&);
\end_layout

\begin_layout Enumerate
\noindent
bool DeviceAttribute::extract_set (vector<DevULong>&);
\end_layout

\begin_layout Enumerate
bool DeviceAttribute::extract_set (vector<DevULong64>&);
\end_layout

\begin_layout Enumerate
\noindent
bool DeviceAttribute::extract_set (vector<string>&);
\end_layout

\begin_layout Enumerate
bool DeviceAttribute::extract_set (vector<DevState>&);
\end_layout

\begin_layout Enumerate
bool DeviceAttribute::extract_set(string &, vector<unsigned char> &);
\end_layout

\end_deeper
\begin_layout Enumerate
Special extract method for the Tango::DevEncoded data type
\end_layout

\begin_deeper
\begin_layout Enumerate
bool DeviceAttribute::extract(const char *&, unsigned char *&, unsigned
 int &);
\begin_inset Newline newline
\end_inset

The last argument is the size of the buffer passed to the method as its
 second argument
\end_layout

\begin_layout Enumerate
bool DeviceAttribute::extract(string &, vector<unsigned char> &);
\end_layout

\end_deeper
\begin_layout Standard
\noindent
Operators also exist for extracting some native TANGO CORBA sequence types.
 These can be useful for programmers who want to use the TANGO api internally
 in their device servers and do not want to convert from CORBA to C++ types.
 
\end_layout

\begin_layout Enumerate
\noindent
Insert operators for spectrum attribute and for the following types by pointer
 :
\end_layout

\begin_deeper
\begin_layout Enumerate
DevVarBooleanArray *
\end_layout

\begin_layout Enumerate
DevVarShortArray *
\end_layout

\begin_layout Enumerate
DevVarLongArray *
\end_layout

\begin_layout Enumerate
DevVarLong64Array *
\end_layout

\begin_layout Enumerate
DevVarFloatArray *
\end_layout

\begin_layout Enumerate
DevVarDoubleArray *
\end_layout

\begin_layout Enumerate
DevVarUCharArray *
\end_layout

\begin_layout Enumerate
DevVarUShortArray *
\end_layout

\begin_layout Enumerate
DevVarULongArray *
\end_layout

\begin_layout Enumerate
DevVarULong64Array *
\end_layout

\begin_layout Enumerate
DevVarStringArray *
\end_layout

\begin_layout Enumerate
DevVarStateArray *
\end_layout

\end_deeper
\begin_layout Enumerate
Insert operators for spectrum attribute and for the following types by reference
 :
\end_layout

\begin_deeper
\begin_layout Enumerate
const DevVarBooleanArray &
\end_layout

\begin_layout Enumerate
const DevVarShortArray &
\end_layout

\begin_layout Enumerate
const DevVarLongArray &
\end_layout

\begin_layout Enumerate
const DevVarLong64Array &
\end_layout

\begin_layout Enumerate
const DevVarFloatArray &
\end_layout

\begin_layout Enumerate
const DevVarDoubleArray &
\end_layout

\begin_layout Enumerate
const DevVarUCharArray &
\end_layout

\begin_layout Enumerate
const DevVarUShortArray &
\end_layout

\begin_layout Enumerate
const DevVarULongArray &
\end_layout

\begin_layout Enumerate
const DevVarULong64Array &
\end_layout

\begin_layout Enumerate
const DevVarStringArray &
\end_layout

\begin_layout Enumerate
const DevVarStateArray &
\end_layout

\end_deeper
\begin_layout Enumerate
Insert methods for image attribute and pointers.
 These method allow the programmer to define the x and y image dimensions.
 The following methods are defined :
\end_layout

\begin_deeper
\begin_layout Enumerate
insert(DevVarBooleanArray *, int , int )
\end_layout

\begin_layout Enumerate
insert(DevVarShortArray *, int , int )
\end_layout

\begin_layout Enumerate
insert(DevVarLongArray *, int , int )
\end_layout

\begin_layout Enumerate
insert(DevVarLong64Array *, int, int )
\end_layout

\begin_layout Enumerate
insert(DevVarFloatArray *, int , int )
\end_layout

\begin_layout Enumerate
insert(DevVarDoubleArray *, int , int )
\end_layout

\begin_layout Enumerate
insert(DevVarUCharArray *, int , int )
\end_layout

\begin_layout Enumerate
insert(DevVarUShortArray *, int , int )
\end_layout

\begin_layout Enumerate
insert(DevVarULongArray *, int , int )
\end_layout

\begin_layout Enumerate
insert(DevVarULong64Array *, int, int )
\end_layout

\begin_layout Enumerate
insert(DevVarStringArray *, int , int )
\end_layout

\begin_layout Enumerate
insert(DevVarStateArray *, int, int)
\end_layout

\end_deeper
\begin_layout Enumerate
Insert methods for image attribute and reference.
 These method allow the programmer to define the x and y image dimensions.
 The following methods are defined :
\end_layout

\begin_deeper
\begin_layout Enumerate
insert(const DevVarBooleanArray &, int , int )
\end_layout

\begin_layout Enumerate
insert(const DevVarShortArray &, int , int )
\end_layout

\begin_layout Enumerate
insert(const DevVarLongArray &, int , int )
\end_layout

\begin_layout Enumerate
insert(const DevVarLong64Array &, int, int )
\end_layout

\begin_layout Enumerate
insert(const DevVarFloatArray &, int , int )
\end_layout

\begin_layout Enumerate
insert(const DevVarDoubleArray &, int , int )
\end_layout

\begin_layout Enumerate
insert(const DevVarUCharArray &, int , int )
\end_layout

\begin_layout Enumerate
insert(const DevVarUShortArray &, int , int )
\end_layout

\begin_layout Enumerate
insert(const DevVarULongArray &, int , int )
\end_layout

\begin_layout Enumerate
insert(const DevVarULong64Array &, int, int )
\end_layout

\begin_layout Enumerate
insert(const DevVarStringArray &, int , int )
\end_layout

\begin_layout Enumerate
insert(const DevVarStateArray &, int, int )
\end_layout

\end_deeper
\begin_layout Enumerate
Extract operators for the following types :
\end_layout

\begin_deeper
\begin_layout Enumerate
DevVarBooleanArray *
\end_layout

\begin_layout Enumerate
DevVarShortArray *
\end_layout

\begin_layout Enumerate
DevVarLongArray *
\end_layout

\begin_layout Enumerate
DevVarLong64Array *
\end_layout

\begin_layout Enumerate
DevVarFloatArray *
\end_layout

\begin_layout Enumerate
DevVarDoubleArray *
\end_layout

\begin_layout Enumerate
DevVarUCharArray *
\end_layout

\begin_layout Enumerate
DevVarUShortArray *
\end_layout

\begin_layout Enumerate
DevVarULongArray *
\end_layout

\begin_layout Enumerate
DevVarULong64Array *
\end_layout

\begin_layout Enumerate
DevVarStringArray *
\end_layout

\begin_layout Enumerate
DevVarStateArray *
\end_layout

\begin_layout Enumerate
DevVarEncodedArray *
\end_layout

\end_deeper
\begin_layout Standard
\noindent
Here is an example of creating, inserting and extracting some DeviceAttribute
 types :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DeviceAttribute my_short, my_long, my_string;
\end_layout

\begin_layout Verbatim
\noindent
DeviceAttribute my_float_vector, my_double_vector;
\end_layout

\begin_layout Verbatim
\noindent
string a_string;
\end_layout

\begin_layout Verbatim
\noindent
short a_short;
\end_layout

\begin_layout Verbatim
\noindent
DevLong a_long;
\end_layout

\begin_layout Verbatim
\noindent
vector<float> a_float_vector;
\end_layout

\begin_layout Verbatim
\noindent
vector<double> a_double_vector;
\end_layout

\begin_layout Verbatim
\noindent
my_short << 100; // insert a short
\end_layout

\begin_layout Verbatim
\noindent
my_short >> a_short; // extract a short
\end_layout

\begin_layout Verbatim
\noindent
my_long << 1000; // insert a long
\end_layout

\begin_layout Verbatim
\noindent
my_long >> a_long; // extract a DevLong
\end_layout

\begin_layout Verbatim
\noindent
my_string << string("estas lista a bailar el tango ?"); // insert a string
\end_layout

\begin_layout Verbatim
\noindent
my_string >> a_string; // extract a string
\end_layout

\begin_layout Verbatim
\noindent
my_float_vector << a_float_vector // insert a vector of floats
\end_layout

\begin_layout Verbatim
\noindent
my_float_vector >> a_float_vector; // extract a vector of floats
\end_layout

\begin_layout Verbatim
\noindent
my_double_vector << a_double_vector; // insert a vector of doubles
\end_layout

\begin_layout Verbatim
\noindent
my_double_vector >> a_double_vector; // extract a vector of doubles
\end_layout

\begin_layout Verbatim
//
\end_layout

\begin_layout Verbatim
// Extract read and set value of an attribute separately
\end_layout

\begin_layout Verbatim
// and get their dimensions
\end_layout

\begin_layout Verbatim
//
\end_layout

\begin_layout Verbatim
\noindent
vector<float> r_float_vector, w_float_vector;
\end_layout

\begin_layout Verbatim
my_float_vector.extract_read (r_float_vector) // extract read values
\end_layout

\begin_layout Verbatim
int dim_x = my_float_vector.get_dim_x();      // get x dimension
\end_layout

\begin_layout Verbatim
int dim_y = my_float_vector.get_dim_y();      // get y dimension
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
my_float_vector.extract_set  (w_float_vector) // extract set values
\end_layout

\begin_layout Verbatim
int w_dim_x = my_float_vector.get_written_dim_x();  // get x dimension
\end_layout

\begin_layout Verbatim
int W_dim_y = my_float_vector.get_written_dim_y();  // get y dimension
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
//
\end_layout

\begin_layout Verbatim
// Example of memory management with TANGO sequence types without memory
 leaks
\end_layout

\begin_layout Verbatim
//
\end_layout

\begin_layout Verbatim
for (int i = 0;i < 10;i++)
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
    DeviceAttribute da;
\end_layout

\begin_layout Verbatim
    DevVarLongArray *out;
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
    try
\end_layout

\begin_layout Verbatim
    {
\end_layout

\begin_layout Verbatim
        da = device->read_attribute("Attr");
\end_layout

\begin_layout Verbatim
        da >> out;
\end_layout

\begin_layout Verbatim
    }
\end_layout

\begin_layout Verbatim
    catch(DevFailed &e)
\end_layout

\begin_layout Verbatim
    {
\end_layout

\begin_layout Verbatim
       ....
\end_layout

\begin_layout Verbatim
    }
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
    cout << "Received value = " << (*out)[0];
\end_layout

\begin_layout Verbatim
    delete out;
\end_layout

\begin_layout Verbatim
}
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exception: WrongData if requested
\end_layout

\begin_layout Subsection
\noindent
bool DeviceAttribute::is_empty()
\end_layout

\begin_layout Standard
\noindent
is_empty() is a boolean method which returns true or false depending on
 whether the DeviceAttribute object contains data or not.
 It can be used to test whether the DeviceAttribute has been initialized
 or not e.g.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
string parity;
\end_layout

\begin_layout Verbatim
\noindent
DeviceAttribute sl_parity = my_device->read_attribute("parity");
\end_layout

\begin_layout Verbatim
\noindent
if (! sl_read.is_empty()) 
\end_layout

\begin_layout Verbatim
\noindent
{
\end_layout

\begin_layout Verbatim
\noindent
    sl_parity >> parity;
\end_layout

\begin_layout Verbatim
\noindent
}
\end_layout

\begin_layout Verbatim
\noindent
else
\end_layout

\begin_layout Verbatim
\noindent
{
\end_layout

\begin_layout Verbatim
\noindent
    cout << " no parity attribute defined for serial line !" << endl;
\end_layout

\begin_layout Verbatim
\noindent
}
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: WrongData if requested
\end_layout

\begin_layout Subsection
\noindent
void DeviceAttribute::exceptions(bitset<DeviceAttribute::numFlags>)
\end_layout

\begin_layout Standard
\noindent
Is a method which allows the user to switch on/off exception throwing when
 trying to extract data from an empty DeviceAttribute object or with a wrong
 data type.
 The following flags are supported :
\end_layout

\begin_layout Enumerate
\noindent

\series bold
isempty_flag
\series default
 - throw a WrongData exception (reason= API_EmptyDeviceAttribute) if user
 tries to extract data from an empty DeviceAttribute object.
 By default, this flag is set.
\end_layout

\begin_layout Enumerate

\series bold
wrongtype_flag
\series default
 - throw a WrongData exception (reason = API_IncompatibleAttrArgumentType)
 if user tries to extract data with a type different than the type used
 for insertion.
 By default, this flag is not set.
\end_layout

\begin_layout Enumerate

\series bold
failed_flag
\series default
 - throw an exception when the user try to extract data from the DeviceAttribute
 object and an error was reported by the server when the user try to read
 the attribute.
 The type of the exception thrown is the type of the error reported by the
 server.
 By default, this flag is set.
\end_layout

\begin_layout Enumerate

\series bold
unknown_format_flag
\series default
 - throw an exception when the user try to get the attribute data format
 from the DeviceAttribute object when this information is not yet available.
 This information is available only after the 
\emph on
read_attribute
\emph default
 call has been sucessfully executed.
 The type of the exception thrown is WrongData exception (reason = API_EmptyDevi
ceAttribute).
 By default, this flag is not set.
\end_layout

\begin_layout Subsection
bitset<DeviceAttribute::numFlags> exceptions()
\end_layout

\begin_layout Standard
Return the whole exception flags.
\end_layout

\begin_layout Subsection
void DeviceAttribute::reset_exceptions(DeviceAttribute::except_flags fl)
\end_layout

\begin_layout Standard
Reset one exception flag
\end_layout

\begin_layout Subsection
void DeviceAttribute::set_exceptions(DeviceAttribute::except_flags fl)
\end_layout

\begin_layout Standard
Set one exception flag
\end_layout

\begin_layout Standard
The following is an example of how to use these exceptions related methods
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
     1  DeviceAttribute da;
\end_layout

\begin_layout Verbatim
     2  
\end_layout

\begin_layout Verbatim
     3  bitset<DeviceAttribute::numFlags> bs = da.exceptions();
\end_layout

\begin_layout Verbatim
     4  cout << "bs = " << bs << endl;
\end_layout

\begin_layout Verbatim
     5                  
\end_layout

\begin_layout Verbatim
     6  da.set_exceptions(DeviceAttribute::wrongtype_flag);
\end_layout

\begin_layout Verbatim
     7  bs = da.exceptions();
\end_layout

\begin_layout Verbatim
     8                  
\end_layout

\begin_layout Verbatim
     9  cout << "bs = " << bs << endl;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Subsection
bool DeviceAttribute::has_failed()
\end_layout

\begin_layout Standard
Returns a boolean set to true if the server report an error when the attribute
 was read.
\end_layout

\begin_layout Subsection
const DevErrorList &DeviceAttribute::get_err_stack()
\end_layout

\begin_layout Standard
Returns the error stack reported by the server when the attribute was read.
\end_layout

\begin_layout Standard
The following is an example of the three available ways to get data out
 of a DeviceAttribute object.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
     1  DeviceAttribute da;
\end_layout

\begin_layout Verbatim
     2  vector<short> attr_data;
\end_layout

\begin_layout Verbatim
     3  
\end_layout

\begin_layout Verbatim
     4  try
\end_layout

\begin_layout Verbatim
     5  {
\end_layout

\begin_layout Verbatim
     6      da = device->read_attribute("Attr");
\end_layout

\begin_layout Verbatim
     7      da >> attr_data;
\end_layout

\begin_layout Verbatim
     8  }
\end_layout

\begin_layout Verbatim
     9  catch (DevFailed &e)
\end_layout

\begin_layout Verbatim
    10  {
\end_layout

\begin_layout Verbatim
    11      ....
\end_layout

\begin_layout Verbatim
    12  }
\end_layout

\begin_layout Verbatim
    13  
\end_layout

\begin_layout Verbatim
    14  
\end_layout

\begin_layout Verbatim
    15  ------------------------------------------------------------------------
\end_layout

\begin_layout Verbatim
    16  
\end_layout

\begin_layout Verbatim
    17  DeviceAttribute da;
\end_layout

\begin_layout Verbatim
    18  vector<short> attr_data;
\end_layout

\begin_layout Verbatim
    19  
\end_layout

\begin_layout Verbatim
    20  da.reset_exceptions(DeviceAttribute::failed_flag);
\end_layout

\begin_layout Verbatim
    21  
\end_layout

\begin_layout Verbatim
    22  try
\end_layout

\begin_layout Verbatim
    23  {
\end_layout

\begin_layout Verbatim
    24      da = device->read_attribute("Attr");
\end_layout

\begin_layout Verbatim
    25  }
\end_layout

\begin_layout Verbatim
    26  catch (DevFailed &e)
\end_layout

\begin_layout Verbatim
    27  {
\end_layout

\begin_layout Verbatim
    28      .....
\end_layout

\begin_layout Verbatim
    29  }
\end_layout

\begin_layout Verbatim
    30  
\end_layout

\begin_layout Verbatim
    31  if (!(da >> attr_data))
\end_layout

\begin_layout Verbatim
    32  {
\end_layout

\begin_layout Verbatim
    33      DevErrorList &err = da.get_err_stack();
\end_layout

\begin_layout Verbatim
    34      .....
\end_layout

\begin_layout Verbatim
    35  }
\end_layout

\begin_layout Verbatim
    36  else
\end_layout

\begin_layout Verbatim
    37  {
\end_layout

\begin_layout Verbatim
    38      .....
\end_layout

\begin_layout Verbatim
    39  }
\end_layout

\begin_layout Verbatim
    40  
\end_layout

\begin_layout Verbatim
    41  ----------------------------------------------------------------------
\end_layout

\begin_layout Verbatim
    42  
\end_layout

\begin_layout Verbatim
    43  DeviceAttribute da;
\end_layout

\begin_layout Verbatim
    44  vector<short> attr_data;
\end_layout

\begin_layout Verbatim
    45  
\end_layout

\begin_layout Verbatim
    46  try
\end_layout

\begin_layout Verbatim
    47  {
\end_layout

\begin_layout Verbatim
    48      da = device->read_attribute("Attr");
\end_layout

\begin_layout Verbatim
    49  }
\end_layout

\begin_layout Verbatim
    50  catch (DevFailed &e)
\end_layout

\begin_layout Verbatim
    51  {
\end_layout

\begin_layout Verbatim
    52      ......
\end_layout

\begin_layout Verbatim
    53  }
\end_layout

\begin_layout Verbatim
    54  
\end_layout

\begin_layout Verbatim
    55  if (da.has_failed())
\end_layout

\begin_layout Verbatim
    56  {
\end_layout

\begin_layout Verbatim
    57      DevErrorList &err = da.get_err_stack();
\end_layout

\begin_layout Verbatim
    58      ....
\end_layout

\begin_layout Verbatim
    59  }
\end_layout

\begin_layout Verbatim
    60  else
\end_layout

\begin_layout Verbatim
    61  {
\end_layout

\begin_layout Verbatim
    62      da >> attr_data;        
\end_layout

\begin_layout Verbatim
    63  }
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
The first way is coded between lines 1 and 13.
 It uses the default behaviour of the DeviceAttribute object which is to
 throw an exception when the user try to extract data when the server reports
 an error when the attribute was read.
 The second way is coded between line 17 and 40.
 The DeviceAttribute object now does not throw "failed" exception any more
 and the return value of the extractor operator is checked.
 The third way is coded between line 43 and 63.
 In this case, the attribute data validity is checked before trying to extract
 them.
\end_layout

\begin_layout Subsection
string &DeviceAttribute::get_name()
\end_layout

\begin_layout Standard
Returns the name of the attribute
\end_layout

\begin_layout Subsection
void DeviceAttribute::set_name(string &)
\end_layout

\begin_layout Standard
Sets attribute name
\end_layout

\begin_layout Subsection
void DeviceAttribute::set_name(const char *)
\end_layout

\begin_layout Standard
Sets attribute name
\end_layout

\begin_layout Subsection
AttrQuality &DeviceAttribute::get_quality()
\end_layout

\begin_layout Standard
Returns the quality of the attribute: an enumerate type which can be one
 of {ATTR_VALID, ATTR_INVALID, ATTR_ALARM, ATTR_CHANGING or ATTR_WARNING}.
\end_layout

\begin_layout Subsection
int DeviceAttribute::get_dim_x()
\end_layout

\begin_layout Standard
Returns the attribute read x dimension
\end_layout

\begin_layout Subsection
int DeviceAttribute::get_dim_y()
\end_layout

\begin_layout Standard
Returns the attribute read y dimension
\end_layout

\begin_layout Subsection
int DeviceAttribute::get_written_dim_x()
\end_layout

\begin_layout Standard
Returns the attribute write x dimension
\end_layout

\begin_layout Subsection
int DeviceAttribute::get_written_dim_y()
\end_layout

\begin_layout Standard
Returns the attribute write y dimension
\end_layout

\begin_layout Subsection
AttributeDimension DeviceAttribute::get_r_dimension()
\end_layout

\begin_layout Standard
Returns the attribute read dimension
\end_layout

\begin_layout Subsection
AttributeDimension DeviceAttribute::get_w_dimension()
\end_layout

\begin_layout Standard
Returns the attribute write dimension
\end_layout

\begin_layout Subsection
long DeviceAttribute::get_nb_read()
\end_layout

\begin_layout Standard
Returns the number of read values
\end_layout

\begin_layout Subsection
long DeviceAttribute::get_nb_written()
\end_layout

\begin_layout Standard
Returns the number of written values.
 Here is an example of these last methods usage.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
 1  DeviceAttribute da;
\end_layout

\begin_layout Verbatim
 2  vector<short> attr_data;
\end_layout

\begin_layout Verbatim
 3  
\end_layout

\begin_layout Verbatim
 4  try
\end_layout

\begin_layout Verbatim
 5  {
\end_layout

\begin_layout Verbatim
 6     da = device->read_attribute("Attr");
\end_layout

\begin_layout Verbatim
 7     da >> attr_data;
\end_layout

\begin_layout Verbatim
 8  }
\end_layout

\begin_layout Verbatim
 9  catch (DevFailed &e)
\end_layout

\begin_layout Verbatim
10  {
\end_layout

\begin_layout Verbatim
11     ....
\end_layout

\begin_layout Verbatim
12  }
\end_layout

\begin_layout Verbatim
13  
\end_layout

\begin_layout Verbatim
14  long read = da.get_nb_read();
\end_layout

\begin_layout Verbatim
15  long written = da.get_nb_written();
\end_layout

\begin_layout Verbatim
16  size_t size = attr_data.size();
\end_layout

\begin_layout Verbatim
17  
\end_layout

\begin_layout Verbatim
18  for (long i = 0;i < read;i++)
\end_layout

\begin_layout Verbatim
19     cout << "Read value " << i+1 << " = " << attr_data[i] <<  endl;
\end_layout

\begin_layout Verbatim
20
\end_layout

\begin_layout Verbatim
21  int ind;
\end_layout

\begin_layout Verbatim
22  for (long j = 0; j < written;j++)
\end_layout

\begin_layout Verbatim
23  {
\end_layout

\begin_layout Verbatim
24     size == 1 ? ind = j : ind = j + read;
\end_layout

\begin_layout Verbatim
25     cout << "Last written value " << j+1 << " = " << attr_data[ind] <<
 endl;
\end_layout

\begin_layout Verbatim
26  }
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Line 24 is needed to cover the case of scalar write attribute where only
 one value is returned but both get_nb_read() and get_nb_written() methods
 return 1.
\end_layout

\begin_layout Subsection
TimeVal &DeviceAttribute::get_date()
\end_layout

\begin_layout Standard
Returns a reference to the time when the attribute was read in server
\end_layout

\begin_layout Subsection
int DeviceAttribute::get_type()
\end_layout

\begin_layout Standard
Returns the type of the attribute data.
\end_layout

\begin_layout Subsection
AttrDataFormat DeviceAttribute::get_data_format()
\end_layout

\begin_layout Standard
Returns the attribute data format.
 Note that this information is valid only after the call to the device has
 been executed.
 Otherwise the FMT_UNKNOWN value of the AttrDataFormat enumeration is returned
 or an exception is thrown according to the object exception flags.
\end_layout

\begin_layout Subsection
ostream &operator<<(ostream &, DeviceAttribute &)
\end_layout

\begin_layout Standard
Is an utility function to easily print the contents of a DeviceAttribute
 object.
 This function knows all types which could be inserted in a DeviceAttribute
 object and print them accordingly if the data are valid.
 It also prints the date returned within the attribute, the attribute name,
 the dim_x and dim_y attribute parameter and its quality factor.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DeviceProxy *dev = new DeviceProxy("...");
\end_layout

\begin_layout Verbatim
DeviceAttribute attr;
\end_layout

\begin_layout Verbatim
attr = dev->read_attribute("MyAttribute");
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
cout << "Attribute returned: " << attr << endl;
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Section
Tango::DeviceAttributeHistory
\begin_inset CommandInset label
LatexCommand label
name "AttributeHistory"

\end_inset


\end_layout

\begin_layout Standard
This is the fundamental type for receiving data from device attribute polling
 buffers.
 This class inherits from the Tango::DeviceAttribute class.
 One instance of this class is created for each attribute result history.
 Within this class, you find the attribute result data or the exception
 parameters and a flag indicating if the attribute has failed when it was
 invoked by the device server polling thread.
 For history calls, it is not possible to returns attribute error as exception.
 See chapter on Advanced Features for all details regarding device polling.
 On top of the methods inherited from the DeviceAttribute class, it offers
 the following methods
\end_layout

\begin_layout Subsection
ostream &operator<<(ostream &, DeviceAttributeHistory &)
\end_layout

\begin_layout Standard
Is an utility function to easily print the contents of a DeviceAttributeHistory
 object.
 This function knows all types which could be inserted in a DeviceAttributeHisto
ry object and print them accordingly.
 It also prints date, attribute name, attribute dim_x and dim_y parameters,
 attribute quality factor and error stack in case the attribute returned
 an error.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DeviceProxy *dev = new DeviceProxy(
\begin_inset Quotes eld
\end_inset

...
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Verbatim
int hist_depth = 4;
\end_layout

\begin_layout Verbatim
vector<DeviceAttributeHistory> *hist;
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
hist = dev->attribute_history(
\begin_inset Quotes eld
\end_inset

MyAttribute
\begin_inset Quotes erd
\end_inset

,hist_depth);
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
for (int i = 0;i < hist_depth;i++)
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
    cout << (*hist)[i] << endl;
\end_layout

\begin_layout Verbatim
}
\end_layout

\begin_layout Verbatim
delete hist;
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Section
Tango::AttributeProxy()
\end_layout

\begin_layout Standard
The high level object which provides the client with an easy-to-use interface
 to TANGO device attributes.
 AttributeProxy is a handle to the real Attribute (hence the name Proxy)
 and is not the real Attribute (of course).
 The AttributeProxy manages timeouts, stateless connections (new AttributeProxy(
) nearly always works), and reconnection if the device server is restarted.
\end_layout

\begin_layout Subsection
Constructors
\end_layout

\begin_layout Subsubsection
AttributeProxy::AttributeProxy(string &name)
\end_layout

\begin_layout Standard
Create an AttributeProxy to an attribute of the specified name.
 The constructor will connect to the TANGO database, query for the device
 to which the attribute belongs to network address and build a connection
 to this device.
 If the device to which the attribute belongs to is defined in the TANGO
 database but the device server is not running, AttributeProxy will try
 to build a connection every time the client tries to access the attribute.
 If an alias
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
alias
\end_layout

\end_inset

 name is defined for the attribute, this alias name can be used to create
 the AttributeProxy instance.
 If a device name alias is defined for the device, it can be used instead
 of the three fields device name.
 If the device to which the attribute belongs to is not defined in the database,
 an exception is thrown.
 Examples :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
AttributeProxy *my_attr = new AttributeProxy("my/own/device/attr");
\end_layout

\begin_layout Verbatim
AttributeProxy *my_attr_bis = new AttributeProxy("attr_alias");
\end_layout

\begin_layout Verbatim
AttributeProxy *my_attr_ter = new AttributeProxy("dev_alias/attr");
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
See appendix on device/attribute naming for all details about Tango device
 or attribute naming syntax.
 
\end_layout

\begin_layout Standard

\emph on
Exception: WrongNameSyntax, ConnectionFailed
\end_layout

\begin_layout Subsubsection
AttributeProxy::AttributeProxy(const char *name)
\end_layout

\begin_layout Standard
Idem previous call
\end_layout

\begin_layout Subsection
Miscellaneous methods
\end_layout

\begin_layout Subsubsection
DevState AttributeProxy::state()
\end_layout

\begin_layout Standard
A method which returns the state of the device to which the attribute belongs
 to.
 This state is returned as a Tango::DevState type.
 Example :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
dev_state = my_attr->state() << endl;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed
\end_layout

\begin_layout Subsubsection
string AttributeProxy::status()
\end_layout

\begin_layout Standard
A method which return the status of the device to which the attribute belongs
 to.
 The status is returned as a string.
 Example :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
cout << "device status" << my_attr->status() << endl;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed
\end_layout

\begin_layout Subsubsection
int AttributeProxy::ping()
\end_layout

\begin_layout Standard
A method which sends a ping to the device to which the attribute belongs
 and returns the time elapsed in microseconds.
 Example :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
cout << "device ping took " << my_device->ping() << 
\begin_inset Quotes eld
\end_inset

 microseconds
\begin_inset Quotes erd
\end_inset

 << endl;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed
\end_layout

\begin_layout Subsubsection
string AttributeProxy::name()
\end_layout

\begin_layout Standard
Returns the attribute name
\end_layout

\begin_layout Subsubsection
DeviceProxy *get_device_proxy()
\end_layout

\begin_layout Standard
Returns the DeviceProxy instance used to communicate with the device to
 which the attributes belongs.
\end_layout

\begin_layout Verbatim
\noindent

\end_layout

\begin_layout Subsection
Synchronous related methods
\end_layout

\begin_layout Subsubsection
AttributeInfo AttributeProxy::get_config()
\end_layout

\begin_layout Standard
Return the attribute configuration.
 AttributeInfo is a struct defined as follows :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
typedef struct _AttributeInfo { 
\end_layout

\begin_layout Verbatim
   string name; 
\end_layout

\begin_layout Verbatim
   AttrWriteType writable; 
\end_layout

\begin_layout Verbatim
   AttrDataFormat data_format; 
\end_layout

\begin_layout Verbatim
   int data_type; 
\end_layout

\begin_layout Verbatim
   int max_dim_x; 
\end_layout

\begin_layout Verbatim
   int max_dim_y; 
\end_layout

\begin_layout Verbatim
   string description; 
\end_layout

\begin_layout Verbatim
   string label; 
\end_layout

\begin_layout Verbatim
   string unit; 
\end_layout

\begin_layout Verbatim
   string standard_unit; 
\end_layout

\begin_layout Verbatim
   string display_unit; 
\end_layout

\begin_layout Verbatim
   string format; 
\end_layout

\begin_layout Verbatim
   string min_value; 
\end_layout

\begin_layout Verbatim
   string max_value; 
\end_layout

\begin_layout Verbatim
   string min_alarm; 
\end_layout

\begin_layout Verbatim
   string max_alarm; 
\end_layout

\begin_layout Verbatim
   string writable_attr_name; 
\end_layout

\begin_layout Verbatim
   vector<string> extensions; 
\end_layout

\begin_layout Verbatim
   Tango::DispLevel disp_level;
\end_layout

\begin_layout Verbatim
} AttributeInfo; 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
void AttributeProxy::set_config(AttributeInfo &)
\end_layout

\begin_layout Standard
Change the attribute configuration.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked, DevFailed
 from device
\end_layout

\begin_layout Subsubsection
DeviceAttribute AttributeProxy::read()
\end_layout

\begin_layout Standard
Read the attribute.
 To extract the value you have to use the operator of the class DeviceAttribute
 which corresponds to the data type of the attribute.
 NOTE: There is no automatic type conversion from the attribute native type
 to user type e.g.
 if an attribute returns a short you cannot extract it as a double (this
 will return 0) you have to extract it as a short.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
void AttributeProxy::write(DeviceAttribute&)
\end_layout

\begin_layout Standard
Write the attribute.
 To insert the value to write you have to use the operator of the class
 DeviceAttribute which corresponds to the data type of the attribute.
 NOTE: There is no automatic type conversion from the user type to the attribute
 native type e.g.
 if an attribute expects a short you cannot insert it as a double (this
 will throw an exception) you have to insert it as a short.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked, DevFailed
 from device
\end_layout

\begin_layout Subsubsection
DeviceAttribute AttributeProxy::write_read(DeviceAttribute&)
\end_layout

\begin_layout Standard
Write then read a single attribute in a single network call.
 By default (serialisation by device), the execution of this call in the
 server can't be interrupted by other clients.
 To insert/extract the value to write/read you have to use the operator
 of the class DeviceAttribute which corresponds to the data type of the
 attribute.
 NOTE: There is no automatic type conversion from the user type to the attribute
 native type e.g.
 if an attribute expects a short you cannot insert it as a double (this
 will throw an exception) you have to insert it as a short.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DeviceUnlocked, DevFailed
 from device
\end_layout

\begin_layout Subsubsection
vector<DeviceAttributeHistory> *AttributeProxy::history(int)
\end_layout

\begin_layout Standard
Retrieve attribute history from the attribute polling buffer.
 The argument is the wanted history depth.
 This method returns a vector of DeviceAttributeHistory types.
 This method allocates memory for the vector of DeviceAttributeHistory returned
 to the caller.
 It is the caller responsibility to delete this memory.
 Class DeviceAttributeHistory is detailed on chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "AttributeHistory"

\end_inset

See chapter on Advanced Feature for all details regarding polling.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
AttributeProxy attr = new AttributeProxy("my/own/device/Current"); 
\end_layout

\begin_layout Verbatim
vector<DeviceAttributeHistory> *hist;
\end_layout

\begin_layout Verbatim
hist = attr->history(5);
\end_layout

\begin_layout Verbatim
\noindent
for (int i = 0;i < 5;i++) 
\end_layout

\begin_layout Verbatim
\noindent
{
\end_layout

\begin_layout Verbatim
\noindent

\end_layout

\begin_layout Verbatim
    bool fail = (*hist)[i].has_failed();
\end_layout

\begin_layout Verbatim
    if (fail == false)
\end_layout

\begin_layout Verbatim
    {
\end_layout

\begin_layout Verbatim
        cout << "Attribute name = " << (*hist)[i].get_name() << endl;
\end_layout

\begin_layout Verbatim
        cout << "Attribute quality factor = " << (*hist)[i].get_quality()
 << endl;
\end_layout

\begin_layout Verbatim
        long value;
\end_layout

\begin_layout Verbatim
        (*hist)[i] >> value;
\end_layout

\begin_layout Verbatim
        cout << "Current = " << value << endl;
\end_layout

\begin_layout Verbatim
    }
\end_layout

\begin_layout Verbatim
    else
\end_layout

\begin_layout Verbatim
    {
\end_layout

\begin_layout Verbatim
        cout << "Attribute failed !" << endl;
\end_layout

\begin_layout Verbatim
        cout << "Error level 0 desc = " << ((*hist)[i].get_err_stack())[0].desc
 << endl;
\end_layout

\begin_layout Verbatim
    }
\end_layout

\begin_layout Verbatim
    cout << "Date = " << (*hist)[i].get_date().tv_sec << endl;
\end_layout

\begin_layout Verbatim
\noindent
}
\end_layout

\begin_layout Verbatim
delete hist;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
NonSupportedFeature, ConnectionFailed, CommunicationFailed, DevFailed from
 device
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Subsection
Asynchronous methods
\end_layout

\begin_layout Subsubsection
long AttributeProxy::read_asynch()
\end_layout

\begin_layout Standard
Read the attribute asynchronously (polling model).
 This call returns an 
\emph on
asynchronous call identifier
\emph default
 which is needed to get the attribute value.
\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed
\end_layout

\begin_layout Subsubsection
DeviceAttribute *AttributeProxy::read_reply(long id)
\end_layout

\begin_layout Standard
Check if the answer of an asynchronous read is arrived (polling model).
 id is the asynchronous call identifier.
 If the reply is arrived and if it is a valid reply, it is returned to the
 caller in a DeviceAttribute object.
 If the reply is an exception, it is re-thrown by this call.
 An exception is also thrown in case of the reply is not yet arrived.
 To extract attribute value, you have to use the operator of the class DeviceAtt
ribute which corresponds to the data type of the attribute.
 NOTE: There is no automatic type conversion from the attribute native type
 to user type e.g.
 if an attribute returns a short you cannot extract it as a double, you
 have to extract it as a short.
 Memory has been allocated for the DeviceAttribute object returned to the
 caller.
 This is the caller responsibility to delete this memory.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
AsynCall, AsynReplyNotArrived, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
DeviceAttribute *AttributeProxy::read_reply(long id, long timeout)
\end_layout

\begin_layout Standard
Check if the answer of an asynchronous read is arrived (polling model).
 id is the asynchronous call identifier.
 If the reply is arrived and if it is a valid reply, it is returned to the
 caller in a DeviceAttribute object.
 If the reply is an exception, it is re-thrown by this call.
 If the reply is not yet arrived, the call will wait (blocking the process)
 for the time specified in timeout.
 If after timeout milliseconds, the reply is still not there, an exception
 is thrown.
 If timeout is set to 0, the call waits until the reply arrived.
 To extract attribute value, you have to use the operator of the class DeviceAtt
ribute which corresponds to the data type of the attribute.
 NOTE: There is no automatic type conversion from the attribute native type
 to user type e.g.
 if an attribute returns a short you cannot extract it as a double, you
 have to extract it as a short.
 Memory has been allocated for the DeviceAttribute object returned to the
 caller.
 This is the caller responsibility to delete this memory.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
AsynCall, AsynReplyNotArrived, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
long AttributeProxy::write_asynch(DeviceAttribute &argin)
\end_layout

\begin_layout Standard
Write the attribute asynchronously (polling model).
 To insert the value to write you have to use the operator of the class
 DeviceAttribute which corresponds to the data type of the attribute.
 NOTE: There is no automatic type conversion from the user type to the attribute
 native type e.g.
 if an attribute expects a short you cannot insert it as a double (this
 will throw an exception) you have to insert it as a short.
 This call returns an 
\emph on
asynchronous call identifier
\emph default
 which is needed to get the server reply.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
ConnectionFailed
\end_layout

\begin_layout Subsubsection
void AttributeProxy::write_reply(long id)
\end_layout

\begin_layout Standard
Check if the answer of an asynchronous write is arrived (polling model).
 id is the asynchronous call identifier.
 If the reply is arrived and if it is a valid reply, the call returned.
 If the reply is an exception, it is re-thrown by this call.
 An exception is also thrown in case of the reply is not yet arrived.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
AsynCall, AsynReplyNotArrived, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
void AttributeProxy::write_reply(long id, long timeout)
\end_layout

\begin_layout Standard
Check if the answer of an asynchronous write is arrived (polling model).
 id is the asynchronous call identifier.
 If the reply is arrived and if it is a valid reply, the call returned.
 If the reply is an exception, it is re-thrown by this call.
 If the reply is not yet arrived, the call will wait (blocking the process)
 for the time specified in timeout.
 If after timeout milliseconds, the reply is still not there, an exception
 is thrown.
 If timeout is set to 0, the call waits until the reply arrived.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
AsynCall, AsynReplyNotArrived, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsubsection
void AttributeProxy::read_asynch(CallBack &cb)
\end_layout

\begin_layout Standard
Read the attribute asynchronously using the callback model.
 The argument is a reference to a callback object.
 This callback object should be an instance of a user class inheriting from
 the 
\emph on
Tango::CallBack
\emph default
 class with the 
\emph on
attr_read()
\emph default
 method overloaded.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
ConnectionFailed
\end_layout

\begin_layout Subsubsection
void AttributeProxy::write_asynch(DeviceAttribute &argin, CallBack &cb)
\end_layout

\begin_layout Standard
Write the attribute asynchronously using the callback model.
 The argument is a reference to a callback object.
 This callback object should be an instance of a user class inheriting from
 the 
\emph on
Tango::CallBack
\emph default
 class with the 
\emph on
attr_written()
\emph default
 method overloaded.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
ConnectionFailed
\end_layout

\begin_layout Subsection
Polling related methods
\end_layout

\begin_layout Subsubsection
bool AttributeProxy::is_polled()
\end_layout

\begin_layout Standard
Returns true if the attribute is polled.
 Otherwise, returns false.
\end_layout

\begin_layout Subsubsection
int AttributeProxy::get_poll_period()
\end_layout

\begin_layout Standard
Returns the attribute polling period in mS.
 If the attribute is not polled, it returns 0.
\end_layout

\begin_layout Subsubsection
void AttributeProxy::poll(int period)
\end_layout

\begin_layout Standard
Add the attribute to the list of polled attributes.
 The polling period is specified by "period" (in mS).
 If the attribute is already polled, this method will update the polling
 period according to "period".
\end_layout

\begin_layout Subsubsection
void AttributeProxy::stop_poll()
\end_layout

\begin_layout Standard
Remove attribute from the list of polled attributes.
\end_layout

\begin_layout Subsection
Event related methods
\end_layout

\begin_layout Subsubsection
int AttributeProxy::subscribe_event(EventType event, CallBack *cb)
\end_layout

\begin_layout Standard
The client call to subscribe for event reception in the 
\series bold
push model
\series default
.
 The client implements a callback method which is triggered when the event
 is received either by polling or a dedicated thread.
 Filtering is done based on the reason specified and the event type.
 For example when reading the state and the reason specified is "change"
 the event will be fired only when the state changes.
 Events consist of an attribute name and the event reason.
 A standard set of reasons are implemented by the system, additional device
 specific reasons can be implemented by device servers programmers.
\end_layout

\begin_layout Standard
The 
\emph on
event
\emph default
 parameter is the event reason and must be on the enumerated values:
\end_layout

\begin_layout Itemize
Tango::CHANGE_EVENT
\end_layout

\begin_layout Itemize
Tango::PERIODIC_EVENT
\end_layout

\begin_layout Itemize
Tango::ARCHIVE_EVENT
\end_layout

\begin_layout Itemize
Tango::ATTR_CONF_EVENT
\end_layout

\begin_layout Standard

\emph on
cb
\emph default
 is a pointer to a class inheriting from the Tango CallBack class and implementi
ng a 
\emph on
push_event()
\emph default
 method, 
\emph on
filters
\emph default
 is a variable list of name,value pairs which define additional filters
 for events.
 The 
\emph on
subscribe_event()
\emph default
 call returns an event id which has to be specified when unsubscribing from
 this event.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
EventSystemFailed
\end_layout

\begin_layout Standard
Note: For releases prior to Tango 8, a similar call with a third argument
 (const vector<string> &filters) was available.
 This extra argument gave the user a way to define extra event filtering.
 For compatibility reason, this call still exist but the extra filtering
 features is not implemented.
\end_layout

\begin_layout Subsubsection
int AttributeProxy::subscribe_event(EventType event, CallBack *cb, bool
 stateless)
\end_layout

\begin_layout Standard
This subscribe event method has the same functionality as described in the
 last section.
 It adds an additional flag called 
\emph on
stateless
\emph default
.
 When the 
\emph on
stateless
\emph default
 flag is set to 
\emph on
false
\emph default
, an exception will be thrown when the event subscription encounters a problem.
 
\end_layout

\begin_layout Standard
With the 
\emph on
stateless
\emph default
 flag set to 
\emph on
true
\emph default
, the event subscription will always succeed, even if the corresponding
 device server is not running.
 The keep alive thread will try every 10 seconds to subscribe for the specified
 event.
 At every subscription retry, a callback is executed which contains the
 corresponding exception.
\end_layout

\begin_layout Standard

\emph on
Exception: EventSystemFailed
\end_layout

\begin_layout Standard
Note: For releases prior to Tango 8, a similar call with a forth argument
 (const vector<string> &filters) was available.
 This extra argument gave the user a way to define extra event filtering
 and it was the third argument in the argument list.
 For compatibility reason, this call still exist but the extra filtering
 features is not implemented.
\end_layout

\begin_layout Subsubsection
int AttributeProxy::subscribe_event(EventType event, int event_queue_size,
 bool stateless)
\end_layout

\begin_layout Standard
The client call to subscribe for event reception in the 
\series bold
pull model
\series default
.
 Instead of a callback method the client has to specify the size of the
 event reception buffer.
\end_layout

\begin_layout Standard
The event reception buffer is implemented as a round robin buffer.
 This way the client can set-up different ways to receive events.
\end_layout

\begin_layout Standard
Event reception buffer size = 1 : The client is interested only in the value
 of the last event received.
 All other events that have been received since the last reading are discarded.
\end_layout

\begin_layout Standard
Event reception buffer size > 1 : The client has chosen to keep an event
 history of a given size.
 When more events arrive since the last reading, older events will be discarded.
\end_layout

\begin_layout Standard
Event reception buffer size = ALL_EVENTS : The client buffers all received
 events.
 The buffer size is unlimited and only restricted by the available memory
 for the client.
\end_layout

\begin_layout Standard
All other parameters are similar to the descriptions given in the last two
 sections.
\end_layout

\begin_layout Standard

\emph on
Exception: EventSystemFailed
\end_layout

\begin_layout Standard
Note: For releases prior to Tango 8, a similar call with a forth argument
 (const vector<string> &filters) was available.
 This extra argument gave the user a way to define extra event filtering
 and it was the third argument in the argument list.
 For compatibility reason, this call still exist but the extra filtering
 features is not implemented.
\end_layout

\begin_layout Subsubsection
void AttributeProxy::unsubscribe_event(int event_id)
\end_layout

\begin_layout Standard
Unsubscribe a client from receiving the event specified by 
\emph on
event_id
\emph default
.
 
\emph on
event_id
\emph default
 is the event identifier returned by the 
\emph on
AttributeProxy::subscribe_event()
\emph default
 method.
\end_layout

\begin_layout Standard

\emph on
Exception:
\emph default
 
\emph on
EventSystemFailed
\end_layout

\begin_layout Subsubsection
void AttributeProxy::get_events(int event_id, CallBack *cb)
\end_layout

\begin_layout Standard
The method extracts all waiting events from the event reception buffer and
 executes the callback method cb for every event.
 During event subscription the client must have chosen the pull model for
 this event.
 event_id is the event identifier returned by the AttributeProxy::subscribe_even
t() method.
\end_layout

\begin_layout Standard

\emph on
Exception: EventSystemFailed
\end_layout

\begin_layout Subsubsection
void AttributeProxy::get_events(int event_id, EventDataList &event_list)
\end_layout

\begin_layout Standard
The method extracts all waiting events from the event reception buffer.
 The returned event_list is a vector of EventData pointers.
 The EventData object contains the event information as for the callback
 methods.
 
\end_layout

\begin_layout Standard
During event subscription the client must have chosen the pull model for
 this event.
 event_id is the event identifier returned by the AttributeProxy::subscribe_even
t() method.
\end_layout

\begin_layout Standard

\emph on
Exception: EventSystemFailed
\end_layout

\begin_layout Subsubsection
void AttributeProxy::get_events(int event_id, AttrConfEventDataList &event_list)
\end_layout

\begin_layout Standard
The method extracts all waiting attribute configuration events from the
 event reception buffer.
 The returned event_list is a vector of AttrConfEventData pointers.
 The AttrConfEventData object contains the event information as for the
 callback methods.
 
\end_layout

\begin_layout Standard
During event subscription the client must have chosen the pull model for
 this event.
 event_id is the event identifier returned by the AttributeProxy::subscribe_even
t() method.
\end_layout

\begin_layout Standard

\emph on
Exception: EventSystemFailed
\end_layout

\begin_layout Subsubsection
int AttributeProxy::event_queue_size(int event_id)
\end_layout

\begin_layout Standard
Returns the number of stored events in the event reception buffer.
 After every call to DeviceProxy:get_events(), the event queue size is 0.
\end_layout

\begin_layout Standard
During event subscription the client must have chosen the pull model for
 this event.
 event_id is the event identifier returned by the AttributeProxy::subscribe_even
t() method.
\end_layout

\begin_layout Standard

\emph on
Exception: EventSystemFailed
\end_layout

\begin_layout Subsubsection
TimeVal AttributeProxy::get_last_event_date(int event_id)
\end_layout

\begin_layout Standard
Returns the arrival time of the last event stored in the event reception
 buffer.
 After every call to DeviceProxy:get_events(), the event reception buffer
 is empty.
 In this case an exception will be returned.
\end_layout

\begin_layout Standard
During event subscription the client must have chosen the pull model for
 this event.
 event_id is the event identifier returned by the AttributeProxy::subscribe_even
t() method.
\end_layout

\begin_layout Standard

\emph on
Exception: EventSystemFailed
\end_layout

\begin_layout Subsubsection
bool AttributeProxy::is_event_queue_empty(int event_id)
\end_layout

\begin_layout Standard
Returns true when the event reception buffer is empty.
\end_layout

\begin_layout Standard
During event subscription the client must have chosen the pull model for
 this event.
 event_id is the event identifier returned by the AttributeProxy::subscribe_even
t() method.
\end_layout

\begin_layout Standard

\emph on
Exception: EventSystemFailed
\end_layout

\begin_layout Subsection
Property related methods
\end_layout

\begin_layout Subsubsection
void AttributeProxy::get_property (string&, DbData&)
\end_layout

\begin_layout Standard
Get a single property for the attribute.
 The property to get is specified as a string.
 Refer to DbDevice::get_property() and DbData sections below for details
 on the DbData type.
\end_layout

\begin_layout Standard

\emph on
Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
 (with database), DevFailed from database device
\end_layout

\begin_layout Subsubsection
void AttributeProxy::get_property (vector<string>&, DbData&)
\end_layout

\begin_layout Standard
Get a list of properties for the attribute.
 The properties to get are specified as a vector of strings.
 Refer to DbDevice::get_property() and DbData sections below for details
 on the DbData type.
\end_layout

\begin_layout Standard

\emph on
Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
 (with database), DevFailed from database device
\end_layout

\begin_layout Subsubsection
void AttributeProxy::get_property(DbData&)
\end_layout

\begin_layout Standard
Get property(ies) for the attribute.
 Properties to get are specified using the DbData type.
 Refer to DbDevice::get_property() and DbData sections below for details.
\end_layout

\begin_layout Standard

\emph on
Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
 (with database), DevFailed from database device
\end_layout

\begin_layout Subsubsection
void AttributeProxy::put_property(DbData&)
\end_layout

\begin_layout Standard
Put property(ies) for an attribute.
 Properties to put are specified using the DbData type.
 Refer to DbDevice::put_property() and DbData sections below for details.
\end_layout

\begin_layout Standard

\emph on
Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
 (with database), DevFailed from database device
\end_layout

\begin_layout Subsubsection
void AttributeProxy::delete_property (string&, DbData&)
\end_layout

\begin_layout Standard
Delete a single property for an attribute.
 The property to delete is specified as a string.
 Refer to DbDevice::delete_property() and DbData sections below for details
 on the DbData type.
\end_layout

\begin_layout Standard

\emph on
Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
 (with database), DevFailed from database device
\end_layout

\begin_layout Subsubsection
void AttributeProxy::delete_property (vector<string>&, DbData&)
\end_layout

\begin_layout Standard
Delete a list of properties for an attribute.
 The properties to delete are specified as a vector of strings.
 Refer to DbDevice::get_property() and DbData sections below for details
 on the DbData type.
\end_layout

\begin_layout Standard

\emph on
Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
 (with database), DevFailed from database device
\end_layout

\begin_layout Subsubsection
void AttributeProxy::delete_property(DbData&)
\end_layout

\begin_layout Standard
Delete property(ies) for an attribute.
 Properties to delete are specified using the DbData type.
 Refer to DbDevice::get_property() and DbData sections below for details.
\end_layout

\begin_layout Standard

\emph on
Exception: NonDbDevice, ConnectionFailed (with database), CommunicationFailed
 (with database), DevFailed from database device
\end_layout

\begin_layout Section
Tango::ApiUtil
\begin_inset CommandInset label
LatexCommand label
name "sec:Tango::ApiUtil"

\end_inset


\end_layout

\begin_layout Standard
This class is a singleton.
 Therefore, it is not necessary to create it.
 It will be automatically done.
 A static method allows a user to retrieve the instance
\end_layout

\begin_layout Subsection
static ApiUtil *ApiUtil::instance()
\end_layout

\begin_layout Standard
Return the ApiUtil singleton instance.
\end_layout

\begin_layout Subsection
static void ApiUtil::cleanup()
\end_layout

\begin_layout Standard
Destroy the ApiUtil singleton instance.
\end_layout

\begin_layout Subsection
long ApiUtil::pending_asynch_call(asyn_req_type req)
\end_layout

\begin_layout Standard
Return number of asynchronous pending requests (any device).
 The input parameter is an enumeration with three values which are:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
POLLING : Return only polling model asynchronous request number
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
CALL_BACK : Return only callback model asynchronous request number
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
ALL_ASYNCH : Return all asynchronous request number
\end_layout

\begin_layout Standard

\emph on
Exception: None
\end_layout

\begin_layout Subsection
void ApiUtil::get_asynch_replies()
\end_layout

\begin_layout Standard
Fire callback methods for all (any device) asynchronous requests (command
 and attribute) with already arrived replied.
 Returns immediately if there is no replies already arrived or if there
 is no asynchronous requests.
\end_layout

\begin_layout Standard

\emph on
Exception: None, all errors are reported using the err and errors fields
 of the parameter passed to the callback method.
 See chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Asynchronous-callback-related"

\end_inset

 for details.
\end_layout

\begin_layout Subsection
void ApiUtil::get_asynch_replies(long timeout)
\end_layout

\begin_layout Standard
Fire callback methods for all (any device) asynchronous requests (command
 and attributes) with already arrived replied.
 Wait and block the caller for timeout milliseconds if they are some device
 asynchronous requests which are not yet arrived.
 Returns immediately if there is no asynchronous request.
 If timeout is set to 0, the call waits until all the asynchronous requests
 sent has received a reply.
\end_layout

\begin_layout Standard

\emph on
Exception: AsynReplyNotArrived.
 All other errors are reported using the err and errors fields of the object
 passed to the callback methods.
 See chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Asynchronous-callback-related"

\end_inset

 for details.
\end_layout

\begin_layout Subsection
void ApiUtil::set_asynch_cb_sub_model(cb_sub_model model)
\end_layout

\begin_layout Standard
Set the asynchronous callback sub-model between the pull and push sub-model.
 See chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Request-model"

\end_inset

 to read the definition of these sub-model.
 The cb_sub_model data type is an enumeration with two values which are
 :
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
PUSH_CALLBACK : The push sub-model
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
PULL_CALLBACK : The pull sub-model
\end_layout

\begin_layout Standard
By default, all Tango client using asynchronous callback model are in pull
 sub-model.
 This call must be used to switch to the push sub-model.
 NOTE that in push sub-model, a separate thread is spawned to deal with
 server replies.
\end_layout

\begin_layout Standard

\emph on
Exception: None
\end_layout

\begin_layout Subsection
cb_sub_model ApiUtil::get_asynch_cb_sub_model()
\end_layout

\begin_layout Standard
Get the asynchronous callback sub-model.
\end_layout

\begin_layout Standard

\emph on
Exception: None
\end_layout

\begin_layout Subsection
static int ApiUtil::get_env_var(const char *name,string &value)
\end_layout

\begin_layout Standard
Get environment variable.
 On Unixes OS, this call tries to get the variable in the caller environment
 then in a file 
\emph on
.tangorc
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
tangorc
\end_layout

\end_inset


\emph default
 in the user home directory and finally in a file 
\emph on
/etc/tangorc
\emph default
.
 On Windows, this call looks in the user environment then in a file stored
 in %TANGO_HOME%/tangorc.
 This method returns 0 of the environment variable is found.
 Otherwise, it returns -1.
\end_layout

\begin_layout Standard

\emph on
Exception: None
\end_layout

\begin_layout Subsection
void set_event_buffer_hwm(DevLong val)
\end_layout

\begin_layout Standard
Set the client event buffer high water mark (HWM
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
HWM
\end_layout

\end_inset

)
\end_layout

\begin_layout Section
Asynchronous callback related classes
\begin_inset CommandInset label
LatexCommand label
name "sec:Asynchronous-callback-related"

\end_inset


\end_layout

\begin_layout Subsection
Tango::CallBack
\end_layout

\begin_layout Standard
When using the event push model (callback automatically executed), there
 are some cases (same callback used for events coming from different devices
 hosted in device server process running on different hosts) where the callback
 method could be executed concurently by different threads started by the
 ORB.
 The user has to code his callback method in a 
\series bold
thread
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
thread
\end_layout

\end_inset

 
\series bold
safe
\series default
 manner.
\end_layout

\begin_layout Subsubsection
void CallBack::cmd_ended(CmdDoneEvent *event)
\end_layout

\begin_layout Standard
This method is defined as being empty and must be overloaded by the user
 when the asynchronous callback model is used.
 This is the method which will be executed when the server reply from a
 command_inout is received in both push and pull sub-mode.
\end_layout

\begin_layout Subsubsection
void CallBack::attr_read(AttrReadEvent *event)
\end_layout

\begin_layout Standard
This method is defined as being empty and must be overloaded by the user
 when the asynchronous callback model is used.
 This is the method which will be executed when the server reply from a
 read_attribute(s) is received in both push and pull sub-mode.
\end_layout

\begin_layout Subsubsection
void CallBack::attr_written(AttrWrittenEvent *event)
\end_layout

\begin_layout Standard
This method is defined as being empty and must be overloaded by the user
 when the asynchronous callback model is used.
 This is the method which will be executed when the server reply from a
 write_attribute(s) is received in both push and pull sub-mode.
\end_layout

\begin_layout Subsubsection
void CallBack::push_event(EventData *event)
\end_layout

\begin_layout Standard
This method is defined as being empty and must be overloaded by the user
 when events are used.
 This is the method which will be executed when the server send event(s)
 to the client.
\end_layout

\begin_layout Subsubsection
void CallBack::push_event(AttrConfEventData *event)
\end_layout

\begin_layout Standard
This method is defined as being empty and must be overloaded by the user
 when events are used.
 This is the method which will be executed when the server send attribute
 configuration change event(s) to the client.
\end_layout

\begin_layout Subsubsection
void CallBack::push_event(DataReadyEventData *event)
\end_layout

\begin_layout Standard
This method is defined as being empty and must be overloaded by the user
 when events are used.
 This is the method which will be executed when the server send attribute
 data ready event(s) to the client.
\end_layout

\begin_layout Subsection
Tango::CmdDoneEvent
\end_layout

\begin_layout Standard
This class is used to pass data to the callback method in asynchronous callback
 model for command execution.
 It contains the following public field
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
device : The DeviceProxy object on which the call was executed (Tango::DevicePro
xy *)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
cmd_name : The command name (string &)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
argout : The command argout (DeviceData &)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
err : A boolean flag set to true if the command failed.
 False otherwise (bool)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
errors : The error stack (DevErrorList &)
\end_layout

\begin_layout Subsection
Tango::AttrReadEvent
\end_layout

\begin_layout Standard
This class is used to pass data to the callback method in asynchronous callback
 model for read_attribute(s) execution.
 It contains the following public field
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
device : The DeviceProxy object on which the call was executed (Tango::DevicePro
xy *)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
attr_names : The attribute name list (vector<string> &)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
argout : The attribute data (vector<DeviceAttribute> *)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
err : A boolean flag set to true if the request failed.
 False otherwise (bool)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
errors : The error stack (DevErrorList &)
\end_layout

\begin_layout Standard
To extract attribute value(s), you have to use the operator of the class
 DeviceAttribute which corresponds to the data type of the attribute.
 NOTE: There is no automatic type conversion from the attribute native type
 to user type e.g.
 if an attribute returns a short you cannot extract it as a double, you
 have to extract it as a short.
 Memory has been allocated for the vector of DeviceAttribute objects passed
 to the caller.
 This is the caller responsibility to delete this memory.
\end_layout

\begin_layout Subsection
Tango::AttrWrittenEvent
\end_layout

\begin_layout Standard
This class is used to pass data to the callback method in asynchronous callback
 model for write_attribute(s) execution.
 It contains the following public field
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
device : The DeviceProxy object on which the call was executed (Tango::DevicePro
xy *)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
attr_names : The attribute name list (vector<string> &)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
err : A boolean flag set to true if the request failed.
 False otherwise (bool)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
errors : The error stack (DevErrorList &)
\end_layout

\begin_layout Subsection
Tango::EventData
\end_layout

\begin_layout Standard
This class is used to pass data to the callback method when an event is
 sent to the client.
 It contains the following public field
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
device : The DeviceProxy object on which the call was executed (Tango::DevicePro
xy *)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
attr_name : The attribute name (std::string &)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
event : The event name (std::string &)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
attr_value : The attribute data (DeviceAttribute *)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
err : A boolean flag set to true if the request failed.
 False otherwise (bool)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
errors : The error stack (DevErrorList &)
\end_layout

\begin_layout Standard
To extract attribute value(s), you have to use the operator of the class
 DeviceAttribute which corresponds to the data type of the attribute.
 NOTE: There is no automatic type conversion from the attribute native type
 to user type e.g.
 if an attribute returns a short you cannot extract it as a double, you
 have to extract it as a short.
 Memory has been allocated for the vector of DeviceAttribute objects passed
 to the caller.
 This is the caller responsibility to delete this memory.
\end_layout

\begin_layout Subsection
Tango::AttrConfEventData
\end_layout

\begin_layout Standard
This class is used to pass data to the callback method when an attribute
 configuration event is sent to the client.
 It contains the following public field
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
device : The DeviceProxy object on which the call was executed (Tango::DevicePro
xy *)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
attr_name : The attribute name (std::string &)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
event : The event name (std::string &)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
attr_conf : The attribute configuration (AttributeInfoEx *)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
err : A boolean flag set to true if the request failed.
 False otherwise (bool)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
errors : The error stack (DevErrorList &)
\end_layout

\begin_layout Subsection
Tango::DataReadyEventData
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
DataReadyEventData
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This class is used to pass data to the callback method when an attribute
 data ready event is sent to the client.
 It contains the following public field
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
device : The DeviceProxy object on which the call was executed (Tango::DevicePro
xy *)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
attr_name : The attribute name (std::string &)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
event : The event name (std::string &)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
attr_data_type :The attribute data type (int)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
ctr : The user counter.
 Set to 0 if not defined when sent by the server (int)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
err : A boolean flag set to true if the request failed.
 False otherwise (bool)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
errors : The error stack (DevErrorList &)
\end_layout

\begin_layout Section
Tango::Group
\end_layout

\begin_layout Subsection
Constructor and Destructor
\end_layout

\begin_layout Subsubsection
Group::Group (const std::string& name)
\end_layout

\begin_layout Standard
Instanciate an empty group.
 The group name allows retrieving a sub-group in the hierarchy.
 
\end_layout

\begin_layout Standard
See also: Group::~Group(), Group::get_group().
 
\end_layout

\begin_layout Subsubsection
Group::~Group ()
\end_layout

\begin_layout Standard
Delete a group and all its elements.
 
\end_layout

\begin_layout Standard
Be aware that a group always gets the ownership of its children and deletes
 them when it is itself deleted.
 Therefore, never try to delete a Group (respectively a DeviceProxy) returned
 by a call to 
\emph on
Tango::Group::get_group()
\emph default
 (respectively to 
\emph on
Tango::Group::get_device()
\emph default
).
 Use the 
\emph on
Tango::Group::remove()
\emph default
 method instead.
\end_layout

\begin_layout Standard
See also: Group::Group(), Group::remove(), Group::remove_all().
 
\end_layout

\begin_layout Subsection
Group Management Related Methods
\end_layout

\begin_layout Subsubsection
void Group::add (Group* group, int timeout_ms = -1)
\end_layout

\begin_layout Standard
Attaches a (sub)group.
 
\end_layout

\begin_layout Standard
Be aware that a group always gets the ownership of its children and deletes
 them when it is itself deleted.
 Therefore, never try to delete a Group attached to a Group.
 Use the 
\emph on
Group::remove()
\emph default
 method instead.
\end_layout

\begin_layout Standard
If 
\emph on
timeout_ms
\emph default
 parameter is different from -1, the client side timeout associated to each
 device composing the group added is set to 
\emph on
timeout_ms
\emph default
 milliseconds.
 If 
\emph on
timeout_ms
\emph default
 is -1, timeouts are not changed.
\end_layout

\begin_layout Standard
This method does nothing if the specified group is already attached (i.e.
 it is silently ignored) and 
\emph on
timeout_ms
\emph default
 = -1.
\end_layout

\begin_layout Standard
If the specified group is already attached and 
\emph on
timeout_ms
\emph default
 is different from -1, the client side timeout of each device composing
 the group given in parameter is set to 
\emph on
timeout_ms
\emph default
 milliseconds.
\end_layout

\begin_layout Standard
See also: all other forms of Group::add() and Group::set_timeout_millis().
\end_layout

\begin_layout Subsubsection
void Group::add (const std::string& pattern, int timeout_ms = -1)
\end_layout

\begin_layout Standard
Attaches any device which name matches the specified 
\emph on
pattern
\emph default
.
 
\end_layout

\begin_layout Standard
The pattern parameter can be a simple device name or a device name pattern
 (e.g.
 domain_*/ family/member_*).
\end_layout

\begin_layout Standard
This method first asks to the Tango database the list of device names matching
 the pattern.
 Devices are then attached to the group in the order in which they are returned
 by the database.
\end_layout

\begin_layout Standard
Any device already present in the hierarchy (i.e.
 a device belonging to the group or to one of its subgroups) is silently
 ignored but its client side timeout is set to 
\emph on
timeout_ms
\emph default
 milliseconds if 
\emph on
timeout_ms
\emph default
 is different from -1.
\end_layout

\begin_layout Standard
Set the client side timeout of each device matching the specified 
\emph on
pattern
\emph default
 to 
\emph on
timeout_ms
\emph default
 milliseconds if 
\emph on
timeout_ms
\emph default
 is different from -1.
\end_layout

\begin_layout Standard
See also: all other forms of Group::add() and Group::set_timeout_millis().
\end_layout

\begin_layout Subsubsection
void Group::add (const std::vector<std::string>& patterns, int timeout_ms
 = -1)
\end_layout

\begin_layout Standard
Attaches any device which name matches one of the specified patterns.
 
\end_layout

\begin_layout Standard
The 
\emph on
patterns
\emph default
 parameter can be an array of device names and/or device name patterns.
\end_layout

\begin_layout Standard
This method first asks to the Tango database the list of device names matching
 one the patterns.
 Devices are then attached to the group in the order in which they are returned
 by the database.
\end_layout

\begin_layout Standard
Any device already present in the hierarchy (i.e.
 a device belonging to the group or to one of its subgroups), is silently
 ignored but its client side timeout is set to 
\emph on
timeout_ms
\emph default
 milliseconds if 
\emph on
timeout_ms
\emph default
 is different from -1.
\end_layout

\begin_layout Standard
If 
\emph on
timeout_ms
\emph default
 is different from -1, the client side timeouts of all devices matching
 the specified 
\emph on
patterns
\emph default
 are set to 
\emph on
timeout_ms
\emph default
 milliseconds.
\end_layout

\begin_layout Standard
See also: all other forms of Group::add() and Group::set_timeout_millis().
\end_layout

\begin_layout Subsubsection
void Group::remove (const std::string& pattern, bool fwd = true)
\end_layout

\begin_layout Standard
Removes any group or device which name matches the specified pattern.
 
\end_layout

\begin_layout Standard
The 
\emph on
pattern
\emph default
 parameter can be a group name, a device name or a device name pattern (e.g
 domain_*/family/member_*).
 
\end_layout

\begin_layout Standard
Since we can have groups with the same name in the hierarchy, a group name
 can be fully qualified to specify which group should be removed.
 Considering the following group:
\end_layout

\begin_layout Verbatim
-> gauges 
\end_layout

\begin_layout Verbatim
   | -> cell-01 
\end_layout

\begin_layout Verbatim
   |     |-> penning 
\end_layout

\begin_layout Verbatim
   |     |    |-> ...
\end_layout

\begin_layout Verbatim
   |     |-> pirani
\end_layout

\begin_layout Verbatim
   |          |-> ...
\end_layout

\begin_layout Verbatim
   | -> cell-02
\end_layout

\begin_layout Verbatim
   |     |-> penning
\end_layout

\begin_layout Verbatim
   |     |    |-> ...
\end_layout

\begin_layout Verbatim
   |     |-> pirani
\end_layout

\begin_layout Verbatim
   |          |-> ...
\end_layout

\begin_layout Verbatim
   | -> cell-03
\end_layout

\begin_layout Verbatim
   |     |-> ...
 
\end_layout

\begin_layout Verbatim
   |     
\end_layout

\begin_layout Verbatim
   | -> ...
 
\end_layout

\begin_layout Standard
A call to gauges->remove("penning") will remove any group named "penning"
 in the hierarchy while gauges->remove("gauges.cell-02.penning") will only
 remove the specified group.
\end_layout

\begin_layout Standard
If 
\emph on
fwd
\emph default
 is set to true (the default), the remove request is also forwarded to subgroups.
 Otherwise, it is only applied to the local set of elements.
 For instance, the following code remove any stepper motor in the hierarchy:
\end_layout

\begin_layout Verbatim
root_group->remove("*/stepper_motor/*");
\end_layout

\begin_layout Standard
See also: all other forms of Group::remove().
 
\end_layout

\begin_layout Subsubsection
void Group::remove (const std::vector<std::string>& patterns, bool fwd =
 true)
\end_layout

\begin_layout Standard
Removes any group or device which name matches the specified patterns.
 
\end_layout

\begin_layout Standard
The 
\emph on
patterns
\emph default
 parameter can be an array of group names and/or device names and/or device
 name patterns.
\end_layout

\begin_layout Standard
Since we can have groups with the same name in the hierarchy, a group name
 can be fully qualified to specify which group should be removed.
 See previous method for details.
\end_layout

\begin_layout Standard
If 
\emph on
fwd
\emph default
 is set to true (the default), the remove request is also forwarded to subgroups.
 Otherwise, it is only applied to the local set of elements.
 
\end_layout

\begin_layout Standard
See also: all other forms of Group::remove().
 
\end_layout

\begin_layout Subsubsection
void Group::remove_all (void)
\end_layout

\begin_layout Standard
Removes all elements in the group.
 After such a call, the group is empty.
\end_layout

\begin_layout Standard
See also: all forms of Group::remove().
 
\end_layout

\begin_layout Subsubsection
bool Group::contains (const std::string& pattern, bool fwd = true)
\end_layout

\begin_layout Standard
Returns true if the hierarchy contains groups and/or devices which name
 matches the specified 
\emph on
pattern
\emph default
.
 Returns false otherwise.
 
\end_layout

\begin_layout Standard
The pattern can be a fully qualified or simple group name, a device name
 or a device name pattern.
\end_layout

\begin_layout Standard
If 
\emph on
fwd
\emph default
 is set to true (the default), the request is also forwarded to subgroups.
 Otherwise, it is only applied to the local set of elements.
 
\end_layout

\begin_layout Standard
See also: Group::get_device(), Group::get_group().
 
\end_layout

\begin_layout Subsubsection
DeviceProxy* Group::get_device (const std::string& device_name)
\end_layout

\begin_layout Standard
Returns a reference to the specified device or NULL if there is no device
 by that name in the group.
 This method may throw an exception in case the specified device belongs
 to the group but can't be reached (not registered, down...).
 See example below.
 See also the Tango::DeviceProxy class documentation for details.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
try
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
  Tango::DeviceProxy *dp = g->get_device("my/device/01");
\end_layout

\begin_layout Verbatim
  if (dp == 0)
\end_layout

\begin_layout Verbatim
  {
\end_layout

\begin_layout Verbatim
// my/device/01 doe snot belongs to the group
\end_layout

\begin_layout Verbatim
  {
\end_layout

\begin_layout Verbatim
}
\end_layout

\begin_layout Verbatim
catch (const Tango::DevFailed &df)
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
// my/device/01 belongs to the group but can't be reached
\end_layout

\begin_layout Verbatim
}
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
The request is systematically forwarded to subgroups (i.e.
 if no device named device_name could be found in the local set of devices,
 the request is forwarded to subgroups).
 
\end_layout

\begin_layout Standard
Be aware that a group always gets the ownership of its children and deletes
 them when it is itself deleted.
 Therefore, never try to delete a DeviceProxy returned by the 
\emph on
Group::get_device()
\emph default
 method.
 Use the 
\emph on
Tango::Group::remove()
\emph default
 method instead.
\end_layout

\begin_layout Standard
See also: other form of Group::get_device(), Group::get_size(), Group::get_group
(), Group::contains().
 
\end_layout

\begin_layout Subsubsection
DeviceProxy* Group::get_device (long idx)
\end_layout

\begin_layout Standard
Returns a reference to the "idx-th" device in the hierarchy or NULL if the
 hierarchy contains less than "
\emph on
idx
\emph default
" devices.
 This method may throw an exception in case the specified device belongs
 to the group but can't be reached (not registered, down...).
 See previous example.
 See also the Tango::DeviceProxy class documentation for details.
\end_layout

\begin_layout Standard
The request is systematically forwarded to subgroups (i.e.
 if the local set of devices contains less than "idx" devices, the request
 is forwarded to subgroups).
 
\end_layout

\begin_layout Standard
Be aware that a group always gets the ownership of its children and deletes
 them when it is itself deleted.
 Therefore, never try to delete a DeviceProxy returned by the 
\emph on
Group::get_device()
\emph default
 method.
 Use the 
\emph on
Tango::Group::remove()
\emph default
 method instead.
\end_layout

\begin_layout Standard
See also: other form of Group::get_device(), Group::get_size(), Group::get_group
, Group::contains().
 
\end_layout

\begin_layout Subsubsection
DeviceProxy* Group::operator[] (long i)
\end_layout

\begin_layout Standard
Returns a reference to the "idx-th" device in the hierarchy or NULL if the
 hierarchy contains less than "idx" devices.
 See the Tango::DeviceProxy class documentation for details.
\end_layout

\begin_layout Standard
The request is systematically forwarded to subgroups (i.e.
 if the local set of devices contains less than "idx" devices, the request
 is forwarded to subgroups).
\end_layout

\begin_layout Standard
Be aware that a group always gets the ownership of its children and deletes
 them when it is itself deleted.
 Therefore, never try to delete a DeviceProxy returned by the 
\emph on
Group::get_device()
\emph default
 method.
 Use the 
\emph on
Tango::Group::remove()
\emph default
 method instead.
\end_layout

\begin_layout Standard
See also: other form of Group::get_device(), Group::get_size(), Group::get_group
(), Group::contains().
 
\end_layout

\begin_layout Subsubsection
Group* Group::get_group (const std::string& group_name)
\end_layout

\begin_layout Standard
Returns a reference to the specified group or NULL if there is no group
 by that name.
 The group_name can be a fully qualified name.
 
\end_layout

\begin_layout Standard
Considering the following group:
\end_layout

\begin_layout Verbatim
-> gauges
\end_layout

\begin_layout Verbatim
    |-> cell-01
\end_layout

\begin_layout Verbatim
    |    |-> penning
\end_layout

\begin_layout Verbatim
    |    |    |-> ...
 
\end_layout

\begin_layout Verbatim
    |    |-> pirani
\end_layout

\begin_layout Verbatim
    |    |-> ...
 
\end_layout

\begin_layout Verbatim
    |-> cell-02
\end_layout

\begin_layout Verbatim
    |    |-> penning
\end_layout

\begin_layout Verbatim
    |    |    |-> ...
\end_layout

\begin_layout Verbatim
    |    |-> pirani
\end_layout

\begin_layout Verbatim
    |    |-> ...
\end_layout

\begin_layout Verbatim
    | -> cell-03
\end_layout

\begin_layout Verbatim
    |    |-> ...
\end_layout

\begin_layout Verbatim
    |
\end_layout

\begin_layout Verbatim
    | -> ...
 
\end_layout

\begin_layout Standard
A call to gauges->get_group("penning") returns the first group named "penning"
 in the hierarchy (i.e.
 gauges.cell-01.penning) while gauges->get_group("gauges.cell-02.penning
\begin_inset Quotes erd
\end_inset

) returns the specified group.
\end_layout

\begin_layout Standard
The request is systematically forwarded to subgroups (i.e.
 if no group named group_name could be found in the local set of elements,
 the request is forwarded to subgroups).
 
\end_layout

\begin_layout Standard
Be aware that a group always gets the ownership of its children and deletes
 them when it is itself deleted.
 Therefore, never try to delete a Group returned by the 
\emph on
Group::get_group()
\emph default
 method.
 Use the 
\emph on
Tango::Group::remove()
\emph default
 method instead.
\end_layout

\begin_layout Standard
See also: Group::get_device(), Group::contains().
 
\end_layout

\begin_layout Subsubsection
long Group::get_size (bool fwd = true)
\end_layout

\begin_layout Standard
Return the number of devices in the hierarchy (respectively the number of
 device in the group) if the forward option is set to true (respectively
 set to false).
 
\end_layout

\begin_layout Subsubsection
std::vector<std::string> Group::get_device_list (bool fwd = true)
\end_layout

\begin_layout Standard
Returns the list of devices currently in the hierarchy.
\end_layout

\begin_layout Standard
If 
\emph on
fwd
\emph default
 is set to true (the default) the request is forwarded to subgroups.
 Otherwise, it is only applied to the local set of devices.
 
\end_layout

\begin_layout Standard
Considering the following hierarchy:
\end_layout

\begin_layout Verbatim
g2->add("my/device/04"); g2->add("my/device/05");
\end_layout

\begin_layout Verbatim
 
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
g4->add("my/device/08"); g4->add("my/device/09");
\end_layout

\begin_layout Verbatim
 
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
g3->add("my/device/06");
\end_layout

\begin_layout Verbatim
g3->addg(g4);
\end_layout

\begin_layout Verbatim
g3->add("my/device/07");
\end_layout

\begin_layout Verbatim
 
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
g1->add("my/device/01");
\end_layout

\begin_layout Verbatim
g1->add(g2);
\end_layout

\begin_layout Verbatim
g1->add("my/device/03");
\end_layout

\begin_layout Verbatim
g1->add(g3);
\end_layout

\begin_layout Verbatim
g1->add("my/device/02");
\end_layout

\begin_layout Standard
The returned vector content depends on the value of the forward option.
 If set to true, the results will be organized as follows:
\end_layout

\begin_layout Verbatim
std::vector<std::string> dl = g1->get_device_list(true);
\end_layout

\begin_layout Standard

\emph on
dl[0]
\emph default
 contains "my/device/01" which belongs to g1
\begin_inset Newline newline
\end_inset


\emph on
dl[1]
\emph default
 contains "my/device/04" which belongs to g1.g2
\begin_inset Newline newline
\end_inset


\emph on
dl[2]
\emph default
 contains "my/device/05" which belongs to g1.g2
\begin_inset Newline newline
\end_inset


\emph on
dl[3]
\emph default
 contains "my/device/03" which belongs to g1
\begin_inset Newline newline
\end_inset


\emph on
dl[4]
\emph default
 contains "my/device/06" which belongs to g1.g3
\begin_inset Newline newline
\end_inset


\emph on
dl[5]
\emph default
 contains "my/device/08" which belongs to g1.g3.g4
\begin_inset Newline newline
\end_inset


\emph on
dl[6]
\emph default
 contains "my/device/09" which belongs to g1.g3.g4
\begin_inset Newline newline
\end_inset


\emph on
dl[7]
\emph default
 contains "my/device/07" which belongs to g1.g3
\begin_inset Newline newline
\end_inset


\emph on
dl[8]
\emph default
 contains "my/device/02" which belongs to g1
\end_layout

\begin_layout Standard
If the forward option is set to false, the results are:
\end_layout

\begin_layout Verbatim
std::vector<std::string> dl = g1->get_device_list(false);
\end_layout

\begin_layout Standard

\emph on
dl[0]
\emph default
 contains "my/device/01" which belongs to g1
\begin_inset Newline newline
\end_inset


\emph on
dl[1]
\emph default
 contains "my/device/03" which belongs to g1
\begin_inset Newline newline
\end_inset


\emph on
dl[2]
\emph default
 contains "my/device/02" which belongs to g1
\end_layout

\begin_layout Subsection
"A la" DeviceProxy Methods
\end_layout

\begin_layout Subsubsection
bool Group::ping (bool fwd = true)
\end_layout

\begin_layout Standard
Ping all devices in a group.
 This method returns true if all devices in the group are alive, false otherwise.
\end_layout

\begin_layout Standard
If 
\emph on
fwd
\emph default
 is set to true (the default), the request is also forwarded to subgroups.
 Otherwise, it is only applied to the local set of devices.
\end_layout

\begin_layout Subsubsection
void Group::set_timeout_millis(int timeout_ms)
\end_layout

\begin_layout Standard
Set client side timeout for all devices composing the group in milliseconds.
 Any method which takes longer than this time to execute will throw an exception.
\end_layout

\begin_layout Standard

\emph on
Exception: none (errors are ignored).
\end_layout

\begin_layout Subsubsection
GroupCmdReplyList Group::command_inout (const std::string& c, bool fwd =
 true)
\end_layout

\begin_layout Standard
Executes a Tango command on a group.
 This method is synchronous and does not return until replies are obtained
 or timeouts occurred.
\end_layout

\begin_layout Standard
The parameter 
\emph on
c
\emph default
 is the name of the command.
 
\end_layout

\begin_layout Standard
If 
\emph on
fwd
\emph default
 is set to true (the default), the request is also forwarded to subgroups.
 Otherwise, it is only applied to the local set of devices.
 
\end_layout

\begin_layout Standard
Command results are returned in a GroupCmdReplyList.
 See Obtaining command result for details (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Obt-cmd-results"

\end_inset

).
 See also Case 1 of executing a command (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Case-1"

\end_inset

) for an example.
 
\end_layout

\begin_layout Subsubsection
GroupCmdReplyList Group::command_inout (const std::string& c, const DeviceData&
 d, bool fwd = true)
\end_layout

\begin_layout Standard
Executes a Tango command on each device in the group.
 This method is synchronous and does not return until replies are obtained
 or timeouts occurred.
\end_layout

\begin_layout Standard
The parameter 
\emph on
c
\emph default
 is the name of the command.
 
\end_layout

\begin_layout Standard
The second parameter 
\emph on
d
\emph default
 is a Tango generic container for command carrying the command argument.
 See the Tango::DeviceData documentation.
\end_layout

\begin_layout Standard
If 
\emph on
fwd
\emph default
 is set to true (the default), the request is also forwarded to subgroups.
 Otherwise, it is only applied to the local set of devices.
 
\end_layout

\begin_layout Standard
Command results are returned in a GroupCmdReplyList.
 See Obtaining command results (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Obt-cmd-results"

\end_inset

) for details.
 See also Case 2 of executing a command (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Case-2"

\end_inset

) for an example.
 
\end_layout

\begin_layout Subsubsection
template<typename T> GroupCmdReplyList Group::command_inout (const std::string&
 c, const std::vector<T>& d, bool fwd = true)
\end_layout

\begin_layout Standard
Executes a Tango command on each device in the group.
 This method is synchronous and does not return until replies are obtained
 or timeouts occurred.
\end_layout

\begin_layout Standard
This implementation of command_inout allows passing a specific input argument
 to each device in the group.
 In order to use this form of command_inout, the user must have an "a priori"
 and "perfect" knowledge of the devices order in the group.
\end_layout

\begin_layout Standard
The parameter 
\emph on
c
\emph default
 is the name of the command.
 
\end_layout

\begin_layout Standard
The std::vector 
\emph on
d
\emph default
 contains a specific argument value for each device in the group.
 Since this method is a template, d is able to contain any Tango command
 argument type.
 Its size must equal Group::get_size(fwd).
 Otherwise, an exception is thrown.
 The order of the argument values must follows the order of the devices
 in the group (d[0] => 1st device, d[1] => 2nd device and so on).
 
\end_layout

\begin_layout Standard
If 
\emph on
fwd
\emph default
 is set to true (the default), the request is also forwarded to subgroups.
 Otherwise, it is only applied to the local set of devices.
\end_layout

\begin_layout Standard
Command results are returned in a GroupCmdReplyList.
 See Obtaining command results (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Obt-cmd-results"

\end_inset

) for details.
 See also Case 3 of executing a command (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Case-3"

\end_inset

) for an example of this special form of command_inout.
\end_layout

\begin_layout Subsubsection
long Group::command_inout_asynch (const std::string& c, bool fgt = false,
 bool fwd = true, long rsv = -1) 
\end_layout

\begin_layout Standard
Executes a Tango command on each device in the group asynchronously.
 The method sends the request to all devices and returns immediately.
 Pass the returned request id to 
\emph on
Group::command_inout_reply()
\emph default
 to obtain the results.
 
\end_layout

\begin_layout Standard
The parameter 
\emph on
c
\emph default
 is the name of the command.
 
\end_layout

\begin_layout Standard
The parameter 
\emph on
fgt
\emph default
 is a fire and forget flag.
 If set to true, it means that no reply is expected (i.e.
 the caller does not care about it and will not even try to get it).
 A false default value is provided.
 
\end_layout

\begin_layout Standard
If the parameter 
\emph on
fwd
\emph default
 is set to true (the default) request is forwarded to subgroups.
 Otherwise, it is only applied to the local set of devices.
 
\end_layout

\begin_layout Standard
Finally, 
\emph on
rsv
\emph default
 is reserved for internal purpose and should not be modify.
 This parameter may disappear in a near future.
 
\end_layout

\begin_layout Standard
See Case 1 of Executing a command (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Case-1"

\end_inset

) for an example.
\end_layout

\begin_layout Subsubsection
long Group::command_inout_asynch (const std::string& c, const DeviceData&
 d, bool fgt = false, bool fwd = true, long rsv = -1)
\end_layout

\begin_layout Standard
Executes a Tango command on each device in the group asynchronously.
 The method sends the request to all devices and returns immediately.
 Pass the returned request id to 
\emph on
Group::command_inout_reply()
\emph default
 to obtain the results.
 
\end_layout

\begin_layout Standard
The parameter 
\emph on
c
\emph default
 is the name of the command.
 
\end_layout

\begin_layout Standard
The second parameter 
\emph on
d
\emph default
 is a Tango generic container for command carrying the command argument.
 See the Tango::DeviceData documentation for details.
\end_layout

\begin_layout Standard
The parameter 
\emph on
fgt
\emph default
 is a fire and forget flag.
 If set to true, it means that no reply is expected (i.e.
 the caller does not care about it and will not even try to get it).
 A false default value is provided.
 
\end_layout

\begin_layout Standard
If the parameter 
\emph on
fwd
\emph default
 is set to true (the default) request is forwarded to subgroups.
 Otherwise, it is only applied to the local set of devices.
 
\end_layout

\begin_layout Standard
Finally, 
\emph on
rsv
\emph default
 is reserved for internal purpose and should not be modify.
 This parameter may disappear in a near future.
 
\end_layout

\begin_layout Standard
See Case 2 of Executing a command (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Case-2"

\end_inset

) for an example.
\end_layout

\begin_layout Subsubsection
long Group::command_inout_asynch (const std::string& c, const std::vector<T>&
 d, fgt = false, bool fwd = true)
\end_layout

\begin_layout Standard
Executes a Tango command on each device in the group asynchronously.
 The method send the request to all devices and return immediately.
 Pass the returned request id to Group::command_inout_reply to obtain the
 results.
 
\end_layout

\begin_layout Standard
This implementation of command_inout allows passing a specific input argument
 to each device in the group.
 In order to use this form of command_inout_asynch, the user must have an
 "a priori" and "perfect" knowledge of the devices order in the group.
\end_layout

\begin_layout Standard
The parameter 
\emph on
c
\emph default
 is the name of the command.
 
\end_layout

\begin_layout Standard
The std::vector 
\emph on
d
\emph default
 contains a specific argument value for each device in the group.
 d is able to contain any Tango command argument type.
 Its size must equal Group::get_size(fwd).
 Otherwise, an exception is thrown.
 The order of the argument values must follows the order of the devices
 in the group (d[0] => 1st device, d[1] => 2nd device and so on).
 
\end_layout

\begin_layout Standard
The parameter 
\emph on
fgt
\emph default
 is a fire and forget flag.
 If set to true, it means that no reply is expected (i.e.
 the caller does not care about it and will not even try to get it).
 A false default value is provided.
 
\end_layout

\begin_layout Standard
If 
\emph on
fwd
\emph default
 is set to true (the default), the request is also forwarded to subgroups.
 Otherwise, it is only applied to the local set of devices.
\end_layout

\begin_layout Standard
See Case 3 of Executing a command (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Case-3"

\end_inset

) for an example of this special form of command_inout.
\end_layout

\begin_layout Subsubsection
GroupCmdReplyList Group::command_inout_reply (long req_id, long timeout_ms
 = 0)
\end_layout

\begin_layout Standard
Returns the results of an asynchronous command.
 
\end_layout

\begin_layout Standard
The first parameter 
\emph on
req_id
\emph default
 is a request identifier previously returned by one of the command_inout_asynch
 methods.
 
\end_layout

\begin_layout Standard
For each device in the hierarchy, if the command result is not yet available,
 command_inout_reply wait 
\emph on
timeout_ms
\emph default
 milliseconds before throwing an exception.
 This exception will be part of the global reply.
 If 
\emph on
timeout_ms
\emph default
 is set to 0, command_inout_reply waits "indefinitely".
\end_layout

\begin_layout Standard
Command results are returned in a GroupCmdReplyList.
 See Obtaining command results (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Obt-cmd-results"

\end_inset

) for details.
\end_layout

\begin_layout Subsubsection
GroupAttrReplyList Group::read_attribute (const std::string& a, bool fwd
 = true)
\end_layout

\begin_layout Standard
Reads an attribute on each device in the group.
 This method is synchronous and does not return until replies are obtained
 or timeouts occurred.
 
\end_layout

\begin_layout Standard
The parameter 
\emph on
a
\emph default
 is the name of the attribute to read.
 
\end_layout

\begin_layout Standard
If 
\emph on
fwd
\emph default
 is set to true (the default) request is forwarded to subgroups.
 Otherwise, it is only applied to the local set of devices.
 
\end_layout

\begin_layout Standard
Attribute values are returned in a GroupAttrReplyList.
 See Obtaining attribute values (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:O-attr-values"

\end_inset

) for details.
 See also Reading an attribute (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Read-attr"

\end_inset

) for an example.
\end_layout

\begin_layout Subsubsection
long Group::read_attribute_asynch (const std::string& a, bool fwd = true,
 long rsv = -1)
\end_layout

\begin_layout Standard
Reads an attribute on each device in the group asynchronously.
 The method sends the request to all devices and returns immediately.
 Pass the returned request id to 
\emph on
Group::read_attribute_reply()
\emph default
 to obtain the results.
 
\end_layout

\begin_layout Standard
The parameter 
\emph on
a
\emph default
 is the name of the attribute to read.
 
\end_layout

\begin_layout Standard
If 
\emph on
fwd
\emph default
 is set to true (the default) request is forwarded to subgroups.
 Otherwise, it is only applied to the local set of devices.
 
\end_layout

\begin_layout Standard
The last parameter (rsv) is reserved for internal purpose and should not
 be modify.
 It may disappear in a near future.
 
\end_layout

\begin_layout Standard
See Reading an attribute (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Read-attr"

\end_inset

) for an example.
\end_layout

\begin_layout Subsubsection
GroupAttrReplyList Group::read_attribute_reply (long req_id, long timeout_ms
 = 0)
\end_layout

\begin_layout Standard
Returns the results of an asynchronous attribute reading.
 
\end_layout

\begin_layout Standard
The first parameter 
\emph on
req_id
\emph default
 is a request identifier previously returned by read_attribute_asynch.
 
\end_layout

\begin_layout Standard
For each device in the hierarchy, if the attribute value is not yet available,
 read_attribute_reply wait 
\emph on
timeout_ms
\emph default
 milliseconds before throwing an exception.
 This exception will be part of the global reply.
 If 
\emph on
timeout_ms
\emph default
 is set to 0, read_attribute_reply waits "indefinitely".
\end_layout

\begin_layout Standard
Replies are returned in a GroupAttrReplyList.
 See Obtaining attribute values (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:O-attr-values"

\end_inset

) for details.
\end_layout

\begin_layout Subsubsection
GroupReplyList Group::write_attribute (const DeviceAttribute& d, bool fwd
 = true)
\end_layout

\begin_layout Standard
Writes an attribute on each device in the group.
 This method is synchronous and does not return until acknowledgements are
 obtained or timeouts occurred.
 
\end_layout

\begin_layout Standard
The first parameter 
\emph on
d
\emph default
 is a Tango generic container for attribute carrying both the attribute
 name and the value.
 See the Tango::DeviceAttribute documentation for details.
\end_layout

\begin_layout Standard
If 
\emph on
fwd
\emph default
 is set to true (the default) request is forwarded to subgroups.
 Otherwise, it is only applied to the local set of devices.
 
\end_layout

\begin_layout Standard
Acknowledgements are returned in a GroupReplyList.
 See Obtaining acknowledgements (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:O-ack"

\end_inset

) for details.
 See also Case 1 of Writing an attribute (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Case-1-writing"

\end_inset

) for an example.
\end_layout

\begin_layout Subsubsection
GroupReplyList Group::write_attribute (const std::string& a, const std::vector<T
>& d, bool fwd = true)
\end_layout

\begin_layout Standard
Writes an attribute on each device in the group.
 This method is synchronous and does not return until replies are obtained
 or timeouts occurred.
\end_layout

\begin_layout Standard
This implementation of write_attribute allows writing a specific value to
 each device in the group.
 In order to use this form of write_attribute, the user must have an "a
 priori" and "perfect" knowledge of the devices order in the group.
\end_layout

\begin_layout Standard
The parameter 
\emph on
a
\emph default
 is the name of the attribute.
 
\end_layout

\begin_layout Standard
The std::vector 
\emph on
d
\emph default
 contains a specific value for each device in the group.
 Since this method is a template, d is able to contain any Tango attribute
 type.
 Its size must equal 
\emph on
Group::get_size(fwd)
\emph default
.
 Otherwise, an exception is thrown.
 The order of the attribute values must follows the order of the devices
 in the group (d[0] => 1st device, d[1] => 2nd device and so on).
 
\end_layout

\begin_layout Standard
If 
\emph on
fwd
\emph default
 is set to true (the default) request is forwarded to subgroups.
 Otherwise, it is only applied to the local set of devices.
\end_layout

\begin_layout Standard
Acknowledgements are returned in a GroupReplyList.
 See Obtaining acknowledgements (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:O-ack"

\end_inset

) for details.
 See also Case 2 of Writing an attribute (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Case-2-writing"

\end_inset

) for an example.
\end_layout

\begin_layout Subsubsection
long Group::write_attribute_asynch (const DeviceAttribute& d, bool fwd =
 true, long rsv = -1)
\end_layout

\begin_layout Standard
Writes an attribute on each device in the group asynchronously.
 The method sends the request to all devices and returns immediately.
 Pass the returned request id to 
\emph on
Group::write_attribute_reply()
\emph default
 to obtain the acknowledgements.
 
\end_layout

\begin_layout Standard
The first parameter 
\emph on
d
\emph default
 is a Tango generic container for attribute carrying both the attribute
 name and the value.
 See the Tango::DeviceAttribute documentation for details.
\end_layout

\begin_layout Standard
If 
\emph on
fwd
\emph default
 is set to true (the default) request is forwarded to subgroups.
 Otherwise, it is only applied to the local set of devices.
 
\end_layout

\begin_layout Standard
The last parameter 
\emph on
rsv
\emph default
 is reserved for internal purpose and should not be modify.
 It may disappear in a near future.
\end_layout

\begin_layout Standard
See Case 1 of Writing an attribute (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Case-1-writing"

\end_inset

) for an example.
\end_layout

\begin_layout Subsubsection
long Group::write_attribute_asynch (const std::string& a, const std::vector<T>&
 d, bool fwd = true)
\end_layout

\begin_layout Standard
Writes an attribute on each device in the group asynchronously.
 The method sends the request to all devices and returns immediately.
 Pass the returned request id to 
\emph on
Group::write_attribute_reply()
\emph default
 to obtain the acknowledgements.
\end_layout

\begin_layout Standard
This implementation of write_attribute_asynch allows writing a specific
 value to each device in the group.
 In order to use this form of write_attribute_asynch, the user must have
 an "a priori" and "perfect" knowledge of the devices order in the group.
\end_layout

\begin_layout Standard
The parameter 
\emph on
a
\emph default
 is the name of the attribute.
 
\end_layout

\begin_layout Standard
The std::vector 
\emph on
d
\emph default
 contains a specific value for each device in the group.
 Since this method is a template, d is able to contain any Tango attribute
 type.
 Its size must equal 
\emph on
Group::get_size(fwd)
\emph default
.
 Otherwise, an exception is thrown.
 The order of the attribute values must follows the order of the devices
 in the group (d[0] => 1st device, d[1] => 2nd device and so on).
 
\end_layout

\begin_layout Standard
If 
\emph on
fwd
\emph default
 is set to true (the default) request is forwarded to subgroups.
 Otherwise, it is only applied to the local set of devices.
\end_layout

\begin_layout Standard
See Case2 of Writing an attribute (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Case-2-writing"

\end_inset

) for an example.
\end_layout

\begin_layout Subsubsection
GroupReplyList Group::write_attribute_reply (long req_id, long timeout_ms
 = 0)
\end_layout

\begin_layout Standard
Returns the acknowledgements of an asynchronous attribute writing.
 
\end_layout

\begin_layout Standard
The first parameter 
\emph on
req_id
\emph default
 is a request identifier previously returned by one of the write_attribute_async
h implementation.
 
\end_layout

\begin_layout Standard
For each device in the hierarchy, if the acknowledgement is not yet available,
 write_attribute_reply wait 
\emph on
timeout_ms
\emph default
 milliseconds before throwing an exception.
 This exception will be part of the global reply.
 If 
\emph on
timeout_ms
\emph default
 is set to 0, write_attribute_reply waits "indefinitely".
\end_layout

\begin_layout Standard
Acknowledgements are returned in a GroupReplyList.
 See Obtaining acknowledgements 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:O-ack"

\end_inset

 for details.
\end_layout

\begin_layout Subsubsection
GroupAttrReplyList Group::read_attributes (const std::vector<std::string>&
 al, bool fwd = true)
\end_layout

\begin_layout Standard
Reads several attributes on each device in the group.
 This method is synchronous and does not return until replies are obtained
 or timeouts occurred.
 
\end_layout

\begin_layout Standard
The parameter 
\emph on
al
\emph default
 is a vector containing the name of the attributes to be read.
 
\end_layout

\begin_layout Standard
If 
\emph on
fwd
\emph default
 is set to true (the default) request is forwarded to subgroups.
 Otherwise, it is only applied to the local set of devices.
 
\end_layout

\begin_layout Standard
Attribute values are returned in a GroupAttrReplyList.
 See Obtaining attribute values (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:O-attr-values"

\end_inset

) for details.
 See also Reading an attribute (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Read-attr"

\end_inset

) for an example.
 The order of attribute value returned in the GroupAttrReplyList is all
 attributes for first element in the group followed by all attributes for
 the second group element and so on.
\end_layout

\begin_layout Subsubsection
long Group::read_attributes_asynch (const std::vector<std::string>& al,
 bool fwd = true, long rsv = -1)
\end_layout

\begin_layout Standard
Reads several attributes on each device in the group asynchronously.
 The method sends the request to all devices and returns immediately.
 Pass the returned request id to 
\emph on
Group::read_attributes_reply()
\emph default
 to obtain the results.
 
\end_layout

\begin_layout Standard
The parameter 
\emph on
al
\emph default
 is a vector containing the name of the attributes to be read.
 
\end_layout

\begin_layout Standard
If 
\emph on
fwd
\emph default
 is set to true (the default) request is forwarded to subgroups.
 Otherwise, it is only applied to the local set of devices.
 
\end_layout

\begin_layout Standard
The last parameter (rsv) is reserved for internal purpose and should not
 be modify.
 It may disappear in a near future.
 
\end_layout

\begin_layout Standard
See Reading an attribute (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Read-attr"

\end_inset

) for an example.
\end_layout

\begin_layout Subsubsection
GroupAttrReplyList Group::read_attributes_reply (long req_id, long timeout_ms
 = 0)
\end_layout

\begin_layout Standard
Returns the results of an asynchronous attribute reading.
 
\end_layout

\begin_layout Standard
The first parameter 
\emph on
req_id
\emph default
 is a request identifier previously returned by read_attributes_asynch.
 
\end_layout

\begin_layout Standard
For each device in the hierarchy, if the attribute value is not yet available,
 read_attributes_reply wait 
\emph on
timeout_ms
\emph default
 milliseconds before throwing an exception.
 This exception will be part of the global reply.
 If 
\emph on
timeout_ms
\emph default
 is set to 0, read_attributes_reply waits "indefinitely".
\end_layout

\begin_layout Standard
Replies are returned in a GroupAttrReplyList.
 See Obtaining attribute values (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:O-attr-values"

\end_inset

) for details.
 The order of attribute value returned in the GroupAttrReplyList is all
 attributes for first element in the group followed by all attributes for
 the second group element and so on.
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Section
\noindent
Tango::Database
\end_layout

\begin_layout Standard
\noindent
A high level object which contains the link to the database.
 It has methods for all database commands e.g.
 get_device_property(), device_list(), info(), etc.
 
\end_layout

\begin_layout Subsection
\noindent
Database::Database()
\end_layout

\begin_layout Standard
\noindent
Create a TANGO Database object.
 The constructor uses the environment variable 
\begin_inset Quotes eld
\end_inset

TANGO_HOST
\begin_inset Quotes erd
\end_inset

 to determine which instance of the TANGO database to connect to.
 Example :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
using namespace Tango;
\end_layout

\begin_layout Verbatim
\noindent
Database *db = new Database();
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
The Database class also has a copy constructor and one assignement operator
 defined.
\end_layout

\begin_layout Subsection
\noindent
string Database::get_info()
\end_layout

\begin_layout Standard
\noindent
Query the database for some general info about the tables in the database.
 Result is returned as a string.
 Example :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
cout << db->get_info() << endl;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent
will return information like this :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
Running since 2000-11-06 14:10:46
\end_layout

\begin_layout Verbatim
\noindent
 
\end_layout

\begin_layout Verbatim
\noindent
Devices defined  = 115
\end_layout

\begin_layout Verbatim
\noindent
Devices exported  = 41
\end_layout

\begin_layout Verbatim
\noindent
Device servers defined  = 47
\end_layout

\begin_layout Verbatim
\noindent
Device servers exported  = 17
\end_layout

\begin_layout Verbatim
\noindent
 
\end_layout

\begin_layout Verbatim
\noindent
Class properties defined  = 5
\end_layout

\begin_layout Verbatim
\noindent
Device properties defined  = 130
\end_layout

\begin_layout Verbatim
\noindent
Class attribute properties defined  = 20
\end_layout

\begin_layout Verbatim
\noindent
Device attribute properties defined  = 92
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions: ConnectionFailed, CommunicationFailed, DevFailed from device
 (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void Database::add_device(DbDevInfo&)
\end_layout

\begin_layout Standard
\noindent
Add a device to the database.
 The device name, server and class are specified in the DbDevInfo structure.
 Example :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbDevInfo my_device_info;
\end_layout

\begin_layout Verbatim
\noindent
my_device_info.name = 
\begin_inset Quotes eld
\end_inset

my/own/device
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Verbatim
\noindent
my_device_info._class = 
\begin_inset Quotes eld
\end_inset

MyDevice
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Verbatim
\noindent
my_device_info.server = 
\begin_inset Quotes eld
\end_inset

MyServer/test
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Verbatim
\noindent
db->add_device(my_device_info);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
\noindent
void Database::delete_device(string)
\end_layout

\begin_layout Standard
\noindent
Delete the device of the specified name from the database.
 Example
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
db->delete_device(
\begin_inset Quotes eld
\end_inset

my/own/device
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError,
 DB_DeviceNotDefined)
\end_layout

\begin_layout Subsection
\noindent
DbDevImportInfo Database::import_device(string &)
\end_layout

\begin_layout Standard
\noindent
Query the database for the export info of the specified device.
 The command returns the information in a DbDevImportInfo structure.
 Example :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbDevImportInfo my_device_import;
\end_layout

\begin_layout Verbatim
\noindent
my_device_import = db->import_device(
\begin_inset Quotes eld
\end_inset

my/own/device
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Verbatim
\noindent
cout << 
\begin_inset Quotes eld
\end_inset

 device 
\begin_inset Quotes erd
\end_inset

 << my_device_import.name;
\end_layout

\begin_layout Verbatim
\noindent
cout << 
\begin_inset Quotes eld
\end_inset

exported 
\begin_inset Quotes erd
\end_inset

 << my_device_import.exported;
\end_layout

\begin_layout Verbatim
\noindent
cout << 
\begin_inset Quotes eld
\end_inset

ior 
\begin_inset Quotes erd
\end_inset

 << my_device_import.ior;
\end_layout

\begin_layout Verbatim
\noindent
cout << 
\begin_inset Quotes eld
\end_inset

version 
\begin_inset Quotes erd
\end_inset

 << my_device_import.version;
\end_layout

\begin_layout Verbatim
\noindent
cout << endl;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device ( DB_SQLError,
 DB_DeviceNotDefined)
\end_layout

\begin_layout Subsection
\noindent
void Database::export_device(DbDevExportInfo&)
\end_layout

\begin_layout Standard
\noindent
Update the export info for this device in the database.
 Device name, server, class, pid and version are specified in the DbDevExportInf
o structure.
 Example :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbDevExportInfo my_device_export;
\end_layout

\begin_layout Verbatim
\noindent
my_device_export.name = 
\begin_inset Quotes eld
\end_inset

my/own/device
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Verbatim
\noindent
my_device_export.ior = 
\begin_inset Quotes eld
\end_inset

the real ior
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Verbatim
\noindent
my_device_export.host = 
\begin_inset Quotes eld
\end_inset

dumela
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Verbatim
\noindent
my_device_export.version = 
\begin_inset Quotes eld
\end_inset

1.0
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Verbatim
\noindent
my_device_export.pid = get_pid();
\end_layout

\begin_layout Verbatim
\noindent
db->export_device(my_device_export);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError,
 DB_DeviceNotDefined)
\end_layout

\begin_layout Subsection
\noindent
void Database::unexport_device(string)
\end_layout

\begin_layout Standard
\noindent
Mark the specified device as un-exported in the database.
 Example :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
db->unexport_device(
\begin_inset Quotes eld
\end_inset

my/own/device
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void Database::add_server(string &, DbDevInfos&)
\end_layout

\begin_layout Standard
\noindent
Add a group of devices to the database.
 The device names, server names and classes are specified in the vector
 of DbDevInfo structures.
\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void Database::delete_server(string &)
\end_layout

\begin_layout Standard
\noindent
Delete the device server and its associated devices from the database.
\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void Database::export_server( DbDevExportInfos &)
\end_layout

\begin_layout Standard
\noindent
Export a group of devices to the database.
 The device names, IOR, class, server name, pid etc.
 are specified in the vector of DbDevExportInfo structures.
\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void Database::unexport_server(string &)
\end_layout

\begin_layout Standard
\noindent
Mark all devices exported for this server as unexported.
\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
DbDatum Database::get_services(string &servicename,string &instname)
\end_layout

\begin_layout Standard
Query database for specified services.The instname parameter can be a wildcard
 character ("*").
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string servicename("HdbManager");
\end_layout

\begin_layout Verbatim
string instname("ctrm");
\end_layout

\begin_layout Verbatim
DbDatum db_datum = db->get_services(servicename,instname);
\end_layout

\begin_layout Verbatim
vector<string> service_list;
\end_layout

\begin_layout Verbatim
db_datum >> service_list;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
void Database::register_service(string &servicename,string &instname,string
 &devname)
\end_layout

\begin_layout Standard
Register the specified service wihtin the database.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string servicename("HdbManager");
\end_layout

\begin_layout Verbatim
string instname("ctrm");
\end_layout

\begin_layout Verbatim
string devname("sys/hdb/1");
\end_layout

\begin_layout Verbatim
db->register_service(servicename,instname,devname);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
void Database::unregister_service(string &servicename,string &instname)
\end_layout

\begin_layout Standard
Unregister the specified service from the database.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string servicename("HdbManager");
\end_layout

\begin_layout Verbatim
string instname("ctrm");
\end_layout

\begin_layout Verbatim
db->unregister_service(servicename,instname);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
DbDatum Database::get_host_list()
\end_layout

\begin_layout Standard
Returns the list of all host names registered in the database.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
DbDatum db_datum = db->get_host_list();
\end_layout

\begin_layout Verbatim
vector<string> host_list;
\end_layout

\begin_layout Verbatim
db_datum >> host_list;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
DbDatum Database::get_host_list(string &wildcard)
\end_layout

\begin_layout Standard
Returns the list of all host names registered in the database which match
 the specified wildcard (eg: "l-c0*").
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string wildcard("l-c0*");
\end_layout

\begin_layout Verbatim
DbDatum db_datum = db->get_host_list(wildcard);
\end_layout

\begin_layout Verbatim
vector<string> host_list;
\end_layout

\begin_layout Verbatim
db_datum >> host_list;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
DbDatum Database::get_server_class_list(string &server)
\end_layout

\begin_layout Standard
Query the database for a list of classes instancied by the specified server.
 The DServer class exists in all TANGO servers and for this reason this
 class is removed from the returned list.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string server("Serial/1");
\end_layout

\begin_layout Verbatim
DbDatum db_datum = db->get_server_class_list(server);
\end_layout

\begin_layout Verbatim
vector<string> class_list;
\end_layout

\begin_layout Verbatim
db_datum >> class_list;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
DbDatum Database::get_server_name_list()
\end_layout

\begin_layout Standard
Return the list of all server names registered in the database.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
DbDatum db_datum = db->get_server_name_list();
\end_layout

\begin_layout Verbatim
vector<string> server_list;
\end_layout

\begin_layout Verbatim
db_datum >> server_list;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
DbDatum Database::get_instance_name_list(string &servername)
\end_layout

\begin_layout Standard
Return the list of all instance names existing in the database for the specifed
 server.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string servername("Serial");
\end_layout

\begin_layout Verbatim
DbDatum db_datum = db->get_instance_name_list(servername);
\end_layout

\begin_layout Verbatim
vector<string> instance_list;
\end_layout

\begin_layout Verbatim
db_datum >> instance_list;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
DbDatum Database::get_server_list()
\end_layout

\begin_layout Standard
Return the list of all servers registered in the database.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
DbDatum db_datum = db->get_server_list();
\end_layout

\begin_layout Verbatim
vector<string> server_list;
\end_layout

\begin_layout Verbatim
db_datum >> server_list;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
DbDatum Database::get_server_list(string &wildcard)
\end_layout

\begin_layout Standard
Return the list of all servers registered in the database which match the
 specified wildcard (eg: "Serial/*").
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string wildcard("Serial/*");
\end_layout

\begin_layout Verbatim
DbDatum db_datum = db->get_server_list(wildcard);
\end_layout

\begin_layout Verbatim
vector<string> server_list;
\end_layout

\begin_layout Verbatim
db_datum >> server_list;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
DbDatum Database::get_host_server_list(string &hostname)
\end_layout

\begin_layout Standard
Query the database for a list of servers registred on the specified host.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string host("kidiboo");
\end_layout

\begin_layout Verbatim
DbDatum db_datum = db->get_host_server_list(wildcard);
\end_layout

\begin_layout Verbatim
vector<string> server_list;
\end_layout

\begin_layout Verbatim
db_datum >> server_list;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
DbServerInfo Database::get_server_info(string &server)
\end_layout

\begin_layout Standard
Query the database for server information.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string server("Serial/1");
\end_layout

\begin_layout Verbatim
DbServerInfo info = db->get_server_info(server);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
void Database::put_server_info(DbServerInfo &info)
\end_layout

\begin_layout Standard
Add/update server information in the database.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
DbServerInfo info;
\end_layout

\begin_layout Verbatim
info.name = "Serial/1"; // Server (name/instance)
\end_layout

\begin_layout Verbatim
info.host = "kidiboo"; // Register on host kidiboo
\end_layout

\begin_layout Verbatim
info.mode = 1; // Controlled by Astor flag (0 or 1)
\end_layout

\begin_layout Verbatim
info.level = 3; // Startup level (Used by Astor)
\end_layout

\begin_layout Verbatim
db->put_server_info(info);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
void Database::delete_server_info(string &server)
\end_layout

\begin_layout Standard
Delete server information of the specifed server from the database.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string server("Serial/1");
\end_layout

\begin_layout Verbatim
db->delete_server_info(server);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
\noindent
DbDatum Database::get_device_name(string &, string &)
\end_layout

\begin_layout Standard
\noindent
Query the database for a list of devices served by the specified server
 (1st parameter) and of the specified class (2nd parameter).
 The method returns a DbDatum type.
 The device names are stored as an array of strings.
 Here is two code example of how to extract the names from the DbDatum type
 :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
vector<string> device_names;
\end_layout

\begin_layout Verbatim
\noindent
device_names << db_datum;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent
or :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
for (int i=0; i< db_datum.size(); i++)
\end_layout

\begin_layout Verbatim
\noindent
{
\end_layout

\begin_layout Verbatim
\noindent
device_name[i] = db_datum.value_string[i];
\end_layout

\begin_layout Verbatim
\noindent
}
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
\noindent
DbDatum Database::get_device_exported(string &)
\end_layout

\begin_layout Standard
\noindent
Query the database for a list of exported devices whose names satisfy the
 supplied filter (* is wildcard for any character(s)).
 This method returns a DbDatum type.
 See the method get_device_name() for an example of how to extract the list
 of aliases from the DbDatum type.
\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
DbDatum Database::get_device_domain(string &)
\end_layout

\begin_layout Standard
\noindent
Query the database for a list of device domain names which match the wildcard
 provided.
 Wildcard character is * and matches any number of characters.
 Domain names are case insensitive.
 This method returns a DbDatum type.
 See the method get_device_name() for an example of how to extract the list
 of aliases from the DbDatum type.
\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
DbDatum Database::get_device_family(string &)
\end_layout

\begin_layout Standard
\noindent
Query the database for a list of device family names which match the wildcard
 provided.
 Wildcard character is * and matches any number of characters.
 Family names are case insensitive.
 This method returns a DbDatum type.
 See the method get_device_name() for an example of how to extract the list
 of aliases from the DbDatum type.
\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
DbDatum Database::get_device_member(string &)
\end_layout

\begin_layout Standard
\noindent
Query the database for a list of device member names which match the wildcard
 provided.
 Wildcard characters is * and matches any number of characters.
 Member names are case insensitive.
 This method returns a DbDatum type.
 See the method get_device_name() for an example of how to extract the list
 of aliases from the DbDatum type.
\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
DbDatum Database::get_device_class_list(string &server)
\end_layout

\begin_layout Standard
Query the database for a list of devices and classes served by the specified
 server.
 Return a list with the following structure: {device name,class name,device
 name,class name,...}
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string server("Serial/1");
\end_layout

\begin_layout Verbatim
DbDatum db_datum = db->get_device_class_list(server);
\end_layout

\begin_layout Verbatim
vector<string> dev_list;
\end_layout

\begin_layout Verbatim
db_datum >> dev_list;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
string Database::get_class_for_device(string &devname)
\end_layout

\begin_layout Standard
Return the class of the specified device.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string devname("sr/rf-cavity/1");
\end_layout

\begin_layout Verbatim
string classname = db->get_class_for_device(devname);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
DbDatum Database::get_class_inheritance_for_device(string &devname)
\end_layout

\begin_layout Standard
Return the class inheritance scheme of the specified device.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string devname("sr/rf-cavity/1");
\end_layout

\begin_layout Verbatim
DbDatum db_datum = db->get_class_inheritance_for_device(devname);
\end_layout

\begin_layout Verbatim
vector<string> class_list;
\end_layout

\begin_layout Verbatim
db_datum >> class_list;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
DbDatum Database::get_device_exported_for_class(string &classname)
\end_layout

\begin_layout Standard
Query database for list of exported devices for the specified class.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string classname("MyClass");
\end_layout

\begin_layout Verbatim
DbDatum db_datum = db->get_device_exported_for_class(classname);
\end_layout

\begin_layout Verbatim
vector<string> dev_list;
\end_layout

\begin_layout Verbatim
db_datum >> dev_list;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
DbDatum Database::get_object_list(string &wildcard)
\end_layout

\begin_layout Standard
Query the database for a list of object (free properties) for which properties
 are defined and which match the specified wildcard.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string wildcard("Optic*");
\end_layout

\begin_layout Verbatim
DbDatum db_datum = db->get_object_list(wildcard);
\end_layout

\begin_layout Verbatim
vector<string> obj_list;
\end_layout

\begin_layout Verbatim
db_datum >> obj_list;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
DbDatum Database::get_object_property_list(string &objectname,string &wildcard)
\end_layout

\begin_layout Standard
Query the database for a list of properties defined for the specified object
 and which match the specified wildcard.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string objname("OpticID9");
\end_layout

\begin_layout Verbatim
string wildcard("Delta*");
\end_layout

\begin_layout Verbatim
DbDatum db_datum = db->get_object_property_list(objname,wildcard);
\end_layout

\begin_layout Verbatim
vector<string> prop_list;
\end_layout

\begin_layout Verbatim
db_datum >> prop_list;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
\noindent
void Database::get_property(string, DbData&)
\end_layout

\begin_layout Standard
\noindent
Query the database for a list of object (i.e.
 non-device) properties for the specified object.
 The property names are specified by the vector of DbDatum structures.
 The method returns the properties in the same DbDatum structures.
 To retrieve the properties use the extract operator >>.
 Here is an example of how to use the DbData type to specify and extract
 properties :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbData db_data;
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum(
\begin_inset Quotes eld
\end_inset

velocity
\begin_inset Quotes erd
\end_inset

));
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum(
\begin_inset Quotes eld
\end_inset

acceleration
\begin_inset Quotes erd
\end_inset

));
\end_layout

\begin_layout Verbatim
\noindent
db->get_property(
\begin_inset Quotes eld
\end_inset

mymotor
\begin_inset Quotes erd
\end_inset

, db_data);
\end_layout

\begin_layout Verbatim
\noindent
float velocity, acceleration;
\end_layout

\begin_layout Verbatim
\noindent
db_data[0] >> velocity;
\end_layout

\begin_layout Verbatim
\noindent
db_data[1] >> acceleration;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void Database::put_property(string, DbData&)
\end_layout

\begin_layout Standard
\noindent
Insert or update a list of properties for the specified object.
 The property names and their values are specified by the vector of DbDatum
 structures.
 Use the insert operator >> to insert the properties into the DbDatum structures.
 Here is an example of how to insert properties into the database using
 this method :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbDatum velocity(
\begin_inset Quotes eld
\end_inset

velocity
\begin_inset Quotes erd
\end_inset

), acceleration(
\begin_inset Quotes eld
\end_inset

acceleration
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Verbatim
\noindent
DbData db_data;
\end_layout

\begin_layout Verbatim
\noindent
velocity << 100000.0;
\end_layout

\begin_layout Verbatim
\noindent
acceleration << 500000.0;
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(velocity);
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(acceleration);
\end_layout

\begin_layout Verbatim
\noindent
db->put_property(
\begin_inset Quotes eld
\end_inset

mymotor
\begin_inset Quotes erd
\end_inset

, db_data);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void Database::delete_property(string, DbData&)
\end_layout

\begin_layout Standard
\noindent
Delete a list of properties for the specified object.
 The property names are specified by the vector of DbDatum structures.
 Here is an example of how to delete properties from the database using
 this method :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbData db_data;
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum(
\begin_inset Quotes eld
\end_inset

velocity
\begin_inset Quotes erd
\end_inset

));
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum(
\begin_inset Quotes eld
\end_inset

acceleration
\begin_inset Quotes erd
\end_inset

));
\end_layout

\begin_layout Verbatim
\noindent
db->delete_property(
\begin_inset Quotes eld
\end_inset

mymotor
\begin_inset Quotes erd
\end_inset

, db_data);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exceptions: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
vector<DbHistory> Database::get_property_history(string &objname, string
 &propname)
\end_layout

\begin_layout Standard
Get the list of the last 10 modifications of the specifed object property.
 Note that propname can contain a wildcard character (eg: "prop*").
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
vector<DbHistory> hist;
\end_layout

\begin_layout Verbatim
DbDatum result;
\end_layout

\begin_layout Verbatim
string objname("jlptest");
\end_layout

\begin_layout Verbatim
string propname("test_prop");
\end_layout

\begin_layout Verbatim
hist = db->get_property_history(objname,propname);
\end_layout

\begin_layout Verbatim
// Print the modification history of the specified property
\end_layout

\begin_layout Verbatim
for(int i=0;i<hist.size();i++) {
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
  cout << "Name:" << hist[i].get_name() << endl; 
\end_layout

\begin_layout Verbatim
  cout << "Date:" << hist[i].get_date() << endl; 
\end_layout

\begin_layout Verbatim
  if( hist[i].is_deleted() ) {
\end_layout

\begin_layout Verbatim
    cout << "Deleted !" << endl;
\end_layout

\begin_layout Verbatim
  } else {
\end_layout

\begin_layout Verbatim
    hist[i].get_value() >> result;
\end_layout

\begin_layout Verbatim
    for (int j=0; j<result.size(); j++)
\end_layout

\begin_layout Verbatim
      cout << "Value:" << result[j] << endl;
\end_layout

\begin_layout Verbatim
  }
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
}
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exceptions: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
\noindent
void Database::get_device_property(string, DbData&)
\end_layout

\begin_layout Standard
\noindent
Query the database for a list of device properties for the specified object.
 The property names are specified by the vector of DbDatum structures.
 The method returns the properties in the same DbDatum structures.
 To retrieve the properties use the extract operator >>.
 Here is an example of how to use the DbData type to specify and extract
 properties :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbData db_data;
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum(
\begin_inset Quotes eld
\end_inset

velocity
\begin_inset Quotes erd
\end_inset

));
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum(
\begin_inset Quotes eld
\end_inset

acceleration
\begin_inset Quotes erd
\end_inset

));
\end_layout

\begin_layout Verbatim
\noindent
db->get_device_property(
\begin_inset Quotes eld
\end_inset

id11/motor/1
\begin_inset Quotes erd
\end_inset

, db_data);
\end_layout

\begin_layout Verbatim
\noindent
float velocity, acceleration;
\end_layout

\begin_layout Verbatim
\noindent
db_data[0] >> velocity;
\end_layout

\begin_layout Verbatim
\noindent
db_data[1] >> acceleration;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void Database::put_device_property(string, DbData&)
\end_layout

\begin_layout Standard
\noindent
Insert or update a list of properties for the specified device.
 The property names and their values are specified by the vector of DbDatum
 structures.
 Use the insert operator >> to insert the properties into the DbDatum structures.
 Here is an example of how to insert properties into the database using
 this method :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbDatum velocity(
\begin_inset Quotes eld
\end_inset

velocity
\begin_inset Quotes erd
\end_inset

), acceleration(
\begin_inset Quotes eld
\end_inset

acceleration
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Verbatim
\noindent
DbData db_data;
\end_layout

\begin_layout Verbatim
\noindent
velocity << 100000.0;
\end_layout

\begin_layout Verbatim
\noindent
acceleration << 500000.0;
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(velocity);
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(acceleration);
\end_layout

\begin_layout Verbatim
\noindent
db->put_device_property(
\begin_inset Quotes eld
\end_inset

id11/motor/1
\begin_inset Quotes erd
\end_inset

, db_data);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void Database::delete_device_property(string, DbData&)
\end_layout

\begin_layout Standard
\noindent
Delete a list of properties for the specified device.
 The property names are specified by the vector of DbDatum structures.
 Here is an example of how to delete properties from the database using
 this method :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbData db_data;
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum(
\begin_inset Quotes eld
\end_inset

velocity
\begin_inset Quotes erd
\end_inset

));
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum(
\begin_inset Quotes eld
\end_inset

acceleration
\begin_inset Quotes erd
\end_inset

));
\end_layout

\begin_layout Verbatim
\noindent
db->delete_device_property(
\begin_inset Quotes eld
\end_inset

id11/motor/1
\begin_inset Quotes erd
\end_inset

, db_data);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
vector<DbHistory> Database::get_device_property_history(string &devname,
 string &propname)
\end_layout

\begin_layout Standard
Get the list of the last 10 modifications of the specifed device property.
 Note that propname can contain a wildcard character (eg: "prop*").
 An example of usage of a similar function can be found in the documentation
 of the get_property_history() function.
\end_layout

\begin_layout Standard
Exceptions: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
\noindent
void Database::get_device_attribute_property(string, DbData&)
\end_layout

\begin_layout Standard
\noindent
Query the database for a list of device attribute properties for the specified
 object.
 The attribute names are specified by the vector of DbDatum structures.
 The method returns all the properties for the specified attributes.
 The attribute names are returned with the number of properties specified
 as their value.
 The first DbDatum element of the returned DbData vector contains the first
 attribute name and the first attribute property number.
 The following DbDatum element contains the first attribute property name
 and property values.
 To retrieve the properties use the extract operator >>.
 Here is an example of how to use the DbData type to specify and extract
 attribute properties :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbData db_data;
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum("velocity"));
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum("acceleration"));
\end_layout

\begin_layout Verbatim
\noindent
 
\end_layout

\begin_layout Verbatim
\noindent
db->get_device_attribute_property("id11/motor/1", db_data);
\end_layout

\begin_layout Verbatim
\noindent
 
\end_layout

\begin_layout Verbatim
float vel_max, vel_min, acc_max, acc_min;
\end_layout

\begin_layout Verbatim
\noindent
 
\end_layout

\begin_layout Verbatim
for (int i=0;i < db_data.size();)
\end_layout

\begin_layout Verbatim
\noindent
{
\end_layout

\begin_layout Verbatim
     long nb_prop;
\end_layout

\begin_layout Verbatim
     string &att_name = db_data[i].name;
\end_layout

\begin_layout Verbatim
     db_data[i] >> nb_prop;
\end_layout

\begin_layout Verbatim
     i++;
\end_layout

\begin_layout Verbatim
     for (int k=0;k < nb_prop;k++)
\end_layout

\begin_layout Verbatim
     {
\end_layout

\begin_layout Verbatim
         string &prop_name = db_data[i].name;
\end_layout

\begin_layout Verbatim
         if (att_name == "velocity")
\end_layout

\begin_layout Verbatim
         {
\end_layout

\begin_layout Verbatim
             if (prop_name == "min")
\end_layout

\begin_layout Verbatim
                 db_data[i] >>  vel_min;
\end_layout

\begin_layout Verbatim
             else if (att_name == "max")
\end_layout

\begin_layout Verbatim
                 db_data[i] >> vel_max;
\end_layout

\begin_layout Verbatim
         }
\end_layout

\begin_layout Verbatim
         else
\end_layout

\begin_layout Verbatim
         {
\end_layout

\begin_layout Verbatim
             if (prop_name == "min")
\end_layout

\begin_layout Verbatim
                 db_data[i] >> acc_min;
\end_layout

\begin_layout Verbatim
             else
\end_layout

\begin_layout Verbatim
                 db_data[i] >> acc_max;
\end_layout

\begin_layout Verbatim
         }
\end_layout

\begin_layout Verbatim
         i++;
\end_layout

\begin_layout Verbatim
     }
\end_layout

\begin_layout Verbatim
}
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void Database::put_device_attribute_property(string, DbData&)
\end_layout

\begin_layout Standard
\noindent
Insert or update a list of attribute properties for the specified device.
 The attribute property names and their values are specified by the vector
 of DbDatum structures.
 Use the insert operator >> to insert the properties into the DbDatum structures.
 Here is an example of how to insert/update properties 
\emph on
min
\emph default
, 
\emph on
max
\emph default
 for attribute 
\emph on
velocity
\emph default
 and properties 
\emph on
min
\emph default
, 
\emph on
max
\emph default
 for attribute 
\emph on
acceleration
\emph default
 of device 
\emph on
id11/motor/1
\emph default
 into the database using this method :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbDatum velocity("velocity"), vel_min("min"), vel_max("max");
\end_layout

\begin_layout Verbatim
\noindent
DbDatum acceleration("acceleration"), acc_min("min"), acc_max("max");
\end_layout

\begin_layout Verbatim
\noindent
DbData db_data;
\end_layout

\begin_layout Verbatim
\noindent
velocity << 2;
\end_layout

\begin_layout Verbatim
\noindent
vel_min << 0.0;
\end_layout

\begin_layout Verbatim
\noindent
vel_max << 1000000.0;
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(velocity);
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(vel_min);
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(vel_max);
\end_layout

\begin_layout Verbatim
\noindent
acceleration << 2;
\end_layout

\begin_layout Verbatim
\noindent
acc_min << 0.0;
\end_layout

\begin_layout Verbatim
\noindent
acc_max << 8000000;
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(acceleration);
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(acc_min);
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(acc_max);
\end_layout

\begin_layout Verbatim
\noindent
db->put_device_attribute_property(
\begin_inset Quotes eld
\end_inset

id11/motor/1
\begin_inset Quotes erd
\end_inset

, db_data);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void Database::delete_device_attribute_property(string, DbData&)
\end_layout

\begin_layout Standard
\noindent
Delete a list of attribute properties for the specified device.
 The attribute names are specified by the vector of DbDatum structures.
 Here is an example of how to delete the 
\emph on
unit
\emph default
 property of the 
\emph on
velocity
\emph default
 attribute of the 
\emph on
id11/motor/1
\emph default
 device using this method :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbData db_data;
\end_layout

\begin_layout Verbatim
db_data.push_back(DbDatum("velocity"));
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum("unit"));
\end_layout

\begin_layout Verbatim
\noindent
db->delete_device_attribute_property("id11/motor/1", db_data);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
vector<DbHistory> Database::get_device_attribute_property_history(string
 &devname, string &attname, string &propname)
\end_layout

\begin_layout Standard
Get the list of the last 10 modifications of the specifed device attribute
 property.
 Note that propname and attname can contain a wildcard character (eg: "prop*").
 An example of usage of a similar function can be found in the documentation
 of the get_property_history() function.
\end_layout

\begin_layout Standard
Exceptions: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
DbDatum Database::get_class_list(string &wildcard)
\end_layout

\begin_layout Standard
Query the database for a list of classes which match the specified wildcard.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string wildcard("Motor*");
\end_layout

\begin_layout Verbatim
DbDatum db_datum = db->get_class_list(wildcard);
\end_layout

\begin_layout Verbatim
vector<string> class_list;
\end_layout

\begin_layout Verbatim
db_datum >> class_list;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
DbDatum Database::get_class_property_list(string &classname)
\end_layout

\begin_layout Standard
Query the database for a list of properties defined for the specified class.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string classname("MyClass");
\end_layout

\begin_layout Verbatim
DbDatum db_datum = db->get_class_property_list(classname);
\end_layout

\begin_layout Verbatim
vector<string> prop_list;
\end_layout

\begin_layout Verbatim
db_datum >> prop_list;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
\noindent
void Database::get_class_property(string, DbData&)
\end_layout

\begin_layout Standard
\noindent
Query the database for a list of class properties.
 The property names are specified by the vector of DbDatum structures.
 The method returns the properties in the same DbDatum structures.
 To retrieve the properties use the extract operator >>.
 Here is an example of how to use the DbData type to specify and extract
 properties :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbData db_data;
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum("velocity"));
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum("acceleration"));
\end_layout

\begin_layout Verbatim
\noindent
db->get_class_property("StepperMotor", db_data);
\end_layout

\begin_layout Verbatim
\noindent
float velocity, acceleration;
\end_layout

\begin_layout Verbatim
\noindent
db_data[0] >> velocity;
\end_layout

\begin_layout Verbatim
\noindent
db_data[1] >> acceleration;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void Database::put_class_property(string, DbData&)
\end_layout

\begin_layout Standard
\noindent
Insert or update a list of properties for the specified class.
 The property names and their values are specified by the vector of DbDatum
 structures.
 Use the insert operator >> to insert the properties into the DbDatum structures.
 Here is an example of how to insert properties into the database using
 this method :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbDatum velocity("velocity"), acceleration("acceleration");
\end_layout

\begin_layout Verbatim
\noindent
DbData db_data;
\end_layout

\begin_layout Verbatim
\noindent
velocity << 100000.0;
\end_layout

\begin_layout Verbatim
\noindent
acceleration << 500000.0;
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(velocity);
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(acceleration);
\end_layout

\begin_layout Verbatim
\noindent
db->put_class_property("StepperMotor", db_data);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void Database::delete_class_property(string, DbData&)
\end_layout

\begin_layout Standard
\noindent
Delete a list of properties for the specified class.
 The property names are specified by the vector of DbDatum structures.
 Here is an example of how to delete properties from the database using
 this method :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbData db_data;
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum("velocity"));
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum("acceleration"));
\end_layout

\begin_layout Verbatim
\noindent
db->delete_class_property("StepperMotor", db_data);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
vector<DbHistory> Database::get_class_property_history(string &classname,
 string &propname)
\end_layout

\begin_layout Standard
Get the list of the last 10 modifications of the specifed class property.
 Note that propname can contain a wildcard character (eg: "prop*").
 An example of usage of a similar function can be found in the documentation
 of the get_property_history() function.
\end_layout

\begin_layout Standard
Exceptions: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
DbDatum Database::get_class_attribute_list(string &classname,string &wildcard)
\end_layout

\begin_layout Standard
Query the database for a list of attributes defined for the specified class
 which match the specified wildcard.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
string classname("MyClass");
\end_layout

\begin_layout Verbatim
string wildcard("*");
\end_layout

\begin_layout Verbatim
DbDatum db_datum = db->get_class_attribute_list(classname,wildcard);
\end_layout

\begin_layout Verbatim
vector<string> att_list;
\end_layout

\begin_layout Verbatim
db_datum >> att_list;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
Exception: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
\noindent
void Database::get_class_attribute_property(string, DbData&)
\end_layout

\begin_layout Standard
\noindent
Query the database for a list of class attribute properties for the specified
 object.
 The attribute names are specified by the vector of DbDatum structures.
 The method returns all the properties for the specified attributes.
 The attribute names are returned with the number of properties specified
 as their value.
 The first DbDatum element of the returned DbData vector contains the first
 attribute name and the first attribute property number.
 The following DbDatum element contains the first attribute property name
 and property values.
 To retrieve the properties use the extract operator >>.
 Here is an example of how to use the DbData type to specify and extract
 attribute properties :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbData db_data;
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum("velocity"));
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum("acceleration"));
\end_layout

\begin_layout Verbatim
\noindent
 
\end_layout

\begin_layout Verbatim
db->get_class_attribute_property("StepperMotor", db_data);
\end_layout

\begin_layout Verbatim
\noindent
 
\end_layout

\begin_layout Verbatim
\noindent
float vel_max, vel_min, acc_max, acc_min;
\end_layout

\begin_layout Verbatim
\noindent
 
\end_layout

\begin_layout Verbatim
for (int i=0; i< db_data.size(); i++)
\end_layout

\begin_layout Verbatim
\noindent
{
\end_layout

\begin_layout Verbatim
     long nb_prop;
\end_layout

\begin_layout Verbatim
     string &att_name = db_data[i].name;
\end_layout

\begin_layout Verbatim
     db_data[i] >> nb_prop;
\end_layout

\begin_layout Verbatim
     i++;
\end_layout

\begin_layout Verbatim
     for (int k=0;k < nb_prop;k++)
\end_layout

\begin_layout Verbatim
     {
\end_layout

\begin_layout Verbatim
         string &prop_name = db_data[i].name;
\end_layout

\begin_layout Verbatim
         if (att_name == "velocity")
\end_layout

\begin_layout Verbatim
         {
\end_layout

\begin_layout Verbatim
             if (prop_name == "min")
\end_layout

\begin_layout Verbatim
                 db_data[i] >>  vel_min;
\end_layout

\begin_layout Verbatim
             else if (att_name == "max")
\end_layout

\begin_layout Verbatim
                 db_data[i] >> vel_max;
\end_layout

\begin_layout Verbatim
         }
\end_layout

\begin_layout Verbatim
         else
\end_layout

\begin_layout Verbatim
         {
\end_layout

\begin_layout Verbatim
             if (prop_name == "min")
\end_layout

\begin_layout Verbatim
                 db_data[i] >> acc_min;
\end_layout

\begin_layout Verbatim
             else
\end_layout

\begin_layout Verbatim
                 db_data[i] >> acc_max;
\end_layout

\begin_layout Verbatim
         }
\end_layout

\begin_layout Verbatim
         i++;
\end_layout

\begin_layout Verbatim
     }
\end_layout

\begin_layout Verbatim
}
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void Database::put_class_attribute_property(string, DbData&)
\end_layout

\begin_layout Standard
\noindent
Insert or update a list of attribute properties for the specified class.
 The attribute property names and their values are specified by the vector
 of DbDatum structures.
 Use the insert operator >> to insert the properties into the DbDatum structures.
 Here is an example of how to insert/update 
\emph on
min
\emph default
, 
\emph on
max
\emph default
 properties for attribute 
\emph on
velocity
\emph default
 and 
\emph on
min
\emph default
, 
\emph on
max
\emph default
 properties for attribute 
\emph on
acceleration
\emph default
 properties belonging to class 
\emph on
StepperMotor
\emph default
 into the database using this method :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbDatum velocity("velocity"), vel_min("min"), vel_max("max");
\end_layout

\begin_layout Verbatim
\noindent
DbDatum acceleration("acceleration"), acc_min("min"), acc_max("max");
\end_layout

\begin_layout Verbatim
\noindent
DbData db_data;
\end_layout

\begin_layout Verbatim
\noindent
velocity << 2;
\end_layout

\begin_layout Verbatim
\noindent
vel_min << 0.0;
\end_layout

\begin_layout Verbatim
\noindent
vel_max << 1000000.0;
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(velocity);
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(vel_min);
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(vel_max);
\end_layout

\begin_layout Verbatim
\noindent
acceleration << 2;
\end_layout

\begin_layout Verbatim
\noindent
acc_min << 0.0;
\end_layout

\begin_layout Verbatim
\noindent
acc_max << 8000000;
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(acceleration);
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(acc_min);
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(acc_max);
\end_layout

\begin_layout Verbatim
\noindent
db->put_class_attribute_property("StepperMotor", db_data);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void Database::delete_class_attribute_property(string, DbData&)
\end_layout

\begin_layout Standard
\noindent
Delete a list of attribute properties for the specified class.
 The attribute names are specified by the vector of DbDatum structures.
 All properties belonging to the listed attributes are deleted.
 Here is an example of how to delete the 
\emph on
unit
\emph default
 property of the 
\emph on
velocity
\emph default
 attribute of the 
\emph on
StepperMotor
\emph default
 class from the database using this method :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbData db_data;
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum("velocity"));
\end_layout

\begin_layout Verbatim
\noindent
db_data.push_back(DbDatum("unit"));
\end_layout

\begin_layout Verbatim
\noindent
db->delete_class_attribute_property("StepperMotor", db_data);
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
vector<DbHistory> Database::get_class_attribute_property_history(string
 &devname, string &attname, string &propname)
\end_layout

\begin_layout Standard
Get the list of the last 10 modifications of the specifed class attribute
 property.
 Note that propname and attname can contain a wildcard character (eg: "prop*").
 An example of usage of a similar function can be found in the documentation
 of the get_property_history() function.
\end_layout

\begin_layout Standard
Exceptions: ConnectionFailed, CommunicationFailed, DevFailed from device
\end_layout

\begin_layout Subsection
void Database::get_alias(string dev_name, string &dev_alias)
\end_layout

\begin_layout Standard
Get the device alias name from its name.
 The device name is specified by 
\emph on
dev_name
\emph default
 and the device alias name is returned in 
\emph on
dev_alias
\emph default
.
 If there is no alias defined for the device, a DevFailed exception is thrown.
\end_layout

\begin_layout Standard

\emph on
Exceptions: ConnectionFailed, CommunicationFailed, DevFailed from device
 (DB_AliasNotDefined)
\end_layout

\begin_layout Subsection
void Database::get_device_alias(string dev_alias, string &dev_name)
\end_layout

\begin_layout Standard
\noindent
Get the device name from an alias.
 The device alias is specified by 
\emph on
dev_alias
\emph default
 and the device name is returned in 
\emph on
dev_name
\emph default
.
 If there is no device with the given alias, a DevFailed exception is thrown.
\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_DeviceNotDefine
d)
\end_layout

\begin_layout Subsection
void Database::get_attribute_alias(string attr_alias, string &attr_name)
\end_layout

\begin_layout Standard
\noindent
Get the full attribute name from an alias.
 The attribute alias is specified by 
\emph on
attr_alias
\emph default
 and the full attribute name is returned in 
\emph on
attr_name
\emph default
.
 If there is no attribute with the given alias, a DevFailed exception is
 thrown.
\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
void Database::put_attribute_alias(string &att_name, string &alias_name)
\end_layout

\begin_layout Standard
Set an alias for an attribute name.
 The attribute alias is specified by alias_name and the attribute name is
 specifed by att_name.
 If the given alias already exists, a DevFailed exception is thrown.
\end_layout

\begin_layout Standard
Exceptions: ConnectionFailed, CommunicationFailed, DevFailed from device
 (DB_SQLError)
\end_layout

\begin_layout Subsection
void Database::delete_attribute_alias(string &alias_name)
\end_layout

\begin_layout Standard
Remove the alias associated to an attribute name.
\end_layout

\begin_layout Standard
Exceptions: ConnectionFailed, CommunicationFailed, DevFailed from device
 (DB_SQLError)
\end_layout

\begin_layout Subsection
DbDatum Database::get_device_alias_list(string &filter)
\end_layout

\begin_layout Standard
\noindent
Get device alias list.
 The parameter 
\emph on
alias
\emph default
 is a string to filter the alias list returned.
 Wildcard (*) is supported.
 For instance, if the string alias passed as the method parameter is initialised
 with only the * character, all the defined device alias will be returned.
 The DbDatum returned by this method is initialised with an array of strings
 and must be extracted into a vector<string>.
 If there is no alias with the given filter, the returned array will have
 a 0 size.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbData db_data;
\end_layout

\begin_layout Verbatim
string filter("*");
\end_layout

\begin_layout Verbatim
\noindent

\end_layout

\begin_layout Verbatim
\noindent
db_data = db->get_device_alias_list(filter);
\end_layout

\begin_layout Verbatim
vector<string> al_list;
\end_layout

\begin_layout Verbatim
db_data >> al_list;
\end_layout

\begin_layout Verbatim
cout << al_list.size() << " device alias defined in db" << endl;
\end_layout

\begin_layout Verbatim
for (int i=0;i < al_list.size();i++)
\end_layout

\begin_layout Verbatim
    cout << "alias = " << al_list[i] << endl;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
DbDatum Database::get_attribute_alias_list(string &filter)
\end_layout

\begin_layout Standard
\noindent
Get attribute alias list.
 The parameter 
\emph on
alias
\emph default
 is a string to filter the alias list returned.
 Wildcard (*) is supported.
 For instance, if the string alias passed as the method parameter is initialised
 with only the * character, all the defined attribute alias will be returned.
 The DbDatum returned by this method is initialised with an array of strings
 and must be extracted into a vector<string>.
 If there is no alias with the given filter, the returned array will have
 a 0 size.
\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
void Database::put_device_alias(string &dev_name,string &alias_name)
\end_layout

\begin_layout Standard
\noindent
Create a device alias.
 Alias name has to be uniq within a Tango control system and you will receive
 an exception if the alias is already defined.
\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
void Database::delete_device_alias(string &alias_name)
\end_layout

\begin_layout Standard
\noindent
Delete a device alias.
\end_layout

\begin_layout Standard
\noindent

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Section
\noindent
Tango::DbDevice
\end_layout

\begin_layout Standard
\noindent
A database object for a device which can be used to query or modify properties,
 import and export information for a device.
 This class provides an easy to use interface for device objects in the
 database.
 It uses the methods of the Database class therefore the reader is referred
 to these for the exact calling syntax and examples.
 The following methods are defined for the DbDevice class :
\end_layout

\begin_layout Subsection
\noindent
DbDevice::DbDevice(string &)
\end_layout

\begin_layout Standard
\noindent
A constructor for a DbDevice object for a device in the TANGO database specified
 by the TANGO_HOST environment variable.
 
\end_layout

\begin_layout Subsection
\noindent
DbDevice::DbDevice(string &, Database *)
\end_layout

\begin_layout Standard
\noindent
A constructor for a DbDevice object for the device in the specified database.
 This method reuses the Database supplied by the programmer.
\end_layout

\begin_layout Subsection
\noindent
DbDevImportInfo DbDevice::import_device()
\end_layout

\begin_layout Standard
\noindent
Query the database for the import info of this device.
 Returns a DbDevImportInfo structure.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void DbDevice::export_device(DbDevExportInfo&)
\end_layout

\begin_layout Standard
\noindent
Update the export info for this device in the database.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void DbDevice::add_device(DbDevInfo&)
\end_layout

\begin_layout Standard
\noindent
Add/Update this device to the database.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void DbDevice::delete_device()
\end_layout

\begin_layout Standard
\noindent
Delete this device from the database.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void DbDevice::get_property(DbData&)
\end_layout

\begin_layout Standard
\noindent
Query the database for the list of properties of this device.
 See Database::get_device_property() for an example of how to specify and
 retrieve the properties.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void DbDevice::put_property(DbData&)
\end_layout

\begin_layout Standard
\noindent
Update the list of properties for this device in the database.
 See Database::put_device_property() for an example of how to specify the
 properties.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void DbDevice::delete_property(DbData&)
\end_layout

\begin_layout Standard
\noindent
Delete the list of specified properties for this device in the database.
 See Database::delete_property() for an example of how to specify the properties.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void DbDevice::get_attribute_property(DbData&)
\end_layout

\begin_layout Standard
\noindent
Query the database for the list of attribute properties of this device.
 See Database::get_device_attribute_property() for an example of how to
 specify and retrieve the properties.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void DbDevice::put_attribute_property(DbData&)
\end_layout

\begin_layout Standard
\noindent
Update the list of attribute properties for this device in the database.
 See Database::put_device_attribute_property() for an example of how to
 specify the properties.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void DbDevice::delete_attribute_property(DbData&)
\end_layout

\begin_layout Standard
\noindent
Delete all properties for the list of specified attributes for this device
 in the database.
 See Database::delete_device_attribute_property() for an example of how
 to specify the properties.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Section
\noindent
Tango::DbClass
\end_layout

\begin_layout Standard
\noindent
A database object for a class which can be used to query or modify class
 properties.
\end_layout

\begin_layout Subsection
\noindent
DbClass::DbClass(string)
\end_layout

\begin_layout Standard
\noindent
A constructor for a DbClass object for a class in the TANGO database specified
 by the TANGO_HOST environment variable.
 
\end_layout

\begin_layout Subsection
\noindent
DbClass::DbClass(string, Database *)
\end_layout

\begin_layout Standard
\noindent
A constructor for a DbClass object for the class in the specified database.
 This method reuses the Database supplied by the programmer.
\end_layout

\begin_layout Subsection
\noindent
void DbClass::get_property(DbData&)
\end_layout

\begin_layout Standard
\noindent
Query the database for the list of properties of this class.
 See Database::get_class_property() for an example of how to specify and
 retrieve the properties.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void DbClass::put_property(DbData&)
\end_layout

\begin_layout Standard
\noindent
Update the list of properties for this class in the database.
 See Database::put_class_property() for an example of how to specify the
 properties.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void DbClass::delete_property(DbData&)
\end_layout

\begin_layout Standard
\noindent
Delete the list of specified properties for this class in the database.
 See Database::delete_property() for an example of how to specify the properties.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void DbClass::get_attribute_property(DbData&)
\end_layout

\begin_layout Standard
\noindent
Query the database for the list of attribute properties of this class.
 See Database::get_class_attribute_property() for an example of how to specify
 and retrieve the properties.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void DbClass::put_attribute_property(DbData&)
\end_layout

\begin_layout Standard
\noindent
Update the list of attribute properties for this class in the database.
 See Database::put_class_attribute_property() for an example of how to specify
 the properties.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
\noindent
void DbClass::delete_attribute_property(DbData&)
\end_layout

\begin_layout Standard
\noindent
Delete all properties for the list of specified attributes for this class
 in the database.
 See Database::delete_class_attribute_property() for an example of how to
 specify the properties.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Section
Tango::DbServer
\end_layout

\begin_layout Standard
\noindent
A database object for a device server which can be used to query or modify
 server database information.
\end_layout

\begin_layout Subsection
\noindent
DbServer::DbServer(string)
\end_layout

\begin_layout Standard
\noindent
A constructor for a DbServer object for a server in the TANGO database specified
 by the TANGO_HOST environment variable.
\end_layout

\begin_layout Subsection
\noindent
DbServer::DbServer(string, Database *)
\end_layout

\begin_layout Standard
\noindent
A constructor for a DbServer object for the server in the specified database.
 This method reuses the Database supplied by the programmer.
\end_layout

\begin_layout Subsection
\noindent
void DbServer::add_server(DbDevInfos &)
\end_layout

\begin_layout Standard
Add a group of devices to the database.
 The device names, server names and classes are specified in the vector
 of DbDevInfo structures.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
void DbServer::delete_server()
\end_layout

\begin_layout Standard
Delete the device server and its associated devices from the database.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
void DbServer::export_server(DbDevExportInfos &)
\end_layout

\begin_layout Standard
Export a group of device to the database.
 The device names, IOR, class, server name, pid etc.
 are specified in the vector of DbDevExportInfo structures.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Subsection
void DbServer::unexport_server()
\end_layout

\begin_layout Standard
Mark all the devices exported by the server as un exported.
\end_layout

\begin_layout Standard

\emph on
Exceptions
\emph default
: 
\emph on
ConnectionFailed, CommunicationFailed, DevFailed from device (DB_SQLError)
\end_layout

\begin_layout Section
\noindent
Tango::DbDatum
\end_layout

\begin_layout Standard
\noindent
A single database value which has a name, type, address and value and methods
 for inserting and extracting C++ native types.
 This is the fundamental type for specifying database properties.
 Every property has a name and has one or more values associated with it.
 The values can be inserted and extracted using the operators << and >>
 respectively.
 A status flag indicates if there is data in the DbDatum object or not.
 An additional flag allows the user to activate exceptions.
 
\end_layout

\begin_layout Subsection
\noindent
Operators
\end_layout

\begin_layout Standard
\noindent
The insert and extract operators are specified for the following C++ types
 :
\end_layout

\begin_layout Enumerate
\noindent
boolean
\end_layout

\begin_layout Enumerate
unsigned char
\end_layout

\begin_layout Enumerate
\noindent
short
\end_layout

\begin_layout Enumerate
\noindent
unsigned short
\end_layout

\begin_layout Enumerate
\noindent
DevLong
\end_layout

\begin_layout Enumerate
\noindent
DevULong
\end_layout

\begin_layout Enumerate
DevLong64
\end_layout

\begin_layout Enumerate
DevULong64
\end_layout

\begin_layout Enumerate
\noindent
float
\end_layout

\begin_layout Enumerate
\noindent
double
\end_layout

\begin_layout Enumerate
\noindent
string
\end_layout

\begin_layout Enumerate
\noindent
char* (insert only)
\end_layout

\begin_layout Enumerate
\noindent
const char *
\end_layout

\begin_layout Enumerate
\noindent
vector<string>
\end_layout

\begin_layout Enumerate
\noindent
vector<short>
\end_layout

\begin_layout Enumerate
\noindent
vector<unsigned short>
\end_layout

\begin_layout Enumerate
\noindent
vector<DevLong>
\end_layout

\begin_layout Enumerate
vector<DevULong>
\end_layout

\begin_layout Enumerate
vector<DevLong64>
\end_layout

\begin_layout Enumerate
vector<DevULong64>
\end_layout

\begin_layout Enumerate
\noindent
vector<float>
\end_layout

\begin_layout Enumerate
\noindent
vector<double>
\end_layout

\begin_layout Standard
\noindent
Here is an example of creating, inserting and extracting some DbDatum types
 :
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
DbDatum my_short("my_short"), my_long(
\begin_inset Quotes eld
\end_inset

my_long
\begin_inset Quotes erd
\end_inset

), my_string("my_string");
\end_layout

\begin_layout Verbatim
\noindent
DbDatum my_float_vector("my_float_vector"), my_double_vector("my_double_vector")
;
\end_layout

\begin_layout Verbatim
\noindent
string a_string;
\end_layout

\begin_layout Verbatim
\noindent
short a_short;
\end_layout

\begin_layout Verbatim
\noindent
DevLong a_long;
\end_layout

\begin_layout Verbatim
\noindent
vector<float> a_float_vector;
\end_layout

\begin_layout Verbatim
\noindent
vector<double> a_double_vector;
\end_layout

\begin_layout Verbatim
\noindent
my_short << 100; // insert a short
\end_layout

\begin_layout Verbatim
\noindent
my_short >> a_short; // extract a short
\end_layout

\begin_layout Verbatim
\noindent
my_long << 1000; // insert a DevLong
\end_layout

\begin_layout Verbatim
\noindent
my_long >> a_long; // extract a long
\end_layout

\begin_layout Verbatim
\noindent
my_string << string("estas lista a bailar el tango ?"); // insert a string
\end_layout

\begin_layout Verbatim
\noindent
my_string >> a_string; // extract a string
\end_layout

\begin_layout Verbatim
\noindent
my_float_vector << a_float_vector // insert a vector of floats
\end_layout

\begin_layout Verbatim
\noindent
my_float_vector >> a_float_vector; // extract a vector of floats
\end_layout

\begin_layout Verbatim
\noindent
my_double_vector << a_double_vector; // insert a vector of doubles
\end_layout

\begin_layout Verbatim
\noindent
my_double_vector >> a_double_vector; // extract a vector of doubles
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: WrongData if requested
\end_layout

\begin_layout Subsection
\noindent
bool DbDatum::is_empty()
\end_layout

\begin_layout Standard
\noindent
is_empty() is a boolean method which trues true or false depending on whether
 the DbDatum object contains data or not.
 It can be used to test whether a property is defined in the database or
 not e.g.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
sl_props.push_back(parity_prop);
\end_layout

\begin_layout Verbatim
\noindent
dbase->get_device_property(device_name, sl_props);
\end_layout

\begin_layout Verbatim
\noindent
if (! parity_prop.is_empty()) 
\end_layout

\begin_layout Verbatim
\noindent
{
\end_layout

\begin_layout Verbatim
\noindent
    parity_prop >> parity;
\end_layout

\begin_layout Verbatim
\noindent
}
\end_layout

\begin_layout Verbatim
\noindent
else
\end_layout

\begin_layout Verbatim
\noindent
{
\end_layout

\begin_layout Verbatim
\noindent
    cout << device_name << " has no parity defined in database !" << endl;
\end_layout

\begin_layout Verbatim
\noindent
}
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Exception: WrongData if requested
\end_layout

\begin_layout Subsection
\noindent
void DbDatum::exceptions(bitset<DbDatum::numFlags>)
\end_layout

\begin_layout Standard
\noindent
Is a method which allows the user to switch on/off exception throwing for
 trying to extract data from an empty DbDatum object.
 The default is to not throw exception.
 The following flags are supported :
\end_layout

\begin_layout Enumerate
\noindent

\series bold
isempty_flag
\series default
 - throw a WrongData exception (reason = API_EmptyDbDatum) if user tries
 to extract data from an empty DbDatum object
\end_layout

\begin_layout Enumerate

\series bold
wrongtype_flag
\series default
 - throw a WrongData exception (reason = API_IncompatibleArgumentType) if
 user tries to extract data with a type different than the type used for
 insertion
\end_layout

\begin_layout Subsection
bitset<DbDatum::numFlags> exceptions()
\end_layout

\begin_layout Standard
Returns the whole exception flags.
\end_layout

\begin_layout Subsection
void DbDatum::reset_exceptions(DbDatum::except_flags fl)
\end_layout

\begin_layout Standard
Resets one exception flag
\end_layout

\begin_layout Subsection
void DbDatum::set_exceptions(DbDatum::except_flags fl)
\end_layout

\begin_layout Standard
Sets one exception flag
\end_layout

\begin_layout Standard
The following is an example of how to use these exceptions related methods
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
     1  DbDatum da;
\end_layout

\begin_layout Verbatim
     2  
\end_layout

\begin_layout Verbatim
     3  bitset<DbDatum::numFlags> bs = da.exceptions();
\end_layout

\begin_layout Verbatim
     4  cout << "bs = " << bs << endl;
\end_layout

\begin_layout Verbatim
     5                  
\end_layout

\begin_layout Verbatim
     6  da.set_exceptions(DbDatum::wrongtype_flag);
\end_layout

\begin_layout Verbatim
     7  bs = da.exceptions();
\end_layout

\begin_layout Verbatim
     8                  
\end_layout

\begin_layout Verbatim
     9  cout << "bs = " << bs << endl;
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Section
\noindent
Tango::DbData
\end_layout

\begin_layout Standard
\noindent
A vector of Tango::DbDatum structures.
 DbData is used to send or return one or more database properties or information.
 It is the standard input and output type for all methods which query and/or
 update properties in the database.
\end_layout

\begin_layout Section
Exception
\begin_inset CommandInset label
LatexCommand label
name "sec:Exception"

\end_inset


\end_layout

\begin_layout Standard
All the exception thrown by this API are Tango::DevFailed exception.
 This exception is a variable length array of Tango::DevError type.
 The Tango::DevError type is a four fields structure.
 These fields are :
\end_layout

\begin_layout Enumerate
A string describing the error type.
 This string replaces an error code and allows a more easy management of
 include files.
 This field is called 
\series bold
reason
\end_layout

\begin_layout Enumerate
A string describing in plain text the reason of the error.
 This field is called 
\series bold
desc
\end_layout

\begin_layout Enumerate
A string giving the name of the method which thrown the exception.
 This field is named 
\series bold
origin
\end_layout

\begin_layout Enumerate
The error severity.
 This is an enumeration with three values which are WARN, ERR or PANIC.
 Its name is 
\series bold
severity
\end_layout

\begin_layout Standard
This is a variable length array in order to transmit to the client what
 is the primary error reason.
 The sequence element 0 describes the primary error.
 An exception class hierarchy has been implemented within the API to ease
 API programmers task.
 All the exception classes inherits from the Tango::DevFailed class.
 Except for the 
\emph on
NamedDevFaildeList
\emph default
 exception class, they don't add any new fields to the exception, they just
 allow easy "catching".
 Exception classes thrown only by the API layer are :
\end_layout

\begin_layout Itemize
ConnectionFailed
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ConnectionFailed
\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
CommunicationFailed
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
CommunicationFailed
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
WrongNameSyntax
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
WrongNameSyntax
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
NonDbDevice
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
NonDbDevice
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
WrongData
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
WrongData
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
NonSupportedFeature
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
NonSupportedFeature
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
AsynCall
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
AsynCall
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
AsynReplyNotArrived
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
AsynReplyNotArrived
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
EventSystemFailed
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
EventSystemFailed
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
NamedDevFailedList
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
NamedDevFailedList
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
DeviceUnlocked
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
DeviceUnlocked
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On top of these classes, exception thrown by the device (Tango::DevFailed
 exception) are directly passed to the client.
\end_layout

\begin_layout Subsection
The ConnectionFailed exception
\end_layout

\begin_layout Standard
This exception is thrown when a problem occurs during the connection establishme
nt between the application and the device.
 The API is stateless.
 This means that DeviceProxy constructors filter most of the exception except
 for cases described in the following table.
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.3cm
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="37" columns="5">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Method name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
device type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
error type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Level
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
reason
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TANGO_HOST not set
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_TangoHostNotSet
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
with
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Device not defined in db
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DB_DeviceNotDefined
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 database
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
or
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CommandFailed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DeviceProxy
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Alias not defined in db
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_DeviceNotDefined
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
constructor
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
with database
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Database server
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CorbaException
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
specified in dev name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not running
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CantConnectToDatabase
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
without
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Server running but device
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CorbaException
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
database
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not defined in server
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_DeviceNotExported
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TANGO_HOST not set
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_TangoHostNotSet
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DB_DeviceNotDefined
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Device not defined in db
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CommandFailed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AttributeProxy
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
with
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_DeviceNotDefined
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
constructor
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
database
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DB_SQLError
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Alias not defined in db
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CommandFailed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_AliasNotDefined
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
with database
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Database server
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CorbaException
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
specified in dev name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not running
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CantConnectToDatabase
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DeviceProxy
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
without
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Server not
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CorbaException
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
or
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
database
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
running
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_ServerNotRunning
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AttributeProxy
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Server not running
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_DeviceNotExported
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
method call
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
with
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dead 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CorbaException
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(except
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
database
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
server
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CantConnectToDevice
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cmd_inout
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dead database server
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CorbaException
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
read_attribute)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
when reconnection needed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CantConnectToDatabase
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
without
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Server
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CorbaException
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DeviceProxy
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
database
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_ServerNotRunning
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cmd_inout 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
running
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CommandFailed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
and
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Server 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_DeviceNotExported
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
read_attribute
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not running
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CommandFailed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CorbaException
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
or
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
with
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dead
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CantConnectToDevice
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AttributeProxy
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
database
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
server
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CommandFailed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
read
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
or API_AttributeFailed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
and
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dead database
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CorbaException
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
write
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
server when reconnection
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CantConnectToDatabase
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
needed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CommandFailed
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.3cm
\end_inset


\end_layout

\begin_layout Standard
The desc DevError structure field allows a user to get more precise information.
 These informations are :
\end_layout

\begin_layout Description
DB_DeviceNotDefined The name of the device not defined in the database
\end_layout

\begin_layout Description
API_CommandFailed The device and command name
\end_layout

\begin_layout Description
API_CantConnectToDevice The device name
\end_layout

\begin_layout Description
API_CorbaException The name of the CORBA exception, its reason, its locality,
 its completed flag and its minor code
\end_layout

\begin_layout Description
API_CantConnectToDatabase The database server host and its port number
\end_layout

\begin_layout Description
API_DeviceNotExported The device name
\end_layout

\begin_layout Subsection
The CommunicationFailed exception
\end_layout

\begin_layout Standard
This exception is thrown when a communication problem is detected during
 the communication between the client application and the device server.
 It is a two levels Tango::DevError structure.
 In case of time-out, the DevError structures fields are:
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.3cm
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="4">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Level
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reason
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Severity
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CorbaException
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CORBA exception fields translated into a string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ERR
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_DeviceTimedOut
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String with time-out value and device name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ERR
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.3cm
\end_inset


\end_layout

\begin_layout Standard
For all other communication errors, the DevError structures fields are:
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.3cm
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="4">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="block" valignment="middle" width="60mm">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Level
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reason
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Severity
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CorbaException
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CORBA exception fields translated into a string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ERR
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
API_CommunicationFailed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String with device, method, command/attribute name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ERR
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.3cm
\end_inset


\end_layout

\begin_layout Subsection
The WrongNameSyntax exception
\end_layout

\begin_layout Standard
This exception has only one level of Tango::DevError structure.
 The possible value for the reason field are :
\end_layout

\begin_layout Description
API_UnsupportedProtocol This error occurs when trying to build a DeviceProxy
 or an AttributeProxy instance for a device with an unsupported protocol.
 Refer to the appendix on device naming syntax to get the list of supported
 database modifier
\end_layout

\begin_layout Description
API_UnsupportedDBaseModifier This error occurs when trying to build a DeviceProx
y or an AttributeProxy instance for a device/attribute with a database modifier
 unsupported.
 Refer to the appendix on device naming syntax to get the list of supported
 database modifier
\end_layout

\begin_layout Description
API_WrongDeviceNameSyntax This error occurs for all the other error in device
 name syntax.
 It is thrown by the DeviceProxy class constructor.
\end_layout

\begin_layout Description
API_WrongAttributeNameSyntax This error occurs for all the other error in
 attribute name syntax.
 It is thrown by the AttributeProxy class constructor.
\end_layout

\begin_layout Description
API_WrongWildcardUsage This error occurs if there is a bad usage of the
 wildcard character
\end_layout

\begin_layout Subsection
The NonDbDevice exception
\end_layout

\begin_layout Standard
This exception has only one level of Tango::DevError structure.
 The reason field is set to API_NonDatabaseDevice.
 This exception is thrown by the API when using the DeviceProxy or AttributeProx
y class database access for non-database device.
\end_layout

\begin_layout Subsection
The WrongData exception
\end_layout

\begin_layout Standard
This exception has only one level of Tango::DevError structure.
 The possible value for the reason field are :
\end_layout

\begin_layout Description
API_EmptyDbDatum This error occurs when trying to extract data from an empty
 DbDatum object
\end_layout

\begin_layout Description
API_IncompatibleArgumentType This error occurs when trying to extract data
 with a type different than the type used to send the data
\end_layout

\begin_layout Description
API_EmptyDeviceAttribute This error occurs when trying to extract data from
 an empty DeviceAttribute object
\end_layout

\begin_layout Description
API_IncompatibleAttrArgumentType This error occurs when trying to extract
 attribute data with a type different than the type used to send the data
\end_layout

\begin_layout Description
API_EmptyDeviceData This error occurs when trying to extract data from an
 empty DeviceData object
\end_layout

\begin_layout Description
API_IncompatibleCmdArgumentType This error occurs when trying to extract
 command data with a type different than the type used to send the data
\end_layout

\begin_layout Subsection
The NonSupportedFeature exception
\end_layout

\begin_layout Standard
This exception is thrown by the API layer when a request to a feature implemente
d in Tango device interface release n is requested for a device implementing
 Tango device interface n-x.
 There is one possible value for the reason field which is API_UnsupportedFeatur
e.
\end_layout

\begin_layout Subsection
The AsynCall exception
\end_layout

\begin_layout Standard
This exception is thrown by the API layer when a the asynchronous model
 id badly used.
 This exception has only one level of Tango::DevError structure.
 The possible value for the reason field are :
\end_layout

\begin_layout Description
API_BadAsynPollId This error occurs when using an asynchronous request identifie
r which is not valid any more.
\end_layout

\begin_layout Description
API_BadAsyn This error occurs when trying to fire callback when no callback
 has been previously registered
\end_layout

\begin_layout Description
API_BadAsynReqType This error occurs when trying to get result of an asynchronou
s request with an asynchronous request identifier returned by a non-coherent
 asynchronous request (For instance, using the asynchronous request identifier
 returned by a 
\emph on
command_inout_asynch()
\emph default
 method with a 
\emph on
read_attribute_reply()
\emph default
 attribute).
\end_layout

\begin_layout Subsection
The AsynReplyNotArrived exception
\end_layout

\begin_layout Standard
This exception is thrown by the API layer when:
\end_layout

\begin_layout Itemize
a request to get asynchronous reply is made and the reply is not yet arrived
\end_layout

\begin_layout Itemize
a blocking wait with timeout for asynchronous reply is made and the timeout
 expired.
\end_layout

\begin_layout Standard
There is one possible value for the reason field which is API_AsynReplyNotArrive
d.
\end_layout

\begin_layout Subsection
The EventSystemFailed exception
\end_layout

\begin_layout Standard
This exception is thrown by the API layer when subscribing or unsubscribing
 from an event failed.
 This exception has only one level of Tango::DevError structure.
 The possible value for the reason field are :
\end_layout

\begin_layout Description
API_NotificationServiceFailed This error occurs when the 
\emph on
subscribe_event()
\emph default
 method failed trying to access the CORBA notification service
\end_layout

\begin_layout Description
API_EventNotFound This error occurs when you are using an incorrect event_id
 in the 
\emph on
unsubscribe_event()
\emph default
 method
\end_layout

\begin_layout Description
API_InvalidArgs This error occurs when NULL pointers are passed to the subscribe
 or unsubscribe event methods
\end_layout

\begin_layout Description
API_MethodArgument This error occurs when trying to subscribe to an event
 which has already been subsribed to
\end_layout

\begin_layout Description
API_DSFailedRegisteringEvent This error means that the device server to
 which the device belongs to failed when it tries to register the event.
 Most likely, it means that there is no event property defined
\end_layout

\begin_layout Description
API_EventNotFound Occurs when using a wrong event identifier in the 
\emph on
unsubscribe_event
\emph default
 method
\end_layout

\begin_layout Subsection
The NamedDevFailedList
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
NamedDevFailedList
\end_layout

\end_inset

 exception
\begin_inset CommandInset label
LatexCommand label
name "sub:The-NamedDevFailedList-exception"

\end_inset


\end_layout

\begin_layout Standard
This exception is only thrown by the 
\emph on
DeviceProxy::write_attributes()
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
write-attributes
\end_layout

\end_inset


\emph default
 method.
 In this case, it is necessary to have a new class of exception to transfer
 the error stack for several attribute(s) which failed during the writing.
 Therefore, this exception class contains for each attributes which failed
 :
\end_layout

\begin_layout Itemize
The name of the attribute
\end_layout

\begin_layout Itemize
Its index in the vector passed as argumen tof the write_attributes() method
\end_layout

\begin_layout Itemize
The error stack as described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Exception"

\end_inset


\end_layout

\begin_layout Subsubsection
long NamedDevFailedList::get_faulty_attr_nb()
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
get-faulty-attr-nb
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Returns the number of attributes which failed during the write_attribute
 call.
\end_layout

\begin_layout Subsubsection
vector<NamedDevFailed> NamedDevErrorList::err_list
\end_layout

\begin_layout Standard
Public data member of the NamedDevFailedList.
 There is one element in this vector for each attribute which failed during
 its writing.
\end_layout

\begin_layout Subsubsection
string NamedDevFailed::name
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
NamedDevFailed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Public data member of the NamedDevFailed class.
 It contains the name of the attribute which failed.
\end_layout

\begin_layout Subsubsection
long NamedDevFailed::idx_in_call
\end_layout

\begin_layout Standard
Public data member of the NamedDevFailed class.
 It contains the index in the write_attributes method parameter vector of
 the attribute which failed.
\end_layout

\begin_layout Subsubsection
DevErrorList NamedDevFailed::err_stack
\end_layout

\begin_layout Standard
Public data member of the NamedDevFailed class.
 This is the error stack.
\end_layout

\begin_layout Standard
The following piece of code is an example of how to use this class exception
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Verbatim
\noindent
catch (Tango::NamedDevFailed &e)
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
   long nb_faulty = e.get_faulty_attr_nb();
\end_layout

\begin_layout Verbatim
   for (long i = 0;i < nb_faulty;i++)
\end_layout

\begin_layout Verbatim
   {
\end_layout

\begin_layout Verbatim
       cout << "Attribute " << e.err_list[i].name << " failed!" << endl;
\end_layout

\begin_layout Verbatim
       for (long j = 0;j < e.err_list[i].err_stack.length();j++)
\end_layout

\begin_layout Verbatim
       {
\end_layout

\begin_layout Verbatim
           cout << "Reason [" << j << "] = " << e.err_list[i].err_stack[j].reason;
\end_layout

\begin_layout Verbatim
           cout << "Desc [" << j << "] = " << e.err_list[i].err_stack[j].desc;
\end_layout

\begin_layout Verbatim
       }
\end_layout

\begin_layout Verbatim
   }
\end_layout

\begin_layout Verbatim
}
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "line.tex"

\end_inset


\end_layout

\begin_layout Standard
This exception inherits from Tango::DevFailed.
 It is possible to catch it with a "catch DevFailed" catch block.
 In this case, like any other DevFailed exception, there is only one error
 stack.
 This stack is initialised with the name of all the attributes which failed
 in its "reason" field.
\end_layout

\begin_layout Subsection
The DeviceUnlocked
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
DeviceUnlocked
\end_layout

\end_inset

 exception
\end_layout

\begin_layout Standard
This exception is thrown by the API layer when a device locked by the process
 has been unlocked by an admin client.
 This exception has two levels of Tango::DevError structure.
 There is only possible value for the reason field which is
\end_layout

\begin_layout Description
API_DeviceUnlocked The device has been unlocked by another client (administratio
n client)
\end_layout

\begin_layout Standard
The first level is the message reported by the Tango kernel from the server
 side.
 The second layer is added by the client API layer with informations on
 which API call generates the exception and device name.
\end_layout

\begin_layout Section
Reconnection and exception
\begin_inset CommandInset label
LatexCommand label
name "sec:Reconnection-and-exception"

\end_inset


\end_layout

\begin_layout Standard
The Tango API automatically manages re-connection between client and server
 in case of communication error during a network access between a client
 and a server.
 The transparency reconnection mode allows a user to be (or not be) informed
 that automatic reconnection took place.
 If the transparency reconnection mode is not set, when a communication
 error occurs, an exception is returned to the caller and the connection
 is internally marked as bad.
 On the next try to contact the device, the API will try to re-build the
 network connection.
 If the transparency reconnection mode is set, the API will try to re-build
 the network connection has soon as the communication error occurs and the
 caller is not informed.
 Several cases are possible.
 They are summarized in the following table:
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.3cm
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="5">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0pt">
<column alignment="block" valignment="middle" width="45mm">
<column alignment="center" valignment="top" width="0pt">
<column alignment="block" valignment="middle" width="35mm">
<column alignment="block" valignment="middle" width="35mm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Case
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Server state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
call nb
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
exception (transparency false)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
exception (transparency true)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Server killed before call n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CommunicationFailed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ConnectionFailed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Server killed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
down
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n+1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ConnectionFailed(2 levels)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
idem
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
and re-started
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
down
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n + 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
idem
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
idem
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Running
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n + x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No exception
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No exception
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Server died before call n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CommunicationFailed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ConnectionFailed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Server died
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
died
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n + 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ConnectionFailed (3 levels)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
idem
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
and re-started
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
died
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n + 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
idem
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
idem
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Running
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n + x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No exception
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No exception
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Server killed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Server killed and re-started before call n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CommunicationFailed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No exception
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
and re-started
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Running
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n+x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No exception
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No exception
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Server died
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Server died and re-started before call n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CommunicationFailed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No exception
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
and re-started
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Running
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n + x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No exception
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No exception
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.3cm
\end_inset


\end_layout

\begin_layout Standard
Please note that the timeout case is managed differently because it will
 not enter the re-connection system.
 The transparency reconnection mode is set by default to true for Tango
 version 5.5!
\end_layout

\end_body
\end_document
